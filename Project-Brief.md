# List of Teams/Projects
|팀번호|팀명|프로젝트|
|:---|:---|:---|
|01|[Optimus GPrime](#team-01)|Lamp: GPU Microarchitecture Simulator 용 LLM Hardware Performance Estimator 개발 연구
|02|[박김배](#team-02)|DoongDoongMaster: 드럼 초보자의 연습을 도와주는 어쿠스틱 드럼 채점기​
|03|[Munchkins](#team-03)|식료품 스마트 컨슈밍 어시스턴트, 트루태그(TruthTag)
|04|[심가탕후루](#team-04)|김약사: 노년층을 위한 머신러닝과 광학 문자 인식을 통한 약 복용 관리 모바일 앱
|05|[A.A](#team-05)|모락모락: 개인 맞춤형 헤어스타일을 추천받고 다양한 조건을 비교하여 본인에게 맞는 헤어 디자이너를 찾을 수 있도록 매칭해주는 서비스
|06|[너도 멸종되지 않게 조심해](#team-06)|Inkspire: Gen AI가 생성한 스토리 기반 오픈월드 텍스트 RPG
|07|[루스](#team-07)|Once : 카드 다보유자를 위한 결제 전 최대 할인 카드를 추천해 주는 AI 챗봇 서비스
|08|[ECST](#team-08)|실시간 집중도 분석으로 순수 공부 시간 집계 서비스 : Learning Mate
|09|[강철몽둥이](#team-09)|AI 기반 교내 스마트 중고거래 플랫폼
|10|[Qt](#team-10)|잇터뷰(iterview) : IT 취준생을 위한 CS 기술 구두 면접 대비 & 학습 플랫폼
|11|[로켓단](#team-11)|망하지망고 : 망고 초보 재배자를 위한 이미지 객체 검출 및 분류 기반 농작물 질병 식별 앱 서비스
|12|[팀팀탱탱후라이팬](#team-12)|어린이를 위한 비주얼 프로그래밍 기반 코딩 학습 모바일 게임: 메르헨 코더
|13|[스윗팡이크루](#team-13)|Agent.I : Generative Agent를 적용한 Human-like NPC와 상호 작용하는  사회 시뮬레이션 게임
|14|[CoB](#team-14)|PitchFinder: 사용자 음높이 기반 가요 필터링 서비스 개발
|15|[감자도리](#team-15)|다시: 은퇴한 시니어 전문가를 위한 긱 워킹 채용 플랫폼
|16|[깡총](#team-16)|주변 소리를 인식하여 상황별 알람을 받을 수 있는 서비스: 쫑긋
|17|[출발드림팀](#team-17)|AI를 활용하여 맞춤형 건강 조언을 제공하는 과민대장증후군 관리 어플리케이션, BellyWelly
|18|[뽀로로에디](#team-18)|Prompirit: Automatic Prompt Engineering Assistance to Improve AI-Generative Art Using User Emotion
|19|[TMM](#team-19)|캣치타임: 효율적인 시간 관리를 돕는 타이머 기반 캐릭터 육성 게임
|20|[쿠킹마마](#team-20)|쿡세이브: 식재료 관리를 통한 1인 가구의 식비 절감 지원 웹앱 서비스
|21|[AtoB](#team-21)|일기장 속 친구 :감정 이해와 조언의 동반자 PSYLOG
|22|[쓰리박](#team-22)|Fairy Tairy : 동화같은 그림을 자동으로 생성해주는 AI 일기 서비스
|23|[새우타코](#team-23)|Stroke-based Collaborative Drawing between AI and Human
|24|[망고젤리](#team-24)|Grounding Dino를 활용한 객체 탐지 기반 CCTV 속 흉기 난동 상황 모니터링 SDK
|25|[S](#team-25)|스케줄 추천 및 일정 관리 서비스
|26|[ETT](#team-26)|DISLODGED :  TTS 기술을 활용한 익명 감성 위로 커뮤니티
|27|[E모지](#team-27)|MosaicNow
|28|[달리리](#team-28)|속마음을 담은 일기 교환을 통해 현대인의 소외감 해소를 돕는 교환일기 웹 서비스 <비밀친구>
|29|[츄라이](#team-29)|AI를 활용한 영어 스피킹 시험 준비 앱<츄라이\|try>
|30|[일구어냄](#team-30)|CATCHUP: 컴퓨터공학과 학생에게 맞춤형 선수 학습사항 자료를 제공해주는 LLM 챗봇 웹서비스
|31|[BCS](#team-31)|DreamGuard: 더 좋은 잠을 위한 수면장애 위험도 진단 및 수면 트래킹 서비스
|32|[머니캐처](#team-32)|HobHub: 일상 속 활력 충전을 위한 AI 기반 취미 추천 및 취미 기록 아카이빙 웹 서비스
|33|[Donuts](#team-33)|공유니폼 : 야구 팬을 위한 사용자 기반 추천 유니폼 대여 앱 및 대여 자판기
|34|[고등어](#team-34)|돈워리(Be happy) - 예산 사용량 예측 AI 기반 일정 캘린더·가계부 통합 모바일 웹 서비스
|35|[log](#team-35)|영상 일기 플랫폼 log: NLP를 활용한 간편하고 생생한 일기 기록
|36|[레쏘](#team-36)|Neverland: 생성형 AI 기반 단체 추억 아카이빙 앱 서비스
|37|[re:coding](#team-37)|사용자와 자유로운 상호작용이 가능한 Gen AI 기반 스마트 스케줄링 웹 서비스
|38|[화이](#team-38)|스킨트리: 협업필터링과 머신러닝을 활용한 성분 맞춤형 화장품 추천 서비스
|39|[순간포착](#team-39)|객체 인식과 OCR을 활용한 객관·단답식 시험지 채점 AI 소프트웨어
|40|[흰토끼](#team-40)|FingerSpell: 초등학생 장애 인식 개선을 위한 모션인식 수어 게임
|41|[초이배리](#team-41)|MATHORY: 재미있는 프롬프트 생성 기반 스토리텔링형 초등 수학 교육 게임
|42|[왈라비](#team-42)|DRIVE GUARDIAN : 운전자 모니터링 앱 서비스
 
# Team-01
| (1) 과제명 | Lamp: GPU Microarchitecture Simulator 용 LLM Hardware Performance Estimator 개발 연구
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 01-Optimus GPrime |
| (3) 팀원 역할 분담 | 황재은 (2176427): 리더, CUDA Kernel 프로파일링, GEMM 구현<br>정은비 (2173109): 팀원, NVTX Range 프로파일링, Softmax 구현<br>최이경 (2276327): 팀원, GPU Memory 프로파일링, GEMM RELU 구현			 |
| (4) 팀 지도교수 | 윤명국 |
| (5) 팀 멘토 | 전원 / ETRI / 연구원 |
| (6) 과제 키워드(keywords) | GPU Simulator, LLM, Hardware Performance Estimator  |
| (7) 과제 내용 요약 | 현재, GPU Microarchitecture Simulator에서 실험할 수 있는 LLM application의 부재로, GPU Architecture 측면에서의 LLM 연구가 활성화되기 어려운 실황이다. 따라서, GPU Microarchitecture Simulator에서 실행 가능한 LLM Performance Evaluator를 구현하여 오픈소스로 배포함으로써, 원활한 GPU Architecture LLM 연구 환경을 제공하고자 한다. 						 |
| (8-1) 과제: 문제의 정의 | GPU Microarchitecture Simulator란 GPU (Graphic Processing Unit)의 설계와 성능 최적화를 위해 사용하는 도구이다. 연구자들이 다양한 구조적 변화를 시뮬레이션 함으로써 Hardware에서 실행 없이 그 효과를 예측할 수 있다는 유용함을 제공한다. 특히, 더 복잡해지고, 요구하는 연산 능력이 증가하고 있는 대규모 언어 모델 (이하 LLM)을 효율적으로 지원하기 위한 GPU 구조에 관한 연구의 중요성이 강조되고 있다. <br>그러나, 현재 GPU Microarchitecture Simulator에서 사용할 수 있는 성능 분석 application들은 LLM의 활발한 사용 이전에 개발되었기 때문에 대부분 CNN, LSTM 등과 같은 전통적인 인공지능 모델에 초점을 맞추고 있다. 즉, GPT와 같은 모델에서 사용하는 Transformer의 특성을 반영한 성능 평가 방법은 전무하다. 이는 연구자들이 최신 기술을 위한 새로운 architecture 설계나, 최적화 기법의 효과를 정확히 평가하기 어렵게 만든다. 따라서, LLM에 특화된 Performance Evaluator를 개발함으로써 이러한 문제를 해결하여 LLM을 위한 GPU Architecture 연구를 활성화하고자 한다.  |
| (8-2) 과제: 기존연구와의 비교 | 본 팀은 다양한 GPU Microarchitecture Simulator 용 Application을 조사하였다. 그 중 대표적인 Benchmark Suite(Application의 집합)는 아래 두 가지이다. <br><br>1) Polybench Benchmark Suite [2]<br>- Polybench는 2D Convolution, 2D Matrix Multiplication, GEMM(General Matrix Multiplication)과 같은 GPU 용 커널로 이루어진 Benchmark Suite이다. 다양한 Application으로 구성되어 GPU Microarchitecture의 성능을 측정하는 데에 주로 활용되어 왔으나, 이는 2012년에 개발된 것으로 Outdated Application이 많다. 특히, 최근 중요도가 급부상한 DNN 및 LLM Application이 포함되지 않는다는 한계점이 있다.<br><br>2) Tango Benchmark Suite [3]<br>- Tango는 GPU simulator 및 FPGA 환경에서 실행할 수 있는 LSTM, CNN과 같은 DNN Model Application으로 이루어진 Benchmark Suite이다. DNN 라이브러리 또는 프레임워크의 설치 없이 실행 가능한 Application이라는 것에 의의가 있으며, 유명한 CNN 모델 5개와 RNN 모델 2개를 포함하고 있다. 하지만 Tango 또한 2019년에 개발된 것으로, LLM Application이 부재 한다.<br><br>본 연구에서는 GPU Simulator에서 실행하고 성능을 측정할 수 있는 LLM Application을 구현하여, LLM의 Hardware Performance를 측정해주는 프레임워크를 구현하고자 한다. |
| (8-3) 과제: 제안 내용 | GPU Microarchitecture Simulator에서 실행 가능한 LLM Hardware Performance Estimator를 개발하는 것을 목표로 한다. 이는 LLM Application과 Simulation Performance Results를 제공하는 Evaluator를 포함한 LLM Framework로 구현하여 제공될 예정이다. 해당 LLM Application은 LLM의 연산 구조적 특징을 반영하여 설계될 것이다. |
| (8-4) 과제: 과제의 주요 기능 | Lamp는 LLM의 연산 구조를 반영한 LLM Application과 Hardware 연산 성능을 측정하는 Performance Evaluator를 포함한다. <br><br>1) LLM Application : LLM 연산을 위한 Kernel과 Input data를 제공한다. <br>2) Performance Evaluator :  CUDA Runtime Library를 통해 GPU Microarchitecture Simulator인 GPGPU-Sim[7]에서 LLM Kernel들을 실행하며, 각 Kernel의 성능 결과를 분석하여 요약해주는 역할을 한다. <br><br>이를 통해 연구자들은 LLM 연산에 관한 Hardware Performance 결과를 얻음으로써 LLM 최적화 GPU Architecture 연구의 발전을 도모할 수 있다.   |
| (8-5) 과제: 구현 방법 | 1) LLM Application<br>① Data <br>- 목적: Application를 실행하기 위한 각 Kernel의 Input Tensor를 제공한다.<br>- 기능: 다양한 크기와 형태의 입력 데이터를 포함하며, 실제 LLM (LLaMA) Task를 반영한 데이터 구조를 사용한다. 이때, Input Tensor의 전처리, 로딩, 초기화를 담당하는 모듈을 포함한다.<br>② LLM Kernel Code<br>- 목적: LLM 연산을 수행하는 Core Kernel 코드를 제공한다.<br>- 기능: GEMM, GEMM RELU, softmax 와 같은 LLM 연산의 대표성을 띄는 Kernel Code를 포함한다. 다양한 GPU Architecture에서의 성능을 평가할 수 있도록 최적화하여 구현하도록 한다. (Kernel 선정 방식은 보고서 참고)<br>③ LLM Application Host Code<br>- 목적: Application Kernel을 실행한다.<br>- 기능: LLM Application의 각 Kernel을 호출하고, 실행하는 함수를 포함한다.<br>④ README (사용자 매뉴얼)<br>- 목적: 사용자가 Lamp를 쉽게 사용할 수 있도록 돕는 매뉴얼을 제공한다.<br>- 기능: 설치 방법, 실행 방법, 결과 분석 방법과 같은 Lamp Framework를 활용하기 위해 사용자가 필요로 하는 정보를 제공한다.<br><br>2) Performance Evaluator<br>Performance Evaluator는 LLM Application의 Kernel 시뮬레이션을 통해 얻은 데이터를 분석하고 성능을 평가하는 데 필요한 도구들을 제공한다. 구체적으로는 다음과 같은 두 부분으로 구성된다:<br>① Runner (GPGPU-Sim Executor)<br>- 목적: GPGPU-Sim 환경에서 LLM Application의 다양한 Kernel들을 실행하는 주체이다. 이는 실제 GPU 환경을 모사하여, Kernel 코드의 실행 결과와 성능을 산출한다.<br>- 기능: GPU Configuration과 LLM Application에 필요한 설정을 마친 후, LLM Application Simulation을 위한 GPGPU-Sim 코드들을 실행한다. <br>② Summarizer (성능 요약기)<br>- 목적: 실행된 Kernel들의 성능 결과를 종합적으로 분석하고 요약하는 역할을 한다. <br>- 기능: GPGPU-Sim에서 산출된 Kernel들의 성능 지표들을 요약하여, 사용자가 쉽게 이해할 수 있는 형태로 성능 결과를 제공한다. 이는 연구자들이 LLM Application의 실행 결과를 바탕으로, GPU Architecture 성능을 평가하는 데 도움을 준다. |
| (8-6) 과제: 세부 기술 | 1) CUDA [8]<br>NVIDIA에서 제공하는 CUDA(Compute Unified Device Architecture)는 NVIDIA GPU를 사용하여 Application 실행을 가속화하기 위해 필요한 병렬 컴퓨팅 플랫폼이자 API 모델이다. 본 연구에서는 CUDA를 사용하여 GPU의 병렬성을 최대한으로 활용될 수 있도록 Benchmark Kernel을 구현하고자 한다. <br><br>2) GPGPU-Sim [7]<br>GPGPU-Sim은 NVIDIA GPU를 모델링한 사이클 수준의 시뮬레이터(cycle-level simulator)이다. GPGPU-Sim에서는 CUDA와 OpenCL 기반의 다양한 GPU 연산 워크로드(computing workloads)를 실행하고 성능을 측정할 수 있다. 본 연구에서는 GPGPU-Sim을 타겟 GPU microarchitecture simulator로 사용할 예정이며, GPGPU-Sim에서 실행 가능한 CUDA 기반의 LLM 성능 분석 application를 구현할 예정이다. 추가로 GPGPU-Sim에서 실행한 다수의 커널 결과를 토대로, 전체 LLM Performance Evaluator의 성능을 종합적으로 분석하기 위한 코드를 추가할 계획이다.<br><br>3) CUTLASS Library [6]<br>CUTLASS (CUDA Templates for Linear Algebra Subroutines and Solvers)는 NVDIA에서 개발한 고성능 CUDA C++ 템플릿 라이브러리로써, 고차원 행렬곱 (GEMM) 연산 및 기타 선형 대수 연산을 위한 구현을 제공한다. <br>그러나, CUTLASS Library는 현재 GPU Microarchitecture Simulator에서 일부 커널의 연산이 지원되지 않아 LLM Performance Evaluator 구현에 장애물이 되기 때문에, 해당 커널을 분석하여 CUTLAS와 유사한 커널을 구현하고자 한다. <br><br>4) NVIDIA Nsight Profiling Tools [4][5]<br>NVIDIA에서 제공하는 Nsight Profiling Tools (Nsight Systems, Nsight Compute)는 CPU 및 GPU에서의 Application과 Kernel 실행 성능을 시스템적으로 분석하기 위한 도구이다. 본 연구에서는 Profiling을 통해 실행되는 소프트웨어의 메모리 사용 양상과 계산 양상을 파악하여 프로그램의 Bottleneck을 파악하고 개선해 나가는 일련의 과정을 통해 시스템의 Memory Resource와 Computation Resource가 경제적으로 사용되도록 소프트웨어를 최적화하고자 한다. |
| (8-7) 과제: 기대 효과 및 의의 | 1) GPU Microarchitecture Simulator에서 실행 가능한 LLM Hardware Performance Estimator의 개발을 통해 연구자들은 LLM의 Workload를 반영하는 실험 환경을 구축할 수 있다. <br>2) GPU Architecture 설계와 최적화 과정에서 보다 정확한 결정을 내릴 수 있게 하며, LLM을 효율적으로 지원하는 더 발전된 GPU 구조의 개발로 이어지게 될 것이다. <br>3) 연구자들이 동일한 기준으로 성능을 측정하고, 결과를 비교할 수 있게 되어, 공유와 협업을 촉진함으로써 지식의 축적과 빠른 기술 발전을 도모할 수 있다. |
| (9) 데모 내용 |  Lamp의 Evaluator를 사용하여 LLM 하드웨어 성능 결과를 제시하는 과정을 보인다. 먼저 Runner를 사용하여 본 팀이 구현한 LLM Kernel의 Simulation을 런치하고, Simulation Output이 출력되는 모습을 보인다. 이후 Summarizer를 사용하여 각 Kernel의 성능 결과를 바탕으로 요약한 LLM의 최종 성능 결과를 제시한다. |
| (10) 기타 | 참고자료<br>[1] Touvron, Hugo, et al. "Llama: Open and efficient foundation language models." arXiv preprint arXiv:2302.13971 (2023).<br>[2] Grauer-Gray, Scott, et al. "Auto-tuning a high-level language targeted to GPU codes." 2012 innovative parallel computing (InPar). Ieee, 2012.<br>[3] Karki, Aajna, et al. "Tango: A deep neural network benchmark suite for various accelerators." 2019 IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS). IEEE, 2019.<br>[4] NVIDIA Nsight Systems. https://developer.nvidia.com/nsight-systems <br>[5] NVIDIA Nsight Compute. https://developer.nvidia.com/nsight-compute <br>[6] CUTLASS Library. https://github.com/NVIDIA/cutlass <br>[7] GPGPU-Sim GitHub Repository. https://github.com/gpgpu-sim/gpgpu-sim_distribution<br>[8] CUDA C++ Programming Guide. https://docs.nvidia.com/cuda/cuda-c-programming-guide/<br>[9] Ashish Vaswani, et al. “Attention Is All You Need” arXiv preprint arXiv:1706.037 (2017). |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-02
| (1) 과제명 | DoongDoongMaster: 드럼 초보자의 연습을 도와주는 어쿠스틱 드럼 채점기​
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 02-박김배 |
| (3) 팀원 역할 분담 | 배수아 (2071027): 리더, 서버 개발 <br>김재서 (2071015): 팀원, OMR 모델 개발<br>박지영 (2076168): 팀원, 앱 개발|
| (4) 팀 지도교수 | 오세은 |
| (5) 팀 멘토 | 소준섭 / 블루펭귄 / 대표 |
| (6) 과제 키워드(keywords) | 드럼, ADT(Automatic Drum Transcription), OMR(Optical Music Recognition) |
| (7) 과제 내용 요약 | 박자감 및 자기확신이 부족한 드럼 초보자를 위해, 악보 프롬프트와 어쿠스틱 드럼 채점 기능을 갖춘 어플리케이션을 통해서 드럼 초보자의 연습을 돕고자 한다. |
| (8-1) 과제: 문제의 정의 | 드럼 초보자의 경우, 악보 해석 능력이 부족해서 박자 자체를 이해하지 못하는 경우도 있고, 이해하더라도 가사가 없는 부분에서 박자를 놓치기 쉽다. 또한, 속도가 빠르고 박자가 복잡한 경우에도 어려움을 겪는다. 자신의 연주가 정확한지, 틀렸다면 정확히 어떤 부분이 어떻게 틀렸는지를 초보자가 혼자 판단하기 어렵기 때문에 이를 해결하고자 한다. |
| (8-2) 과제: 기존연구와의 비교 | PracticeBird: 실제 피아노 소리를 인식해, 피드백을 제공하고 채점해주는 등 피아노 연습을 도와주는 앱<br>- 지원 악기: 어쿠스틱 피아노, 디지털 피아노 등 모든 피아노<br>- 악기 연주 실시간 피드백 제공 및 연주 완료 후 채점을 통한 report 제공<br>- “피드백 모드”, “연주 모드”, “자동 음악 연주” 모드가 있어 다양하게 연습 가능<br>- 앱 내 등록된 곡들만 연주 가능하다는 한계 존재<br><br>PianoKiwis: 실제 피아노 소리를 인식해, 피드백을 제공하고 채점해주는 등 피아노 연습을 도와주는 앱<br>- 지원 악기: 어쿠스틱 피아노, 디지털 피아노 등 모든 피아노<br>- 악기 연주 완료 후 채점을 통한 report 제공<br>- “피드백 모드”, “연주 모드”, “자동 음악 연주” 모드가 있어 다양하게 연습 가능<br>- 사용자가 직접 XML 파일 형식의 악보 등록 가능<br><br>Melodics: MIDI 기기와 연동하여 곡을 연습해 볼 수 있는 Desktop App<br>- 지원 악기: 키보드, 핑거 드럼, 전자 드럼 등의 MIDI 악기<br>- 실시간으로 연주가 기록되는 형태로 피드백 제공<br>- 연주가 끝난 후, 종합 점수 제공<br>- 게이미피케이션을 통해 지속적 연습에 대한 동기 부여<br>- 어쿠스틱 드럼에서 사용할 수 없다는 한계 존재<br><br>Yamaha 전자드럼: 전자드럼에 내장되어 연습을 돕는 소프트웨어<br>- 연주가 끝난 후, 각 악기 별 점수 제공<br>- 장르 별로 준비된 곡에 대해 강습 기능 존재<br>- 스트로크 연습 가능<br>- 어쿠스틱 드럼에서 사용할 수 없다는 한계 존재<br><br>종합하면, 악기를 학습할 수 있는 서비스는 있지만 사용자들이 **기존에 치던 어쿠스틱 드럼과 함께 사용하지 못하는 한계점**이 존재한다.<br>![그림3](https://github.com/bsa0322/CapstoneDesign-24-1H/assets/68186101/d4030371-7648-440a-94fc-fdb5a3d2a0f1)|
| (8-3) 과제: 제안 내용 | 1. 박자를 맞추기 어려워하는 초보자를 위한 **<악보 프롬프트>** 기능: 현재 연주하고 있는 위치를 박자에 맞게 프롬프트 함으로써 드럼 초보자의 연습에 도움을 준다. <br> 2. 연주 정확도를 스스로 판단할 수 없는 초보자를 위한 **<연주 채점>** 기능: 사용자의 연주를 AI가 인식한 후, 악보를 기반으로 연주를 채점해서 결과를 분석 후 레포트로 보여줌으로써 스스로 연습의 방향성을 잡아가도록 도움을 준다.  |
| (8-4) 과제: 과제의 주요 기능 | 1. **악보 등록**: 서비스에서 제공하는 악보 외에, 사용자가 연주하고 싶은 악보를 직접 이미지로 등록하여 애플리케이션 내에서 사용할 수 있도록 한다.<br>![image](https://github.com/bsa0322/CapstoneDesign-24-1H/assets/68186101/89bc74fa-692e-49d9-b6b7-c38cd011db2d)<br>2. **악보 프롬프트**: 드럼 초보자는 연주 중 악보를 놓치는 일이 많기 때문에, 현재 연주 중인 위치를 악보 상에 시각적으로 보여주어 연습에 도움을 준다.<br>![image](https://github.com/bsa0322/CapstoneDesign-24-1H/assets/68186101/5564acc7-741f-472b-bbcc-4414b2675b78)<br>3. **연주 채점**: 악보와 사용자의 연주를 비교하여 악기 및 박자 정확도를 기준으로 채점된 점수 및 결과 레포트를 제공한다. 사용자는 이를 통해 자신이 보완해야 하는 부분을 알 수 있고, 연습의 방향성을 설정할 수 있다.<br>![image](https://github.com/bsa0322/CapstoneDesign-24-1H/assets/68186101/fdf5508a-4265-49b3-bdae-7dc1a6bc6614)<br>4. **연습장**: 악기 연습의 특성 상 본 애플리케이션은 일회성이 아니라, 지속적으로 꾸준히 사용하는 것이 바람직하다. 따라서, 사용자의 점수 및 정확도 추이를 제공하여 사용자가 연습이 잘되고 있는지 한 눈에 확인할 수 있도록 하고, 꾸준한 연습을 위한 원동력을 주고자 한다.<br>![image](https://github.com/bsa0322/CapstoneDesign-24-1H/assets/68186101/776b1130-f104-46bd-9ad1-0e04fae7c7de)<br>5. **구간 반복**: 악보에서 연습이 필요한 특정 구간을 반복해서 연습한다. <br>![구간반복](https://github.com/bsa0322/CapstoneDesign-24-1H/assets/68186101/af4ae0e3-3e53-4d66-9588-d53cd7662862)|
| (8-5) 과제: 구현 방법 |1. **<악보 등록>** 기능 구현을 위해 **<악보 인식 AI (Optical Music Recognition)>** 기술을 도입하였다.<br>1-1. 데이터셋<br>1-1-1. 악보 이미지, 음표 정보(MusicXML), 마디 위치 정보(json)<br>1-2. 전처리 단계<br>1-2-1. 악보 이미지로부터 마디 위치 정보에 맞게 이미지를 추출해, 마디 이미지인 Input 데이터를 생성하였다.<br>1-2-2. 음표 정보를 숫자로 토큰화할 수 있도록 직접 정의한 Annotation Output 데이터를 생성하였다.<br>1-3. 문자인식(Optical Character Recognition, OCR)에 쓰이는 CTC 손실 함수를 통해 CRNN 모델 학습시켰다.<br>1-4. 후처리 단계<br>1-4-1. 모델의 예측 결과인 Annotation을 음표 정보(MusicXML)로 변환하여 앱에서 활용한다. <br>➔ 사용 기술: OpenCV 4.5, CRNN, CTC Loss <br><br> 2. **<연주 채점>** 기능 구현을 위해 **<드럼 전사 AI (Automatic Drum Transcription)>** 기술을 도입하였다. <br>2-1. Segment & Classify: 드럼 오디오 신호 강도를 기반으로 Onset을 인식하여 오디오 조각으로 자르고, 각 조각의 특성에서 패턴을 인식하는 방식이다.<br>2-1-1. Onset Detect [박자 전사] - Python Library인 librosa의 *onset_detect* 함수를 활용하였다. <br>2-1-2. Feature extraction - 동적 길이 분할 방식으로 오디오 파일을 각 Onset별로 자르는 전처리를 거친 후, Librosa를 활용해 오디오 파일을 Mel-spectrogram으로 Feature를 추출하였다.<br>2-1-3. Classification(CRNN) [악기 전사] - Convolutional Layer와 Recurrent Neural Layer를 결합한 CRNN 모델을 통해 추출한 Feature를 학습해 한 Onset에 대해 음을 구분하는 모델을 학습시켰다.<br>➔ 사용 기술: Librosa 0.10, CRNN, BCE Loss<br><br>3. **애플리케이션**: 유저와 통신하는 UI/UX 제공 및 로컬 데이터베이스 관리<br>3-1. Framework: Flutter<br>3-2. 주요 opensource<br>3-2-1. `drift`: SQLite3를 기반으로 하는 ORM 라이브러리<br>3-2-2. `fl_chart`: 유저의 연습 기록을 시각화 하기 위해 사용하는 그래프 라이브러리<br>3-2-3. `opensheetmusicdisplay`: MusicXML 데이터를 악보로 렌더링하는 라이브러리<br>3-3. 유저와 직접적으로 통신하는 모바일 애플리케이션으로, 동작 환경은 iOS 태블릿이다.<br>3-4. 사용자 편의를 위해 악보 및 연습장의 저장, 관리 기능을 제공한다.<br><br>4. **시스템 아키텍처**<br>![그림4](https://github.com/bsa0322/CapstoneDesign-24-1H/assets/68186101/d7db75cc-271d-4b72-9fd8-7e0cdf0fe036)|
| (8-6) 과제: 세부 기술 | 1. **<악보 인식 AI (Optical Music Recognition)>**<br>: 악보 이미지를 MusicXML 형태로 데이터화하기 위해 필요한 모듈이다.<br>![image](https://github.com/bsa0322/CapstoneDesign-24-1H/assets/68186101/7afd7521-fcc2-4db2-9226-a3d3214863c4)<br>- Input: 악보 이미지<br>- Pre-processing: OpenCV로 Binary 이미지 변환 및 Resize<br>- Model Architecture: CRNN (conv2D + bi-LSTM)+CTC Loss<br>- Output: 음표, 쉼표, Clef, 마디선 Sequence<br>- Post-processing: MusicXML로 변환 <br><br> 2. **<드럼 전사 AI (Automatic Drum Transcription)>**<br>: 사용자의 연주를 악보 데이터와 비교해서 채점하기 위해 전사하는 과정에서 필요한 모듈이다. <br>![image](https://github.com/bsa0322/CapstoneDesign-24-1H/assets/68186101/7e340609-d86c-4b9c-b46c-7275d9083a1b)<br> - Input: 드럼 오디오 파일<br>Pre-processing: Onset Detection 후, 동시에 친 음과 연이어 친 음을 구분하기 위해 각 Onset에 대해 이후 등장하는 음이 동시에 쳤다고 볼 수 있는지 판단을 한 후, 이어지는 다음 음이 발생하기 전까지 자른 후, Mel-spectrogram으로 Feature를 추출.<br>- Model Architecture: CRNN (conv1D + bi-LSTM)<br>- Output: 각 악기별 예측 확률<br>- Post-processing: threshold 이상의 확률이 나온 라벨을 예측 결과로 정함.|
| (8-7) 과제: 기대 효과 및 의의 |1. 악보를 기반으로 객관적인 피드백을 제공함으로써 사용자는 자신의 드럼 연주 능력에 따라 개선이 필요한 부분을 시각적으로 볼 수 있다. 해당 결과를 바탕으로 사용자는 보다 구체적인 연습 목표를 설정할 수 있다.<br>2. 자신의 드럼 연주에 대해 수치화된 점수를 받음으로써 사용자는 연주에 재미를 느낄 수 있다.|
| (9) 데모 내용 | 0. 소셜 로그인을 통해 앱에 접속한다.<br>1. 악보 등록 과정: 악보를 이미지로 등록하면, 모델을 통해 파싱된 결과를 받아온다.<br>2. 연습장 생성: 연습추가 버튼을 눌러 앞서 등록한 악보를 고른 후, 새로운 연습장을 추가한다.<br>3. 완곡 연습 시작: 추가한 연습장에서 완곡 연주 버튼을 눌러 연습을 시작하고, 악보 프롬프트 화면으로 넘어간다.<br>4. 악보 프롬프트: 앞 과정에서 파싱된 데이터를 통해 사용자가 지정한 속도에 맞추어 악보 프롬프트가 동작한다. 이 때 실제 드럼을 연주하기 어렵기 때문에 녹음본을 재생할 계획이다.<br>5. 채점 레포트 확인: 연주가 끝나고 모델 서버에서 처리가 끝나면 앱에 푸시 알림을 통해 결과가 전달된다. 최종적으로 점수, 연주의 정확도를 확인할 수 있으며 악보 내에서 사용자가 잘못 친 부분 또한 확인이 가능하다.<br>6. 연습 기록 확인: 연습장에서 그간의 연습 기록을 볼 수 있다. 또한 점수 및 정확도의 변화 추이를 그래프로 확인할 수 있다.<br>7. 구간 반복 연습: 이 전의 연습 레포트에서 연습이 필요한 구간을 선택하여 연습을 진행한 후, 결과 화면을 확인한다. |
| (10) 기타 | 👨‍💻[Github 프로젝트 링크](https://github.com/DoongDoongMaster) <br> 🎞[데모 동영상](https://1drv.ms/v/s!Am4JSYfby2lzmP99JINBPLmogUtcBQ?e=QsDhsd)|
 
[Return TOP](#list-of-teamsprojects)
 
# Team-03
| (1) 과제명 | 식료품 스마트 컨슈밍 어시스턴트, 트루태그(TruthTag)
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 03-Munchkins |
| (3) 팀원 역할 분담 | 김현수(2176113): 리더, 프론트엔드 프로그래밍<br>김경민(2062008): 팀원, 백엔드 프로그래밍, 클라우드, UI/UX 디자인<br>한현경(2176410): 팀원, 딥러닝 모델링(OCR, 챗봇) |
| (4) 팀 지도교수 | 심재형 |
| (5) 팀 멘토 | 박건영 / 토스증권 / 개발자 |
| (6) 과제 키워드(keywords) | 스마트컨슈밍, 식료품의 슈링크/스킴 플레이션, 구매 판단 도우미 |
| (7) 과제 내용 요약 | 식료품을 판매하는 기업이 소비자 모르게 가격은 동결시킨 채로 용량을 줄이거나 원재료 구성을 저렴한 것으로 바꿈으로써 소비자들에게 비용 부담을 전가하는 슈링크/스킴플레이션이 발생할 때마다 이에 대한 정보를 주기적으로(7일) 업데이트해 알려줍니다. 이때, 한 상품의 용량 및 원재료 변화 추이를 각각 그래프와 표의 형식으로 보여줍니다. 아울러, 슈링크/스킴플레이션이 일어난 제품을 대체할 수 있는, 현재 구매하고 있던 상품과 가격 혹은 원재료 측면에서 가장 유사한 타사의 제품을 챗봇을 통해 추천해줌으로써 식료품 소비자가 기업에 대항하여 현명한 소비를 할 수 있게끔 돕는 모바일 웹애플리케이션입니다. |
| (8-1) 과제: 문제의 정의 | 1. 식료품 스킴/슈링크플레이션 발생 사실 자체를 인지하기 어려움 <br> 식료품의 가격은 그대로인 채, 식료품의 원재료나 용량이 줄어들었을 때, 기업과 개인의 정보 비대칭성으로 인해 소비자는 그 사실을 빠르게 알지 못한다. <br> 2. 스킴/슈링크플레이션 발생 시 가격 및 구성 성분의 변동을 파악하기 어려움 <br>- 스킴/슈링크 플레이션이 일어났음을 소비자가 인지하였다고 해도, 소비자는 그 전의 식료품 원재료와 용량 정보를 찾기 쉽지 않아, 이전과 비교했을 때 얼마나 큰 변화가 생겼는지 알기 어렵다. <br> 3. 스킴/슈링크플레이션이 발생한 상품의 대체제 찾기의 어려움 <br> 소비자가 스킴/슈링크 플레이션이 일어났음을 알고, 이전 원재료 및 용량 정보를 알게 되어, 현재 구매하던 식료품의 구매를 그만두고 대체품을 찾으려 해도, 이와 비슷한 가격 혹은 비슷한 원재료를 가진 상품이 무엇인지 추천해주는 서비스가 존재하지 않는다. |
| (8-2) 과제: 기존연구와의 비교 | 1. 한국소비자원 '소비자24' <br> 2023년 12월, 정부가 소비자 24를 이용해 중량 변경 정보를 제공한다는 정책을 발표하였으나, (https://www.sedaily.com/NewsView/29YJ8QVPOQ) 아직 실행되기 전의 정책이며, 현재는 6,305,622개 상품의 현재 원재료와 중량에 대한 정보만을 볼 수 있게 되어 있다. <br>장점: 정부 운영 사이트로, 한 사이트에서 국내에 현존하는 대부분의 상품의 원재료와 중량 정보를 공신력 있게 볼 수 있다. <br> 단점: 가격 정보가 부재하여 소비자들은 현재 가격 정보를 해당 사이트 내에서 확인할 수 없으며, 이에 따라 스킴/슈링크플레이션에 대응하기 위해서는 소비자의 추가적인 노력이 필요하다. <br> 2. 한국소비자원 '참가격' <br> 장점: 식료품의 1주 전, 1개월 전, 6개월 전, 1년 전의 가격 변동을 시각화하여 제공한다. <br> 단점: 단위 용량 당 가격이 아닌, 해당 상품의 그 당시 판매가만을 제공하므로, 슈링크플레이션의 발생 여부를 확인할 길이 없다. 또한 원재료에 대해서는 다루지 않아 스킴플레이션에 대응하지 못한다. |
| (8-3) 과제: 제안 내용 | [주요 기능] <br> 1. 변동사항 알림 기능 <br> 소비자가 즐겨찾기에 등록한 상품에서 슈링크 혹은 스킴플레이션이 발생했을 시, 소비자가 해당 정보를 놓치지 않을 수 있게 “A 상품의 가격이 증가했어요”와 같이 발생 사실에 대한 알림 메시지를 전송한다. <br> 2. 스킴/슈링크플레이션 정보 시각화 대시보드 <br> 대부분의 식료품을 취급하는 대형 유통업체(이마트)의 온라인 판매 사이트에서 식료품의 가격과 원재료, 용량, 브랜드 등의 상품 정보를 크롤링을 통해 수집한다. OCR 을 이용해 원재료표를 분석하여 이를 비롯해 크롤링된 상품 정보를 DB 에 저장한다. 주기적인 크롤링을 통해, 기존 DB 의 정보와 새로운 크롤링 정보를 비교 분석하여, 슈링크 혹은 스킴 플레이션이 발생했을 시, 발생한 날짜와 함께 DB 정보를 업데이트한다. 이때 기존 정보를 삭제하는 것이 아니라 기존 정보의 데이터 업데이트 날짜와 함께 기존 가격, 용량 대비 가격, 원재료표 정보를 DB에 저장해둔다. 이를 통해 사용자는 그동안 스킴 혹은 슈링크플레이션이 발생했던 날짜 목록을 확인할 수 있고, 날짜를 클릭하면, 해당 날짜의 상품 정보를 조회함으로써 현재의 가격, 용량, 원재료표와 과거의 것을 스스로 비교 분석할 수 있게 된다. <br> 3. 대체품 추천 챗봇 <br> 슈링크 혹은 스킴플레이션이 발생한 식료품의 구매를 중단하고 싶어도, 이를 대체할 마땅한 상품을 쉽게 찾지 못해 어쩔 수 없이 구매를 지속하는 상황을 방지하기 위해, 원재료 유사품 또는 가격 유사품을 추천하는 챗봇이다. 소비자가 대체하고 싶은 상품 정보와 함께 어떤 기준(예를 들어, 가격이 비슷한 상품이나 구성 성분이 비슷한 상품 등)을 바탕으로 대체품을 추천받고 싶은지를 챗봇에게 입력하면, 이에 맞는 식료품을 추천한다. <br> [부가 기능] <br> 1. 로그인/회원가입 <br> SNS 연동 로그인 기능을 제공한다. <br> 2. 리뷰 <br> 리뷰 작성/삭제: 원하는 식료품에 대한 리뷰를 작성하고 삭제할 수 있는 기능이다. 리뷰 좋아요: 다른 사용자의 리뷰에 공감 버튼을 누를 수 있다. <br> 3. 상품 검색 <br> 검색 방법에는 원재료 검색, 상품명 검색, 이미지 검색 3가지가 있다. 상품명 검색: 상품명을 텍스트로 검색하여 상품을 조회한다. 원재료 검색: 검색에 포함할 원재료와 제외할 원재료를 설정하면, 검색 조건에 해당하는 원재료를 가지는 상품만을 조회한다. 이미지 검색: 사용자가 식료품 구매처에서 상품 태그를 사진 찍으면, OCR 모델을 이용해 상품 정보를 인식하고, 인식한 정보를 활용해 상품을 조회한다. 검색 후 검색 결과에 해당하는 상품 리스트가 표시되고, 상품을 클릭하면 해당 상품의 상세 정보 페이지로 이동한다. 상품 검색 페이지에서는 사용자들이 많이 검색한 상품이 순서대로 '인기 검색어' 리스트에 표시된다. <br> 4. 즐겨찾기 <br> 마음에 들거나 스킴/슈링크플레이션 여부를 트래킹하고자 하는 상품이 있으면, UI 상에서 해당 상품을 즐겨찾기하여, 추후 가격이나 원재료에 변동이 생겼을 때 실시간 알림을 받을 수 있도록 한다.  |
| (8-4) 과제: 과제의 주요 기능 | 1. 상품 별 용량 및 원재료 변동 추이 대시보드<br>2. 슈링크플레이션 / 스킴플레이션 알림 <br>3. 식료품 구매 판단 도우미 챗봇 <br> 4. 식료품 검색  |
| (8-5) 과제: 구현 방법 | 1. 변동사항 알림 기능<br>[FE]: 슈링크 / 스킴 플레이션이 발생한 시점에, 슈링크 / 스킴 플레이션이 발생했다는 알림을 사용자에게 전송하는, 알림 기능을 구현하기 위해, "react-query" 라이브러리를 도입하였고, 1) 서버에 저장된 "알림 데이터"에 변동이 생겼을 때 2) 프론트에 저장된 "알림 데이터" 캐쉬를 삭제한 뒤 3) 새로운 "알림 데이터"를 요청하는 기능을 구현하였습니다.<br>[BE]: API 서버의 DB Batch 모듈을 통해 크롤링을 진행하여 변경된 상품 정보(가격)를 Database에 저장하며, 변경된 상품 원재료 이미지를 Model 서버의 API를 호출하여 전달한다. Batch 모듈의 작업 완료 이후 API 모듈에서 usecase를 실행하여 Domain 모듈을 거쳐 DB에서 알림을 보낼 대상 정보를 조회한다. 조회한 결과를 바탕으로 API 모듈에서 FCM에 알림 push를 보내는 usecase를 실행하여 알림을 보내야 한다는 내용을 클라이언트에 전달한다.<br>[ML]: 상품 정보를 자동으로 DB화하는 파이프라인을 형성하기 위해, Yolov5 및 EasyOCR 모델을 finetuning하여 상품 원재료 표의 문자를 인식하는 모듈을 구현하였다.<br><br>2. 스킴/슈링크플레이션 정보 시각화 대시보드<br>[FE]: 어떤 특정한 상품에 대해 현재까지 일어난 가격, 용량 변화를 꺾은 선 그래프로 사용자에게 보여주는, 대시보드의 차트 기능을 구현하기 위해, "nivo / line" 라이브러리를 도입하였고, 1) 시간 변화를 x 축으로 하고 2) 가격 또는 용량을 y 축으로 하는 3) 꺾은선 그래프를 구현하였습니다.<br>[BE]: API 서버에 호출된 API에 맞추어 API 모듈의 usecase를 실행한다. Domain 모듈을 통해 상품 정보를 조회하고, API의 response 형태로 반환한다.<br><br>3. 대체품 추천 챗봇<br>[FE]: 사용자가 텍스트를 입력하고, 사용자가 입력한 값에 대응하는 답변을 하는, 챗봇 기능을 구현하기 위해, "react-chatbot-kit" 라이브러리를 도입하였고, 1) 사용자가 챗봇에게 채팅을 입력하고 2) 사용자가 입력한 값을 parse 한 뒤 3) 사용자가 입력한 값에 대응하는 채팅을 전송하는 챗봇 기능을 구현하였습니다.<br>[BE]: API 서버의 ChatBot API가 호출되었을 경우, API 모듈에서 Model 서버의 ChatBot API를 호출하는 usecase를 수행한다. 모델 서버의 API 모듈에서는 ChatBot API를 통해 전달된 텍스트의 내용을 추론한 결과를 반환하고, API 서버의 Domain 모듈에서 사용자가 원하는 기능에 따라 CRUD 기능을 수행한다<br>[ML]: 사용자 담화의 의미를 인식하기 위해, KoBERT 모델을 finetuning하여 사용자의 채팅을 서비스 기능 중 하나로 분류하는 모듈을 구현하였다.<br><br>[부가 기능]<br>1. 로그인/회원가입<br>[FE]: 소셜 로그인 기능을 구현하기 위해, "axios" 라는 라이브러리를 도입하였고, 1) access 토큰과 refresh 토큰을 사용해 서버와 통신하며 2) 유저를 식별하는 로그인 / 회원가입 기능을 구현하였습니다.<br>[BE]: API 모듈을 통해 호출된 API에 맞춰 사용자를 생성(회원가입)하거나 로그인하고, 탈퇴(사용자 삭제)하는 usecase를 수행한다. UseCase에 맞추어 Domain 모듈을 통해 ORM을 수행하여 DB 관련 쿼리를 수행한다. 이 때 Spring Security를 통해 filterchain 관련 프로세스를 구현했다.<br><br>2. 리뷰<br>[FE]: 리뷰를 작성하고 삭제하는 기능을 구현하기 위해, "react"와 "axios" 라는 라이브러리를 도입하였고, 1) 사용자가 리뷰를 작성하고 2) 작성한 리뷰를 삭제할 수 있게 하며 3) 다른 사용자가 작성한 리뷰에 좋아요를 누르는 기능을 구현하였습니다.<br>[BE]: API 모듈을 통해 호출된 API에 맞춰 리뷰를 생성, 수정, 삭제, 조회하는 usecase를 수행한다. usecase에 맞추어 Domain 모듈을 통해 ORM을 수행하여 DB 관련 쿼리를 실행한다.<br><br>3. 상품 검색<br>[FE]: 웹에서 카메라로 찍은 이미지를 서버로 전송해 상품을 검색하는, 이미지 검색 기능을 구현하기 위해, "react-html5-camera-photo" 라이브러리를 도입하였고, 1) 웹에서 사용자 기기의 카메라에 접근 권한을 요청하고 2) 사용자가 사진을 찍은 후 3) 사용자가 찍은 사진의 url 을 저장하는 기능을 구현하였습니다.<br>[BE]: API 서버에 호출된 API에 맞추어 API 모듈의 usecase를 실행한다. 이 중에서 이미지 검색의 경우는 Model 서버의 API를 호출하는 usecase를 실행하여, API 모듈을 통해 OCR 과정을 수행할 수 있도록 한다. usecase에서 추론된 상품 검색 정보에 맞춰 Domain 모듈을 통해 상품 정보를 조회하고, API의 response 형태로 반환한다.<br>[ML]: 이미지 검색 기능을 제공하기 위해, Yolov5 및 OCR 모델을 finetuning하여 상품 태그로부터 문자를 인식하는 모듈을 구현하였다.<br><br>4. 즐겨찾기<br>[FE]: 사용자가 식료품을 즐겨찾기해둘 수 있는 기능을 구현하기 위해, "recoil" 이라는 전역 상태 관리 라이브러리를 도입하였고, 1) 다양한 경로에서 사용자가 즐겨찾기를 눌렀을 때 2) 즐겨찾기 상태가 동기화되는, 즐겨찾기 기능을 구현하였습니다.<br>[BE]: API 모듈을 통해 호출된 API에 맞춰 즐겨찾기를 생성, 삭제, 조회하는 usecase를 수행한다. usecase에 맞추어 Domain 모듈을 통해 ORM을 수행하여 DB 관련 쿼리를 실행한다. |
| (8-6) 과제: 세부 기술 | FE: cloudflare 로 배포한 next.js ver.14 의 SSG 환경 사용,  typescript 를 사용하여 정적 타이핑 검사 진행, 빌드 툴로는 yarn3 를 사용함으로써 빌드 속도를 가장 높였다.<br> BE: aws를 통해 배포한 jdk 17 기반 Spring Boot 3 기반 api 서버와 flask 기반 model 서버로 기능을 제공한다. 빌드 툴로는 gradle을 사용하고, KotlinDSL을 통해 gradle 파일을 작성하였다.<br> ML: python과 pytorch 기반 AI 모델링 진행, 자연어처리 모델 베이스라인으로는 KoBERT, OCR 모델 베이스라인으로는 EasyOCR을 사용했으며, 상품 태그 영역 인식을 위해 yolov5를 새로 학습했다. |
| (8-7) 과제: 기대 효과 및 의의 | 1. 변동사항 알림 기능<br>슈링크/스킴플레이션이 발생했을 때, 소비자가 이를 놓치지 않고 바로 발견함으로써, 자신이 알고 있던 상품 정보가 자신도 모르는 사이에 바뀌어 있는 일을 방지한다. 상품 변동에 대한 투명성 증가가 기업의 잦은 슈링크/스킴플레이션을 억제하는 효과가 있을 것으로 기대된다.<br> 2. 스킴/슈링크플레이션 정보 시각화 대시보드<br>소비자가 상품 변동 정보에 쉽게 접근할 수 있게 되어, 스팀/슈링크플레이션 발생 상품의 구매를 지속할지에 대한 판단을 주체적으로 할 수 있게 된다. 해당 기능을 통해 현명하고 합리적인 소비를 촉진할 것으로 예상된다.<br> 3. 대체품 추천 챗봇<br>슈링크/스킴 플레이션이 발생한 어떤 상품을 알리는 것에 그치지 않고, 이에 대한 대체제를 추천한다는 데에 의의가 있다. 소비자의 소비 선택의 폭을 확장하고 유연한 소비를 유도할 것으로 기대된다. |
| (9) 데모 내용 |  1. 홈 화면에서 알림 화면으로 이동해, 슈링크 / 스킴 플레이션이 발생한 식료품들의 알림을 확인했습니다.<br> 2. 홈 화면에서 검색 화면으로 이동해, 원재료 검색과 상품명 검색 기능을 확인했습니다.<br> 3. 홈 화면에서 카메라 화면으로 이동해, 상품의 태그를 찍고, 찍힌 상품의 정보를 불러왔습니다.<br> 4. 카메라 화면에서 태그를 찍은 상품의 상품 상세 화면으로 이동해, 용량 및 가격 그래프와 날짜별 원재료 리스트 변화를 확인했습니다.  |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-04
| (1) 과제명 | 김약사: 노년층을 위한 머신러닝과 광학 문자 인식을 통한 약 복용 관리 모바일 앱
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 04-심가탕후루 |
| (3) 팀원 역할 분담 | 이승민(2076308): 리더, 백엔드, 머신 러닝<br>신단아(2144015): 팀원, 프론트엔드, OCR<br>조윤아(2171047): 팀원, 백엔드, DB |
| (4) 팀 지도교수 | 심재형 교수님 |
| (5) 팀 멘토 | 서진원 / 한화시스템/ICT / ICT RM팀 과장 |
| (6) 과제 키워드(keywords) | 노인친화적, 약 복용, 건강 |
| (7) 과제 내용 요약 | 이름 모를 약의 정보가 궁금해지는 경우, 약의 사진을 찍어 바로 찾을 수 있는 서비스는 드뭅니다. 또한, 약 먹을 때를 까먹는 것은 약 복용에 있어 치명적인 불편함으로 작용합니다. 이와 같은 불편함은 많은 약을 장기 복용하는 노년층에게 더욱 치명적입니다.<br>김약사는 이러한 노년층이 겪는 문제점을 해결하기 위해 머신러닝을 이용한 분류로 알약을 이미지만으로 검색할 수 있게 하고, OCR 기능으로 약 봉투를 인식하여 편리하게 약 복용 알람을 등록할 수 있게 하는 모바일 앱입니다. |
| (8-1) 과제: 문제의 정의 | 1. 이름을 모르는 알약의 정보를 쉽게 찾을 수 있는 서비스가 필요하다. 현재 이름을 모르는 낱알의 알약의 사진을 찍어 찾을 수 있는 서비스는 드물다. 사진을 찍어 누군가에게 질문을 하거나, 생김새를 바탕으로 직접 필터링을 하여 고를 수 있는 서비스가 이를 대체하고 있다. 노년층의 경우, 단순히 궁금해서가 아니라 건강 상의 이유로 이러한 알약 검색 기능이 필요한 특수한 상황이 생긴다. 예를 들어, 항혈전제를 꾸준히 복용하던 환자가 내시경을 앞두고 있는 경우, 출혈을 예방하기 위해서 항혈전제를 잠시 중단해야 한다. 만약 평소 복용하는 약이 많아 어떤 것이 항혈전제인지 찾지 못하는 사람에게 사진만으로 알약을 찾을 수 있는 기능이 있다면, 편리하게 약을 골라낼 수 있게 될 것이다.<br>2. 약 복용 여부를 알려주고 체크할 수 있게 해주는 서비스가 필요하다. 약을 잊지 않고 꾸준히 복용하는 것은 중요한 요소이다. 약 복용을 잊어버리는 것은 약을 복용하는 모든 사람들에게 고질적인 문제이고, 이는 기억력이 저하되지만 복용해야하는 약은 많은 노년층에게 더욱 치명적인 문제점이 된다.<br>3. 노인을 위한 약 복용 도움 서비스가 필요하다. 우리나라의 노인 인구 중 약물 과다 복용 및 부적절한 복용을 하는 인구가 증가하고 있는 추세이다. (우리나라 노인들, ‘과다 및 부적절 약물’ 복용 많다, 팜뉴스, 2023.11.27) 이렇듯 노년층의 약 복용을 돕는 서비스의 필요성이 크지만, 현재 시장에 약 복용을 돕는 헬스 케어 앱 중에서 노년친화적인 서비스는 극히 드물다는 문제점이 있다. |
| (8-2) 과제: 기존연구와의 비교 | 1. (이름 모를 알약의 정보를 쉽게 찾을 수 있는 서비스가 필요하다.)<br>아하 <br>장점 : 약사를 직접 찾아가지 않아도, 약사에게 질문을 할 수 있다. 답변에 대한 신뢰도가 높다.<br>단점 : 직접 결과를 알 수 없고, 약사의 답변이 올 때까지 기다려야 한다. 노인친화적이지 못한 UI/UX<br><br>약학정보원 식별 정보 입력<br>장점 : 알약의 생김새를 바탕으로 검색을 할 수 있다.<br>단점 : 번거롭다.<br><br>2,3 (약 복용 여부를 알려주고 체크할 수 있게 해주는 서비스가 필요하다.)<br>파프리카 케어<br>장점 : 약 복용을 원활하게 해줄 수 있는 많은 기능이 갖춰져 있다.<br>단점 : 노인친화적이지 못한 UI/UX |
| (8-3) 과제: 제안 내용 | 1. (이름 모를 알약의 정보를 쉽게 찾을 수 있는 서비스가 필요하다.) : 알약의 사진을 찍어 알약의 이름 및 정보를 검색할 수 있는 기능 제공<br>2. (약 복용 여부를 알려주고 체크할 수 있게 해주는 서비스가 필요하다.) : 약 봉투의 사진을 찍어 복용하는 약물 목록을 추출하고, 복용 정보를 인식해 자동으로 알람을 등록해주는 기능 제공<br>3. (노인을 위한 약 복용 도움 서비스가 필요하다.) : 약 복용 시 주의 사항 제공 / 노인친화적인 UI/UX |
| (8-4) 과제: 과제의 주요 기능 | 1. 알약의 사진을 찍어 알약의 이름 및 정보를 검색할 수 있는 기능 제공 : MobileNetV2 분류 모델 이용<br>2. 약 봉투의 사진을 찍어 복용하는 약물 목록을 추출하고, 복용 정보를 인식해 자동으로 알람을 등록해주는 기능 제공 : NAVER CLOVA OCR 이용<br>3. 약 복용 시 주의 사항 제공 : DUR 정보 연동 |
| (8-5) 과제: 구현 방법 |1. 알약 사진 인식<br>MobileNetV2 모델을 사용한 알약 분류 모델을 통해 사진 촬영을 통해 무슨 약인지 식별 가능하도록 하며, 식별한 약을 복약 내역에 등록함.<br>2. DUR 정보 확인 <br>OpenAPI를 이용해 해당 약에 대한 DUR 정보를 확인할 수 있도록 함.<br>3. 약 봉투 사진 인식<br>네이버 클라우드 플랫폼의 CLOVA template OCR을 이용해 약 봉투 사진을 업로드하면 처방 약의 목록과 복용 정보 텍스트를 추출할 수 있도록 함. 추출된 정보를 이용하여 사용자의 복약 내역에 등록하고 알람을 설정하도록 함.|
| (8-6) 과제: 세부 기술 |1. 알약 인식 모델 훈련<br>의약품 안전 나라에서 제공하는 25000여종의 알약 이미지 데이터를 사용하여 모델을 훈련시킴. 모델 훈련에는 MobileNetV2를 사용하였으며 사진을 업로드하면 사용자에게 인식한 알약의 품목명을 반환할 수 있도록 함.<br>2. Open API 사용<br>식품의약품안전처에서 제공하는 DUR 품목 정보 Open API를 사용함. 사용자가 업로드한 사진을 인식하여 알약 품목명을 반환 받고 품목명으로 품목일련번호를 검색함. Open API 호출에 품목일련번호를 사용하여 병용금기, 노인주의, 용량주의, 투여기간 주의에 대한 정보를 가져옴.<br>3. Naver CLOVA OCR<br>네이버 클라우드 플랫폼의 CLOVA OCR을 사용함. 그 중 Template OCR을 사용하여 약 봉투 항목들을 직접 템플릿 설정하여 복용 약물의 리스트와 복용 횟수, 시간과 같은 복약 정보를 JSON 형태로 추출할 수 있도록 함. 상세 디자인은 약국마다 다르더라도 형식이 유사하기 때문에 형식별로 템플릿을 제작하였음.|
| (8-7) 과제: 기대 효과 및 의의 |1. 기존 서비스에서는 알약을 검색하려면 모양, 색상, 식별문자 등을 일일이 입력해야 하는데 정보가 너무 많아 이는 인터넷이 서툰 사용자에게는 다소 어려운 과정일 수 있음. 이러한 과정을 사진 촬영 한 번으로 대체하여 인터넷이 어려운 사용자들도 어떤 약인지 쉽게 확인할 수 있음. <br>2. 복용하는 약이 많은 사용자는 복약 내역을 관리하려면 해당 약들을 일일이 모두 등록해야 함. 약봉투 촬영 기능은 처방 받은 약들을 한 번에 등록할 수 있게 하여 쉽게 복약 관리를 할 수 있도록 함. <br>3. 사용자가 의사의 처방 없이 약국에서 직접 약을 구입하거나, 이전에 처방받고 집에 보관해놓은 약을 자율적으로 복용하게 되는 경우 병용 금기 사항이나 용량, 투여기간 주의와 같은 복용 주의사항을 쉽게 확인하기 어려움. 특히 서비스 타겟 사용자인 노인의 경우 작은 설명서로는 해당 정보를 확인하기 어려움. 서비스 내에서 DUR 정보 제공을 통해 약 등록만으로 복약 주의 사항을 확인할 수 있게 하여 약물의 오남용을 방지함.|
| (9) 데모 내용 |  ![image](https://github.com/sngminlee98/CapstoneDesign-24-1H/assets/113418905/a04f3f33-a842-4157-97f6-d92523fa9a88)<br>1. 알약 인식 결과 반환받기 <br>2. 인식된 약에 대한 병용금기 정보와 노인주의, 용량주의, 투여기간 주의 사항 반환받기<br>3. 약봉투 인식 결과 반환받기|
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-05
| (1) 과제명 | 모락모락: 개인 맞춤형 헤어스타일을 추천받고 다양한 조건을 비교하여 본인에게 맞는 헤어 디자이너를 찾을 수 있도록 매칭해주는 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 05-A.A |
| (3) 팀원 역할 분담 | 김지원(2176100): 리더, 백엔드 구현 및 서버 배포<br>오예린(2176218): 팀원, 프론트엔드 및 UI/UX 디자인<br>황서정(2076456): 팀원, AI 구현 및 서버 배포 |
| (4) 팀 지도교수 | 김명 |
| (5) 팀 멘토 | 김정민 / KT / R&D 전임 연구원 |
| (6) 과제 키워드(keywords) | 헤어스타일, 얼굴형, 헤어 디자이너 포트폴리오 |
| (7) 과제 내용 요약 | 일반 사용자들은 본인의 얼굴형에 따른 best 와 worst 헤어스타일을 추천받을 수 있고, 헤어디자이너와의 매칭까지 하나의 로직 안에서 경험해볼 수 있으며, 헤어디자이너들에게는 개인의 작업물을 모아 자신을 홍보 및 브랜딩 할 수 있는 기회를 제공합니다.  |
| (8-1) 과제: 문제의 정의 | 자신의 얼굴형에 어울리는 헤어스타일이 무엇인지 궁금한, 어떤 헤어스타일을 해야 할 지 고민인 20대 여성들이 많으며, 미용실 혹은 자신을 헤어 디자이너 자체로서 어떻게 홍보해야할지 어려움을 겪는 헤어 디자이너들이 많다는 문제가 존재한다.  현재는 주로 인스타그램/개인 블로그를 통한 홍보가 많이 이뤄지기 때문에  정보가 많이 분산 되어 있어 고객들이 찾기 힘들고 , 디자이너들은 홍보 효과 보지 못하고 있다.   |
| (8-2) 과제: 기존연구와의 비교 | __1. 헤어핏__ <br> - 가상 체험을 통해 다양한 헤어스타일을 체험 가능. <br>- 별도 기능으로 주변 디자이너들에게 시술 예약 가능.<br>- 하지만, 전체적으로 합성 과정이 어색하며 결과물이 자연스럽지 못함.<br>- 사용자에게 잘 어울리는 헤어스타일을 제공하지 않고 사용자가 직접 머리를 합성해봐야함 <br>- 합성을 했다고 그게 그 헤어스타일을 잘 하는 디자이너와 바로 연결되지 않음. 따라서 등록된 디자이너들이 많아도 디자이너들에 대한 홍보 효과는 부족함. <br>**2. 카카오헤어샵**<br>- 헤어 디자이너들의 포트폴리오를 확인하기에는 유용한 서비스. <br>- 스토리북 기능이 있어 마음에 드는 헤어스타일의 사진을 클릭 시 어떤 헤어 디자이너가 그 머리를 했는지 확인할 수 있음.<br>- 하지만 개인 헤어스타일 추천 시스템은 존재하지 않으며, 오직 디자이너들의 홍보에 초점을 맞춘 느낌임.<br> **3. 결론**<br>- 사용자 맞춤 헤어스타일을 추천해주는 서비스는 존재하지 않는다. <br>- 특히, 헤어디자인에 가장 핵심적인 요소인 얼굴형을 고려한 서비스는 더더욱 존재하지 않는다.<br>- 헤어스타일을 가상으로 체험해봐도 해당 헤어를 잘하는 디자이너를 추천받을 수 있는 앱은 없다. 즉, 사용자들은 가상 헤어 기능까지만 체험하고 맞춤 디자이너까지 찾아보지는 않으므로, 현존하는 앱들을 이용해 디자이너들은 고객 유치가 힘들다. |
| (8-3) 과제: 제안 내용 | 사용자들에게 헤어스타일을 추천해주기 위해서 얼굴형을 분석하여 어울리는 헤어 합성 사진을 볼 수 있는 기능과 어울리지 않는 합성 사진이 동시에 제공되는 방법을 제시하였다. 또한 헤어 추천 기능과 디자이너의 포트폴리오를 확인할 수 있는 기능이 하나의 서비스에 합쳐진 것이 우리 서비스의 장점이라고 할 수 있다.  |
| (8-4) 과제: 과제의 주요 기능 | 1) 사용자 얼굴형 판단 후 어울리는/어울리지 않는 헤어 합성 사진 제공 : 사용자의 얼굴 이미지를 통해 얼굴형(하트형, 긴형, 계란형, 사각형, 둥근형)을 분석한 후, 분석된 얼굴형에 어울리는 헤어스타일을 합성한 사진 3장과 어울리지 않는 헤어스타일을 합성한 사진 3장을 가시적으로 보여주는 기능이다.<br> 2) 사용자에게 추천된 헤어스타일 관련 디자이너 목록 제공 : 위의 기능에서 추천된 헤어스타일을 기반으로 그 헤어스타일을 전문 헤어로 등록한 디자이너들을 리스트 형태로 제공하는 기능이다. <br> 3) 디자이너 포트폴리오 생성 : 디자이너가 자신의 정보, 근무지, 자격인증서, 전문헤어, 헤어 이미지, 가격 등을 넣어 자신만의 포트폴리오를 생성하는 기능이다. <br> 4) 디자이너 리스트 조회 및 검색 : 자신에게 맞는 디자이너들을 리스트 형태로 모아보고 검색할 수 있는 기능이다.<br> 5) 디자이너 세부 정보 확인 : 디자이너 리스트에서 원하는 디자이너를 눌러 디자이너가 생성한 포트폴리오 내용을 상세하게 확인할 수 있는 기능이다.<br> 6) 디자이너 포트폴리오 찜하기 : 마음에 드는 디자이너 포트폴리오를 찜할 수 있는 기능이다.<br>  |
| (8-5) 과제: 구현 방법 | <b>전체 서비스 아키텍처</b><br>  ![구현방법](https://github.com/JiwonKim08/CapstoneDesign-24-1H/assets/99666136/30cd31f3-9415-4c33-bd60-6d8685128d2e) **1. 공통**<br> 1) 사용자가 morakmorak.vercel.app에 접속하면, 프론트에서 제공하는 UI화면을 보여줍니다. <br> 2) 카카오 로그인을 한 후, 일반 사용자와 헤어 디자이너 중 역할을 선택함으로써 이 후 기능이 달라집니다.  <br> <br> **2. 사용자 입장** <br> 1) 일반 사용자의 경우, 본인의 정면 얼굴 이미지를 업로드 후 얼굴형에 맞는 헤어스타일링을 추천받을 수 있습니다. 이때, 얼굴형 판단 및 추천/비추천 헤어스타일과의 합성 시스템은 tencent cloud 에서 제공하는 compute engine의 gpu를 포함한 인스턴스를 통해 배포한 파이썬 기반의 코드와 EfficientNet B4, FaceSwap 모델을 통해 진행됩니다. Efficient B4를 통해 얼굴형이 분석되며, MobileFaceSwap을 통해 합성 사진이 생성됩니다. 이는 torchvision을 통해 모델 불러오기와 이미지 전처리를 하면서 진행됩니다.<br> 2) EfficientNet B4에서 얼굴형 분석 후, 사용자와 유사도가 가장 높은 얼굴형과 낮은 얼굴형은 프론트엔드로 보냄으로써 사용자의 데이터를 쌓아두고, 어울리는/어울리지 않는 헤어와 본인의 얼굴이 합성된 총 6장의 이미지들 Boto3라는 Python용 AWS SDK를 사용하여 AWS S3로 저장됩니다.<br> 3) 이 후, 프론트엔드에서는 AWS S3에 저장된 6장의 이미지를 AWS-SDK/Client-S3을 사용해 객체 접근용 presigned Url을 받아옵니다. 받아온 이미지들과 AI 서버로부터 받아온 얼굴형 텍스트 결과를 이용해 사용자에게 분석 및 합성 결과를 화면에 제공합니다.<br> 4) 그 후, 프론트엔드는 어울리는 헤어스타일과 해당 헤어스타일을 전문으로 하는 디자이너를 텍스트 매칭하여 디자이너 포트폴리오를 추천하는 API를 호출합니다. <br> 5) 이 때, QueryDSL와 JPA 라이브러리를 사용해 작성해둔 쿼리문을 거쳐 해당 데이터를 프론트로 넘겨줍니다. <br> 6) 프론트엔드에서의 화면을 통해 추천된 디자이너들이 리스트 형태로 보여집니다. <br><br> **3. 디자이너 입장** <br> 1) 헤어 디자이너의 경우, 포트폴리오 생성 화면에서 포트폴리오를 작성함으로써 본인의 작업을 홍보할 수 있습니다.<br> 2) 포트폴리오 생성에 필요한 정보를 텍스트와 이미지로 입력하고, 각각 RDS와 S3에 저장합니다.<br> 3) 작성, 수정, 삭제 기능 등의 api는 백엔드에서 AWS Route53을 거쳐 만든 도메인으로 post, get, delete를 호출하면 됩니다.<br> 4) 이때 AWS Loadbalancer를 거치며 HTTPS로 변경하기 위해 AWS Certificate Manager를 붙임으로써 TLS 보안을 적용하고 라우팅을 분산적으로 가능하게 합니다.<br>5) Nginx를 거쳐 웹서버를 띄우고 이를 도커에 패키징해서 배포(push/pull)함으로써, 다른 OS 환경에서도 같은 환경으로 돌아갈 수 있게 설정합니다.<br>  |
| (8-6) 과제: 세부 기술 | **1. 사용자 얼굴형 판단 및 이미지 합성**<br>얼굴형을 계란형, 둥근형, 긴형, 하트형, 사각형으로 라벨링하고 각각 FACESHAPE_OVAL, FACESHAPE_ROUND, FACESHAPE_OBLONG, FACESHAPE_HEART, FACESHAPE_SQUARE 로 지정합니다.이후 5가지 얼굴형에 어울리는 헤어스타일을 각 3가지씩 지정합니다. 얼굴형에 적절한 헤어스타일은 「얼굴형에 따른 헤어스타일 연구」, 「얼굴형의 특성을 보완한 헤어스타일 연구」, 「얼굴형에 따른 헤어스타일 연출 제안」, 「얼굴 유형에 따른 헤어 커트 스타일 선호도 연구」 와 같은 논문을 기반으로 선정하였습니다. 이 각각의 헤어스타일에 맞는 사진을 데이터베이스에 각각 저장하도록 합니다. <br> 얼굴형 이미지 데이터셋으로 파인튜닝한 EfficientNet-B4 모델을 불러옵니다. 사용자의 이미지를 업로드할 수 있는 함수를 작성하여 사용자로부터 이미지를 입력으로 받아오도록 구현합니다. 입력으로 받은 사용자가 업로드한 이미지를 전처리한 후,  모델을 사용하여 사용자의 얼굴형을 예측한 결과를 반환하고, 가장 확률이 낮게 예측된 얼굴형 결과 또한 반환하도록 합니다. 함수를 이용하여 이 결과를 백엔드 서버측으로 json 형태로 전송합니다. <br> 이때 전송된 결과는 데이터베이스에 텍스트 형태로 저장됩니다. AI 서버에서는 그 결과를 이용하여 데이터베이스에 저장되어있는 헤어스타일 이미지를 불러온 후 MobileFaceSwap를 통해 앞서 전처리된 사용자 얼굴 이미지와, 불러온 헤어스타일 이미지를 합성합니다. 이때 가장 확률이 높게 예측된 얼굴형으로 분류된 헤어스타일 이미지와 합성을 해서 결과를 만들어내고, 가장 확률이 낮게 예측된 얼굴형으로 분류되어있는 헤어스타일 이미지와도 합성을 해서 결과를 만들어, 총 6장의 이미지를 생성합니다. 이후, python에서 이미지들을 AWS S3 버킷에 저장합니다. AWS S3에 저장된 이미지들은 프론트엔드에서 AWS-SDK/Client-S3 라이브러리를 통해 직접 가져와 사용자에게 제공합니다. <br>  <Br> **2. 얼굴 합성** <br>  기능 구현을 위해 프론트엔드에서 사용자의 얼굴과 가장 일치하는 얼굴형 텍스트 결과를 URL의 쿼리로 AI 서버로부터 넘겨받습니다. 이후, 프론트엔드 측에서 해당 사용자 얼굴형에 어울리는 헤어스타일 이름 3가지를 다중값으로 백엔드 서버로 넘깁니다. 백엔드 서버는 넘겨받은 정보를 콤마(,)를 기준으로 파싱한 후, Hairstyle 테이블에서 hair_name부분을 탐색합니다. hair_name에 해당하는 hair_style_id 리스트를 받아, Portfolio_Hairstyles 테이블에서 해당 hair_style_id를 가진 portfolio_id 리스트를 받아옵니다. <br> 앞 로직을 구현하는 쿼리문을 실행시키는 함수를 queryDSL 라이브러리를 사용하여 직접  구현함으로써 portfolio_id를 가진 portfolio 객체를 가져와 디자이너 포트폴리오 리스트로 사용자에게 제공합니다.  이 과정에서, queryDSL을 사용하여 JPA 엔티티에 대한 쿼리를 쉽게 작성하기 위해 JPA 라이브러리를 사용합니다. 이로써 사용자는 자신에게 어울리는 헤어스타일링을 잘하는 디자이너를 추천 받아볼 수 있습니다. 사용자가 디자이너 포트폴리오 리스트에서 특정 포트폴리오를 클릭하면 “포트폴리오 상세 정보 조회 API”와 함께 해당 포트폴리오 ID가 백엔드 서버로 GET 메소드가 요청되어 포트폴리오 세부내용을 조회할 수 있습니다.        |
| (8-7) 과제: 기대 효과 및 의의 | 이 프로젝트를 통해 사용자들은 자신의 얼굴형에 대한 이해와 헤어스타일 선택에 도움을 받을 수 있으며, 헤어 디자이너들과의 연결까지 제공받을 수 있다. 자신의 얼굴형 판단 결과에 대한 호기심을 갖고, 동시에 자신의 얼굴형에 맞는 헤어스타일을 예측하며 추천받고 싶어하는 20대 여성들이 얼굴형 예측 결과를 제공받을 수 있다. 뿐만 아니라 그에 따른 헤어스타일과 사용자 얼굴 합성 사진을 다양하게 제공받을 수 있다. 동시에 자신에게 추천되는 헤어스타일을 주력으로 하는 디자이너를 추천받고 디자이너의 포트폴리오와 관련된 정보를 제공받을 수 있다.디자이너들은 자신의 헤어스타일 작품을 모아 포트폴리오로 생성할 수 있으며 이를 서비스의 다양한 사용자들에게 노출시킴으로써 자신을 홍보할 수 있고 나아가 고객을 확보하는 지름길이 될 수 있다. |
| (9) 데모 내용 |1) 디자이너 플로우<br> - 로그인 및 회원가입<br> - 디자이너 모드 선택<br> - 포트폴리오 생성<br> - 자신의 포트폴리오 조회 <br><br> 2) 일반 유저 플로우<br> - 로그인 및 회원가입<br> - 일반 유저 모드 선택<br> - 얼굴형 분석 및 헤어스타일 추천받기 <br> - 디자이너 추천받기 <br> - 디자이너 검색 <br> - 디자이너 포트폴리오 확인 및 찜하기  |
| (10) 기타 | **실제 서비스 화면** <br> ![image](https://github.com/YelynnOh/CapstoneDesign-24-1H/assets/110076475/5850846d-428c-44be-b6cf-353efd8686a7)
 
[Return TOP](#list-of-teamsprojects)

# Team-06
| (1) 과제명 | Inkspire: Gen AI가 생성한 스토리 기반 오픈월드 텍스트 RPG
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 06-너도 멸종되지 않게 조심해 |
| (3) 팀원 역할 분담 | 오수현(1928019): 팀원, 백엔드 서버 구축 (SpringBoot, AWS 서버 배포), GPT api 호출 프롬프트 엔지니어링<br>이소민(2071035): 팀원, 클라이언트 Unity 개발, 전투 / 플레이 시스템 기획 및 개발, GPT api 호출 프롬프트 엔지니어링<br>이가빈(2176240): 리더, 클라이언트 Unity 개발, 맵 생성 및 이벤트 시스템 기획 및 개발, GPT api 호출 프롬프트 엔지니어링 |
| (4) 팀 지도교수 | 박상수 교수님 |
| (5) 팀 멘토 | 유원준 / 네이버 클라우드 / 연구원 |
| (6) 과제 키워드(keywords) | 텍스트 RPG, ChatGPT, 실시간 상호작용, 오픈월드 |
| (7) 과제 내용 요약 | Inkspire는 사용자에게 풍부한 맞춤형 게임 경험을 제공하는 게임 애플리케이션이다. 사용자가 선택한 게임 배경과 장르, 게임을 진행하며 주어지는 여러 선택지에 따라 각자 다른 형태와 내용의 스토리가 생성되어 사용자는 다양하고 흥미로운 게임 세계를 탐험할 수 있다. 뿐만 아니라 시나리오 작성, 미션 및 퀘스트 설계, 대화 시스템 구축 등과 같은 작업의 자동화로 게임 하나 당 한 편의 시나리오가 적용되던 기존의 게임 서비스에서 벗어나 단 하나의 어플리케이션으로 다양한 스토리를 탐험할 수 있다. |
| (8-1) 과제: 문제의 정의 | 최근 몇 년 동안 인공지능(AI) 기술의 혁신적인 발전은 다양한 산업 분야에 변화를 가져오고 있다. 이러한 변화들은 맞춤형 콘텐츠의 제공이라는 공통점을 지니고 있다. 즉, 인공지능은 빅데이터, 기계학습 및 자연어 처리 기술을 통합하여 사용자별로 맞춤형 경험을 제공하는데 이상적인 툴이 되었다. 이러한 기술 발전과 더불어 소비 경향도 변화하고 있다. Insight M과 CJ AI center에서 조사한 2023년 소비 트렌드 시리즈에 따르면 오늘날의 소비자는 다음과 같은 요구사항을 가지고 있다. 응답자의 72%가 기업이 소비자를 개인으로 인식하고 개인의 관심사를 알기를 기대하고, 71%의 소비자는 개인화된 커뮤니케이션과 제품을 제공받기를 원하며 76%의 소비자가 개인화된 브랜드에서 구매를 고려할 가능성이 더 높다고 답했다.<br>이러한 맥락 속에서 게임 산업도 AI의 발전에 영감을 받아 혁신적인 변화를 겪고 있다. 플레이어들은 개별화된 게임 경험을 원하며, 자신의 선택과 선호도에 따라 게임 세계를 탐험하고 싶어한다. 이와 같이 사용자의 취향에 맞는 "맞춤형 콘텐츠"에 대한 소비자들의 수요가 증가함에 따라 창작자의 취향에 맞추어 창작된 기존의 시나리오는 그들의 기대를 충족시키기 어렵다는 한계점을 가지고 있다. 하지만, 기존 게임 시장에서는 맞춤형 컨텐츠 서비스를 제공하는 사례가 적으며 게임 개발자들이 이러한 사용자 맞춤형 콘텐츠를 만들기 위해서는 많은 노력과 시간을 투자해야 한다. 시나리오 작성, 다양한 미션 및 퀘스트 설계, 대화 시스템 구축 등 직접 맞춤형 콘텐츠를 제작하는 데에는 복잡한 작업들이 따른다. 실제로 시청자들의 선택에 따라 이야기가 달라지는 넷플릭스의 ‘블랙미러: 밴더스내치’ 제작자는 “인터랙티브는 노동집약적인 작업” 이라고 평가하는 등 맞춤형 컨텐츠 제작 과정 중 스크립트 작업에 많은 시간을 투자해야함을 강조하기도 했다. 또, 기존의 생성형 AI의 답변에는 매끄럽지 않은 부분이 많고, 특히 일관적인 내용이나 말투를 생성하는데 어려움이 있다. 따라서 이러한 문제들을 해결하고 사용자의 몰입감과 만족도를 높일 수 있는 AI 게임 스크립트 생성 어플리케이션을 개발할 계획이다. |
| (8-2) 과제: 기존연구와의 비교 | <b>AI 던전</b><br>OpenAI의 AI 던전은 자연어 처리 및 기계학습 기술을 활용하여 맞춤형 텍스트 기반 어드벤처 게임을 생성하는 플랫폼이다. 플레이어는 자신의 선택에 따라 게임의 진행을 조작하며, AI는 플레이어의 입력에 따라 실시간으로 스토리와 상호작용을 생성한다. 이를 통해 각 플레이어에게 맞춤형 경험을 제공하고 있다.<br>그러나, AI 던전은 영어 기반의 텍스트로 훈련시킨 모델을 사용했기 때문에 한국어와 같은 다른 언어로의 번역이나 맥락 파악에 있어서 아직 완벽하지 않은 경우가 있다. 때로는 한국어로 게임을 플레이 했을 때 입력된 텍스트의 맥락을 정확하게 이해하지 못하거나, 부적절한 답변을 생성하기도 한다. 더 심각한 문제로는 AI에 과부하가 걸려 게임이 진행되지 않는 상황도 발생할 수 있다. 영어로 플레이를 하더라도 플레이어가 각종 설정을 세부적으로 설정하지 않으면 스토리가 제대로 진행되지 않는다는 단점이 있다. 또한, 게임의 목표나 보상이 불분명하여 게임이 아닌 AI와 함께 소설을 쓰는 과정과 유사하게 느껴질 수 있다.<br><br><b>메이비(Maybe)</b><br>시나몬 게임즈의 메이비는 네이버 인기 웹툰 및 웹소설을 기반으로 플레이어가 특정 작품을 선택하면 각 상황에 따른 질문이 주어지고, 플레이어의 선택(답변)에 따라 메인 스토리가 전개되는 게임이다. 게임 내에는 다양한 직업과 능력이 있어 플레이어들은 자신만의 캐릭터를 발전시키고 특수 기술을 습득할 수 있으며, 플레이어의 다양한 선택에 따라 본인만의 엔딩을 만들어 갈 수 있기 때문에 기존 네이버웹툰 독자뿐만 아니라 새로운 유저들도 함께 즐길 수 있다.<br>하지만, 이는 네이버 웹툰 혹은 웹소설과 같이 정해진 스토리와 캐릭터를 기반으로 진행되는 게임이기 때문에 플레이어의 게임 내 자유도가 높다고 볼 수 없으며, 사용자의 취향에 맞는 새로운 서사구조를 맞춤형으로 제공한다고 보기는 어렵다.<br><br><b>고스트라이터 (Ghostwriter)</b><br>유비소프트의 고스트라이터는 AI 대사를 재구성하는 LLM으로 게임용 NPC의 기본 대사 초안을 생성하는 AI 도구로 많은 수의 NPC를 구현해야 하는 게임에서 사용되고 있다. NPC가 많은 게임의 경우, NPC 구현에만 10만 줄이 넘는 대화 스크립트를 작성해야 해서 스크립트 작업에 많은 시간이 소요되는데, 이러한 대화 작성 작업을 고스트라이터를 통해 자동화하여 업무 시간을 줄이고 더욱 효율적으로 게임을 개발할 수 있다. 또한, 고스트라이터는 복수 대사를 출력하기 때문에 각본가는 이 중 원하는 옵션을 선택할 수 있고 출력한 대사를 자유롭게 편집할 수 있다.<br>그러나, 고스트라이터는 개발 단계에서 사용하는 툴로, 시나리오 작성 시 제작자를 보조하는 수준으로 사용되고 있으며 플레이어와 NPC의 실시간 상호작용 및 대화를 지원하지는 않는다.  또한, NPC 대사 생성 기능에만 초점을 맞추고 있어 전체적인 게임 시나리오를 개인화하여 제공한다고 보기는 어렵다. |
| (8-3) 과제: 제안 내용 | <b>맞춤형 게임 경험 제공</b><br>Inkspire는 사용자의 선택과 선호를 기반으로 AI가 게임 시나리오 및 목표를 자동으로 생성하는 시스템을 구축하여 개인 맞춤형 게임 경험을 제공한다. 자연어처리를 기반으로 한 알고리즘을 사용하여 플레이어의 행동과 선호를 분석하고, 이에 따라 게임의 스토리, 미션, 아이템, 적, 난이도 등을 적절하게 조절하여 즐겁고 흥미로운 게임 경험을 선사한다. 평소 게임을 즐겨하는 유저들을 대상으로 베타 테스트를 진행하여 맞춤형 게임 경험에 대하여 70% 이상의 만족도를 이끌어내는 것을 목표로한다.<br><br><b>자동화된 시나리오 생성 및 콘텐츠 제작</b><br>자연어 처리 기술을 활용한 대화 시스템을 개발하여 플레이어의 질문 및 행동에 따라 실시간으로 적절한 대화를 생성하고 스토리를 진행시키며 상호작용할 수 있는 게임 내 시나리오 진행 시스템을 구축한다. 이를 통해 사용자는 보다 적극적으로 게임 스토리에 개입할 수 있다. |
| (8-4) 과제: 과제의 주요 기능 | <b>1. 사용자 식별 및 보상 시스템</b><br> - 사용자는 로그인/회원가입을 할 수 있다.<br> - 사용자는 자신의 탐험 목록(캐릭터 이름 및 장르)을 확인할 수 있다.<br> - 사용자는 과거에 플레이했던 내용을 확인할 수 있다.<br> - 사용자는 엔딩을 본 스크립트의 업적을 획득할 수 있다.<br> - 사용자는 최종 엔딩에 성공한 스크립트 개수에 비례하여 칭호를 획득할 수 있다.<br><br><b>2. 게임 초기 설정</b><br> - 사용자는 캐릭터 이름, 장르, 시/공간적 배경을 입력하여 자신이 원하는 테마의 게임을 생성할 수 있다.<br> - 입력받은 장르와 시/공간적 배경을 바탕으로 게임의 세계관, npc 시스템, 장소 시스템, 목표 시스템을 생성할 수 있다.<br> - 사용자는 플레이 할 캐릭터의 초기 스탯 값을 설정할 수 있다.<br><br><b>3. 게임 진행</b><br> - 사용자는 지도 기능을 이용하여 스토리를 진행할 특정 장소를 선택할 수 있다.<br> - 사용자는 행동 지문을 입력하여 게임을 진행할 수 있다.<br> - 사용자가 전투 이벤트가 발생하는 장소에 진입할 경우 캐릭터의 스탯을 이용하여 전투에 참여할 수 있다.<br> - 사용자가 전투에서 승리할 경우 보상 아이템을 획득할 수 있다.<br> - 사용자가 챕터 목표와 관련 있는 장소에 진입할 경우 장소를 탐색하며 정보 혹은 아이템을 획득할 수 있다.<br> - 사용자가 챕터 목표 달성에 성공하면 다음 챕터 장소에 진입할 수 있게 되며, 실패할 경우 최종 챕터 해금이 불가능하다.<br> - 사용자가 게임 진행에 어려움을 겪을 경우 조력자 NPC를 통해 힌트를 획득하거나 다음 챕터 진행을 선택할 수 있다. |
| (8-5) 과제: 구현 방법 | <b>Inkspire 데이터 플로우</b><br>![Inkspire_dataflow](https://github.com/SuHyeon00/CapstoneDesign-24-1H/assets/90602694/142c19d7-4232-44b8-ac33-d6bd3c09877c)<br><br><b>Inkspire 컴포넌트 구조도</b><br>![Inkspire_component](https://github.com/SuHyeon00/CapstoneDesign-24-1H/assets/90602694/d26dcd7b-9bf0-42e7-b245-cc806d5994a3)<br><br><b>게임 초기 설정</b><br>- 기본 스크립트 골격 생성<br>플레이어로부터 입력받은 게임의 장르, 공간/시간적 배경을 토대로 GPT 모델을 활용하여 게임의 전체적인 배경이 될 세계관을 생성한다. 생성된 세계관을 토대로 게임 내 등장할 npc와 최종 목표 및 챕터별 목표를 생성한다.<br>- NPC 생성<br>NPC는 게임의 기본 세계관에 따라 이에 어울리는 조력자 NPC와 적대자 NPC가 생성된다. 이렇게 생성된 NPC는 사용자가 게임을 플레이하는 과정에서 등장하며 스토리에 개입한다. NPC는 게임이 진행되는 동안 일관된 말투를 사용하며 사용자와의 이전 대화 내용을 저장하여 기억하는 형태로 구현하였다.<br>- map 생성<br>게임의 세계관을 바탕으로 플레이어가 탐색할 수 있는 장소를 생성한다. 장소는 최종 챕터에서 한 곳, 일반 챕터 당 세 곳 씩 총 열 세 곳이 생성되며 세 장소 중 하나에는 챕터 목표 달성을 위한 퀘스트가 주어진다. 목표 달성과 관련 없는 장소에서는 랜덤한 확률로 일반 몬스터와의 전투, 아이템 획득, 적대자 NPC 등장 등의 일반 이벤트가 발생하며 플레이어는 자유롭게 장소를 탐색하며 게임을 진행할 수 있다.<br>- 플레이어 스탯<br>플레이어는 공격, 방어, 민첩, 정신, 행운의 5가지 스탯을 1-100 범위 내의 숫자로 설정할 수 있다. 단, 스탯 합 제한범위 내에서 스탯을 배분한다. 그 이상의 스탯은 추후 스크립트 플레이 중 몬스터와 전투를 통해 얻는 보상으로 상승시킬 수 있다. 스탯은 실제 플레이어의 스탯을 저장하는 PlayerStatManager.cs 코드와 스탯 시스템의 구조와 함수를 정의해둔 Stats.cs 코드를 분리해 안전성을 높였다. 플레이어 스탯의 변동은 자주 일어나지 않고 변동의 중요도가 높으므로, 변동 시마다 서버와 통신하여 DB에 저장되어있는 내용을 갱신한다.<br><br><b>게임 플레이</b><br>- 대화 시스템<br>게임은 장소 중심 대화형식으로 진행된다. 각 챕터마다 새로운 장소가 열리며, 플레이어는 이 장소들을 조사하며 게임 스토리의 실마리를 얻는다. 플레이어가 행동이나 대사 지문을 입력하고 전송하면, 프로그램은 이를 GPT에 입력하고 GPT를 호출해 다음 진행될 대화를 생성하게 한다. 각 장소에는 판정을 하여 아이템을 얻거나 NPC와 조우하는 등의 이벤트가 숨어 있는데, 이 이벤트 발동 조건을 충족하는 행동을 하는 지문을 입력할 시 주사위 이벤트가 진행된다. 발동 조건은 매 턴 사용자의 입력과 GPT의 답으로 구성된 스크립트를 프롬프트 엔지니어링을 통해 구성된 이벤트 트리거 체커에 의해 충족되었는지 판단한다.<br>- 주사위 시스템<br>이벤트 트리거 체킹 시스템에 의해 이벤트가 발생하면 GPT는 현재 진행중인 스크립트와 개연성 있는 진행으로 이벤트의 발생 상황을 출력하며 이벤트 발생을 알린다. 이후 일정 기준치가 주어짐에 따라 사용자는 주사위를 굴려 기준치보다 높은 값을 얻어야만 이벤트 판정에 성공하게 된다. 이런 주사위 판정 시스템은 고전 스토리 게임 장르인 TRPG에서 차용한 것이며 게임에 랜덤성을 부여하여 예측할 수 없는 운의 요소를 개입시킨다. 주사위 판정이 끝나면 GPT는 각각 성공/실패 여부에 맞는 스토리 스크립트를 생성하며 게임을 이어간다.<br>- 전투 시스템<br>플레이어가 전투 이벤트가 존재하는 장소에 들어가게 되면 전투 이벤트가 발생한다. 몬스터의 스탯 수치는 일정 범위 내에서 무작위로 생성되며, 플레이어와 몬스터는 턴제 전투를 시행하게 된다. 전투에 참여한 구성원은 각자 공격 턴, 방어 턴을 번갈아 갖게 되는데 이때 턴의 종류에 따라 수행할 수 있는 행동이 달라진다. 시스템적으로 일관되지 않은 게임은 플레이어로 하여금 재미가 아닌 혼란을 느끼게 할 수 있으므로 전투 시스템에서는 일관된 규칙을 적용하고 GPT의 개입을 배제하여 게임성을 높이고 사용자가 느낄 수 있는 복잡도를 줄였다. |
| (8-6) 과제: 세부 기술 | <b>SW 아키텍처</b><br>![Inkspire_시스템구조도](https://github.com/SuHyeon00/CapstoneDesign-24-1H/assets/90602694/b50cd8ac-2f58-4f9e-a4f5-2f171ec92c3d)<br><br><b>GPT 호출 컴포넌트</b><br>Inkspire의 컴포넌트 중 GPT 프롬프팅이 사용 된 경우는 총 8가지로, 다음과 같다.<br>- Script.cs: 세계관 생성, 텍스트 rpg 인트로 생성<br>- Play.cs: 텍스트 rpg 게임 진행<br>- Event.cs: 이벤트 트리거 생성, 판정 이벤트 정보 생성<br>- EventChecker.cs: 이벤트 트리거에 의한 트리거 발동 체크<br>- Goals.cs: 최종목표 생성, 챕터목표 생성<br>-Items.cs: 아이템 이름 생성<br>- Npc.cs: NPC 이름 생성, NPC 정보 생성<br>- Place.cs: 조력자 NPC 상주 장소 생성, 일반 장소 정보 생성<br><br><b>출력 양식 통일</b><br>게임의 목표 정보나 이벤트 정보, NPC의 특징 및 성격 서술의 경우 공통된 정보를 기반으로 일관성있는 내용을 출력하여야 한다. 따라서 각 정보의 생성을 GPT 호출 한 번에 출력하도록 엔지니어링하였다. 하지만 이 정보들은 string 처리를 하여 구분자에 따라 배열에 저장되어야 하기 때문에 출력 양식의 통일이 필요하다. GPT가 통일되지 않은 형태로 출력하는 것을 방지하기 위하여 시스템 프롬프트 내에 다수의 출력 예시를 추가하여 GPT가 통일된 양식을 출력하도록 조정하였다.<br><br><b>게임 진행자 역할 부여</b><br>텍스트 rpg 인트로 생성, 게임 진행, 진행 중 npc 대화체 생성 등에 사용된 GPT의 역할 프롬프팅은 게임 스토리의 배경, 세계관 정보와 주요 NPC 정보를 전달한 후, TRPG Narrator라는 역할을 GPT에게 부여하여 실시간으로 사용자와 상호작용하며 TRPG 게임을 진행시킨다.<br><br><b>텍스트 기반 유사 내용 판별</b><br>플레이어가 입력한 행동 지문이 미리 생성한 퀘스트의 도입 스토리와 유사한지 판단하는 이벤트 체커를 구현하였다. 각 아이템이 위치한 장소 정보와 퀘스트 제목, 퀘스트 도입 스토리를 전달하였을 때 입력된 플레이어의 행동 지문에 따라 그 결과값이 True인지 False인지 판단하는 다수의 예시를 입력하여 판단의 정확도를 향상시켰다.<br><br><b>영어 출력 방지</b><br>openAI의 GPT 서비스는 영어를 기반으로 하고있기에 NPC 이름, 지명 등의 고유명사를 한 단어로 출력할 경우 종종 영어 표기를 한글 표기 옆에 병기하는 문제가 있다. 게임 진행 상 영어 병기는 흐름을 해쳐 몰입도를 저하시킬 위험이 있으므로 제거해야 할 요소 중 하나이다. 따라서 프롬프트 엔지니어링 시 "또한, 출력의 영어표기를 생략하고 한글표기만 나타낸다. 출력은 반드시 한글로만 이루어진다." 등 다른 어휘를 사용한 문장으로 반복적으로 한글만 출력해야 함을 인식시켜주었다.<br><br><b>프롬프팅 코드 예시</b><img width="1252" alt="event_prompting" src="https://github.com/SuHyeon00/CapstoneDesign-24-1H/assets/90602694/cffbd604-c0f2-450b-b36c-b2f683dee2b7"><br><img width="785" alt="goal_prompting" src="https://github.com/SuHyeon00/CapstoneDesign-24-1H/assets/90602694/215bfa4c-d46a-4f94-b3a1-2c03ac8462ff"><br><br><b>Unity와 웹 통신</b><br>게임 데이터 저장 및 사용자 구분을 위한 웹 통신 환경을 구축하였다. 유니티 엔진의 Networking 패키지를 이용하여 aws 클라우드 서버에 배포된 웹서버와 통신하며 저장된 게임 데이터를 통해 이전 플레이 정보를 확인할 수 있다. |
| (8-7) 과제: 기대 효과 및 의의 | 게임 플레이어 측면에서의 기대 효과로는 플레이어의 경험 개선 등을 기대할 수 있다. 증가하는 맞춤형 콘텐츠에 대한 수요에 맞춰 플레이어들에게 게임 세계와 캐릭터에 대한 맞춤형 시나리오를 제공하여 게임 경험의 다양성을 향상시킬 것으로 기대된다. 플레이어들은 이 자동화된 시나리오를 통해 전보다 더욱 다양한 컨텐츠 및 높은 자유도 속에서 게임 세계에 더욱 깊이 참여하고 상호작용할 수 있으며, 게임의 흥미와 재미를 높일 것으로 예상된다.<br>더 나아가 자연어 처리 기술을 게임 개발 분야에 적용하여 게임 개발과 엔터테인먼트 산업에 새로운 가능성을 제시하고 미래 게임 개발에 영감을 줄 수 있을 것이다. Inkspire는 기존 하나의 게임을 관통하는 세계관, 시나리오를 기반으로 제작되던 게임 서비스에서 벗어나 하나의 게임으로 다양한 세계를 탐험할 수 있는 게임 서비스로 나아갈 수 있는 시발점이 될 것이다. 이러한 기술 혁신은 게임 산업의 성장과 향상에 기여할 것으로 예상된다. |
| (9) 데모 내용 | 1. 사용자 계정 생성 및 로그인<br>2. 플레이어 캐릭터의 스탯(능력치) 설정<br>3. 사용자 입력 기반 게임 기본 정보(세계관, 인트로, 목표, 이벤트, npc, 장소) 생성<br>4. NPC와의 대화 상호작용<br>5.주사위 이벤트 진행 - 성공 / 실패 시나리오<br>6.전투 이벤트 진행<br>7. 최종 목표 클리어 후 에필로그 진행<br><br>데모는 안드로이드 모바일 앱에서 동작한다. |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-07
| (1) 과제명 | Once : 카드 다보유자를 위한 결제 전 최대 할인 카드를 추천해 주는 AI 챗봇 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 07-루스 |
| (3) 팀원 역할 분담 | 유지민(2171031) : 팀원, Flutter 프론트엔드, Spring Boot 백엔드, 크롤링, Figma 디자인, 위치 기반 푸시 알림 구현<br>이해원(2171040) : 리더, Flutter 프론트엔드, Spring Boot 백엔드, 크롤링, Figma 디자인, 인공지능 모델 개발<br>허채린(2171052) : 팀원, Spring Boot, AWS 백엔드, 크롤링, 인공지능 모델 개발, 위치 기반 푸시 알림 구현 |
| (4) 팀 지도교수 | 오세은 교수님 |
| (5) 팀 멘토 | 김동수 / 엘핀 / CTO |
| (6) 과제 키워드(keywords) | 카드, 최대 할인, 챗봇 |
| (7) 과제 내용 요약 | ‘원스’는 사용자가 보유한 여러 장의 카드 중, 결제처에서 최대 할인을 받을 수 있는 카드를 추천해 주는 핀테크 서비스입니다.<br>좋은 혜택을 가진 카드를 발급받는 것도 중요하지만, 더 중요한 것은 발급받은 카드의 혜택 조건을 꼼꼼히 챙기는 것입니다.<br>결제 전 어떤 카드를 쓰는 것이 좋을지 고민된다면, 원스 챗봇에게 먼저 물어보세요. <br>보유 중인 카드의 최신 혜택을 분석하여, 해당 결제처에서 최대 할인을 받을 수 있는 카드를 추천해 드립니다. |
| (8-1) 과제: 문제의 정의 | 우리나라 1인당 신용카드 보유 수는 평균 4.4장에 달하지만, 이중 1373만장은 1년 동안 사용되지 않는 휴면카드이다. <br>카드 발급량은 매년 늘어나지만, 실제 사용으로 이어지지 못하는 이유는 무엇일까?<br>이는 소비자들이 다수의 카드를 보유하고 있지만, 모든 카드의 혜택을 충분히 파악하고 적절히 활용하는 데 어려움을 겪고 있음을 의미한다.<br>수많은 금융상품이 쏟아지고 변화하는 상황 속에서, 소비자들은 자신이 보유한 모든 카드의 혜택 정보를 파악하기 어렵다. <br>'Once'는 사용자가 보유한 카드 중 특정 결제처에서 최대 할인을 받을 수 있는 카드를 추천함으로써, 소비자가 모든 카드의 혜택을 최대한 손쉽게 활용할 수 있는 솔루션을 제공한다. |
| (8-2) 과제: 기존연구와의 비교 | 원스가 정의한 문제를 풀기 위해 비슷한 해결책을 제시한 서비스는 크게 **토스, 카드 고릴라, 뱅크샐러드**가 있다.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;1. **토스** : 카드 발급 추천 서비스는 사용자가 새로운 카드를 발급받기 전, 소비 유형과 신용 정보를 바탕으로 가장 유리한 혜택을 가진 카드를 추천한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 강점 : 유리한 혜택을 가진 카드를 개인에게 맞게 자동 추천해 준다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 약점 : 카드를 발급받지 않으면 그 혜택을 온전히 누리기 어렵다.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;2. **카드 고릴라** : 소비자가 원하는 혜택 유형과 분야에 따라 신용카드를 찾아주는 서비스를 제공한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 강점: 원하는 혜택 분야를 여러 개 선택할 수 있고, 전월 실적을 입력하면 이를 고려해 추천해준다는 점에서 소비자가 자신에게 최적화된 카드를 찾기 편리하다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 약점: 전체 카드 상품 중에서 추천하는 서비스로, 해당 카드를 만들지 않으면 혜택을 받기 어렵다. 카드 상품 자체의 혜택 이외에 카드사별 단기 이벤트, 실제 자신의 전월 실적, 포인트 활용을 고려하지 못한다.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;3. **뱅크샐러드** : 소비자가 입력한 카드 종류, 카드사, 월 지출액 및 원하는 브랜드를 기반으로 카드를 추천해 준다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 강점: 사용자가 원하는 업종별 카테고리를 세부적으로 입력할 수 있도록 하여, 보다 맞춤화된 카드 추천 서비스를 제공한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 약점: 사용자가 직접 자신의 정보를 입력해야 한다는 점에서 번거롭고 접근성이 낮다. 또한 발급받을 카드에 집중되어 있어, 소지 카드 중 사용할 카드를 고르는 데에는 적합하지 않다.<br><br>위 세 개의 경쟁 서비스 모두 사용자가 어떤 카드를 발급받으면 좋을지 추천해 주는 "**카드 발급 전 추천**"에 초점이 맞춰져 있다.<br>반면 원스는 사용자가 이미 보유한 카드의 혜택을 최대한 활용할 수 있도록 돕는 "**카드 발급 후 사용 추천**"에 중점을 둔다. <br>즉 발급받으면 좋은 카드를 추천해 주는 일회성 서비스가 아닌, 이미 사용자가 **보유한 카드를 더 효과적으로 활용하는 방법을 지속해서 추천**해 준다는 점에서 가장 큰 차별점이 있다. <br><br>앞서 언급한 3개의 경쟁 서비스와 원스의 포지셔닝 맵은 다음과 같다. <p align="center"><img src="https://github.com/ekhyoo/CapstoneDesign-24-1H/assets/94354545/592a4120-d9c3-4e94-8f9e-db39e90301bc" width="500"/></p>|
| (8-3) 과제: 제안 내용 | 원스는 40-50대 카드 다보유자 및 20대 짠테크족을 타겟으로 하여 사용자가 보유한 카드 중 결제처에서 최대 할인을 받을 수 있는 카드를 추천한다. 사용자가 모든 카드의 혜택을 손쉽게 활용할 수 있도록 돕기 위해 원스는 **1) 최신 카드 혜택 정보 제공**, **2) 정확하고 빠른 결제 카드 추천**, **3) 단골 매장 미리 푸시 알림** 서비스를 제안한다. <br><br>1) 최신 카드 혜택 정보 제공 <br>&nbsp;&nbsp;&nbsp;&nbsp; : 사용자에게 최신 혜택 정보를 제공하기 위해, 주 1회 기본 카드 혜택 크롤링 및 일 1회 이벤트성 혜택 크롤링을 진행한다. 이를 통해 카드사와 소비자 간의 정보 비대칭 문제를 해결한다.<br><br> 2) 정확하고 빠른 결제 카드 추천 <br>&nbsp;&nbsp;&nbsp;&nbsp;: CODEF API를 이용한 사용자 보유 카드 정보 및 크롤링한 혜택 정보를 바탕으로, 사용자가 보유한 카드 중 결제처에서 최대 할인을 제공하는 카드를 정확하고 빠르게 추천한다. <br><br> 3) 단골 매장 미리 푸시 알림 <br>&nbsp;&nbsp;&nbsp;&nbsp;: Beacon 및 GPS 기술을 이용하여, 단골 매장 근처에서 최대 할인을 받을 수 있는 카드를 미리 알려주는 푸시 알림 서비스를 제공한다. |
| (8-4) 과제: 과제의 주요 기능 | 1. [주요 서비스] 결제 카드 추천<br>&nbsp;&nbsp;&nbsp;&nbsp;- 결제 전 최대 할인을 받을 수 있는 카드를 추천한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;- 보유 카드를 기반으로 하여 개인 맞춤형 카드 추천 서비스를 제공한다.<br><br>2. [주요 서비스] GPS 기반 푸시 알림<br>&nbsp;&nbsp;&nbsp;&nbsp;- 단골 매장 근처에서 결제 카드를 미리 추천해 주는 푸시 알림을 전송한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;- 앱에 접속하지 않아도 되는 높은 사용성을 제공한다.<br><br>3. [주요 서비스] 마이 월렛 <br>&nbsp;&nbsp;&nbsp;&nbsp;- 주 1회 주기적인 크롤링을 통해 보유 카드의 모든 최신 혜택 정보를 제공한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;- 카드 실적 관리를 간편하게 제공한다.<br><br>4. [부가 서비스] 월별 혜택 조회<br>&nbsp;&nbsp;&nbsp;&nbsp;- 월별 목표 금액을 설정하고 달성 여부를 손쉽게 확인할 수 있다.<br>&nbsp;&nbsp;&nbsp;&nbsp;- 카테고리별로 받은 구체적인 할인 혜택 금액을 제공한다.<br><br>5. [부가 서비스] 원스와의 대화<br>&nbsp;&nbsp;&nbsp;&nbsp;- 과거 검색 키워드와 카드 추천 내역을 한눈에 제공한다.<br><br>6. [부가 서비스] 주카드 관리<br>&nbsp;&nbsp;&nbsp;&nbsp;- 주카드 등록을 통해 카드 실적 우선 관리 기능을 제공한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;- CODEF API를 이용한 안전한 카드 관리 서비스이다. |
| (8-5) 과제: 구현 방법 |- 필요 기술 1 : 스크래핑 기반 금융 API를 이용한 사용자 카드 정보 조회 (*스크래핑 : 각 카드사와 통신하여 실제 데이터를 제공)<br>&nbsp;&nbsp;&nbsp;&nbsp;→ `CODEF API` 를 이용하여 사용자 보유 카드 목록, 실적 충족 여부, 카드 승인 내역을 조회한다.<br><br>- 필요 기술 2 : 주 1회 6개 카드사의 기본 카드 혜택 정보 수집 및 일 1회 6개 카드사 이벤트성 혜택 실시간 크롤링 (*6개 카드사 : 국민, 현대, 삼성, 신한, 롯데, 하나)<br>&nbsp;&nbsp;&nbsp;&nbsp;→ 파이썬 크롤링 라이브러리 `BeautifulSoup`, `Selenium`, `Requests` 를 이용하여 카드별 최신 상세 혜택 정보를 수집한다.<br><br>- 필요 기술 3 : 프롬프트 엔지니어링을 이용한 카드 혜택 요약 및 파인튜닝 된 `GPT-3.5 Turbo`를 활용한 사용처에서 최대 할인을 제공하는 카드 추천<br>&nbsp;&nbsp;&nbsp;&nbsp;→ 프롬프트 엔지니어링을 통해 크롤링한 카드 혜택 정보를 요약하여 정형화하고, 파인튜닝 된 모델에 결제처, 결제 금액, 혜택 요약 정보를 input으로 넣어 보유 카드 중 최대 할인을 제공하는 카드를 추천한다.<br><br>- 필요 기술 4 : GPS를 이용한 Geofencing 및 Beacon 기술을 이용하여 사용자 위치 추적<br>&nbsp;&nbsp;&nbsp;&nbsp;→ 위치 정보를 추적하여 사용자의 현재 위치가 단골 매장 근처인지 확인 후, 최대 할인 카드를 미리 알려주는 알림 서비스를 제공한다. |
| (8-6) 과제: 세부 기술 | [SW Architecture] <p align="center"><img src="https://github.com/ekhyoo/CapstoneDesign-24-1H/assets/94354545/fc11431a-7c75-4d13-b2e5-f8c546397b03" width="600"/></p> 1. Front-End : Flutter (Dart) <br> 2. Back-End<br>&nbsp;&nbsp;&nbsp;&nbsp;• 프레임워크 : Spring Boot (Java)<br>&nbsp;&nbsp;&nbsp;&nbsp;• 클라우드 호스팅 : AWS – EC2, RDS(MySQL), S3 <br>&nbsp;&nbsp;&nbsp;&nbsp;• 크롤링 라이브러리 : BeautifulSoup, Selenium <br>&nbsp;&nbsp;&nbsp;&nbsp;• 카드 추천 AI 모델 : OpenAI GPT-3.5 Turbo Fine-Tuning <br>3. 외부 오픈 소스 <br>&nbsp;&nbsp;&nbsp;&nbsp;• Docker <br>&nbsp;&nbsp;&nbsp;&nbsp;• CODEF API : 사용자 보유 카드 목록, 실적 충족 여부, 카드 승인 내역 API 조회<br><br> [카드 추천 AI 모델] <br><br>카드 추천 AI 모델을 위한 세부 기술 프로세스는 크게 **1) 카드 혜택 요약** 및 **2) 카드 추천** 프로세스로 이루어진다.<br><br> 1) 카드 혜택 요약 <br>&nbsp;&nbsp;&nbsp;&nbsp;1-1) `GPT-3.5 Turbo`를 이용하여 크롤링한 카드 혜택 정보를 요약하여 정형화한다. <br><p align="center"><img src="https://github.com/ekhyoo/CapstoneDesign-24-1H/assets/94354545/31277ca9-170f-4e58-9ab2-4b18c8a002bf" width="800"/></p>&nbsp;&nbsp;&nbsp;&nbsp;1-2) 토큰 수가 부족하거나 출력 형식이 잘못된 경우, `GPT-4-Turbo-Preview`를 이용하여 혜택 요약을 다시 진행한다.<br><br>2) 카드 추천<br>&nbsp;&nbsp;&nbsp;&nbsp;2-1) 결제처, 결제 금액, 사용자 보유 카드의 혜택 요약 정보를 활용하여 카드 추천 프롬프트를 작성한다. <p align="center"><img src="https://github.com/ekhyoo/CapstoneDesign-24-1H/assets/94354545/d401261d-f2b4-431b-9a00-171b025ed954" width="500"/></p>&nbsp;&nbsp;&nbsp;&nbsp;2-2) 파인튜닝된 `GPT-3.5 Turbo`에 요청을 보내 보유 카드 중 최대 할인을 제공하는 카드 추천 결과를 응답받는다.|
| (8-7) 과제: 기대 효과 및 의의 | 먼저 카드 혜택을 적절히 활용하는 데 어려움을 겪던 소비자들이, 보유한 카드의 혜택 서비스를 적극적으로 이용하도록 장려함으로써, 휴면카드 활성화에 도움이 될 것으로 기대된다.<br><br>사용자는 카드 결제 전, 보유한 카드 중 결제처에서 최대 할인을 받을 수 있는 카드를 추천받을 수 있다. 또한, 보유한 카드의 매달 실적, 혜택, 포인트 정보를 시각적으로 한눈에 보여주어, 손쉬운 카드 관리 서비스를 제공한다. 이때 주기적인 크롤링으로 최신 혜택 정보 업데이트를 제공하여 사용자는 보유 카드의 모든 최신 혜택 정보를 손쉽게 파악하고 관리할 수 있다. 이는 금융 분야에서 소비자와 카드사 간 정보 비대칭 문제 해결에 기여할 것으로 보인다.|
| (9) 데모 내용 | [중간 데모] <br><br>사용자 보유 카드 기반 최대 할인 카드를 추천하는 Once 챗봇 서비스를 시연한다. 데모는 편의점을 자주 이용하는 20살 '원스'의 계정과, 카페를 자주 이용하는 22살 '라떼'의 계정으로 진행한다.<br><br> 1. 편의점을 자주 이용하는 '원스' 계정으로 로그인한다. <br>&nbsp;&nbsp;&nbsp;&nbsp;1-1. 마이월렛 페이지에서 보유 중인 카드 목록, 최신 카드 혜택 정보 및 실적 현황을 보여준다. <br>&nbsp;&nbsp;&nbsp;&nbsp;1-2. 결제처 후보 키워드 중 'CU' 선택 및 결제 금액을 입력한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;1-3. CU에서 최대 할인을 제공하는 카드 추천 결과를 확인한다. <br><br>2. 카페를 자주 이용하는 '라떼' 계정으로 로그인한다. <br>&nbsp;&nbsp;&nbsp;&nbsp;2-1. 결제처로 '카페' 타이핑 및 결제 금액을 입력한다. <br>&nbsp;&nbsp;&nbsp;&nbsp;2-2. 카페에서 최대 할인을 제공하는 카드 추천 결과를 확인한다. <br><br> 두 가지 데모 시나리오를 통해 **사용자 맞춤형 카드 추천 서비스**를 제공하는 원스의 주요 기능을 보여준다.|
| (10) 기타 | [프론트엔드 실제 애플리케이션 화면] <p align="center"><img src="https://github.com/ekhyoo/CapstoneDesign-24-1H/assets/94354545/69c48e11-e393-491e-a3fa-fc42444c8e31" width="600"/></p> <br><br> [프로젝트 깃허브 주소] <br><br><p><a href="https://github.com/EWHA-LUX/ONCE-FE"><img src="https://img.shields.io/badge/Front--End-02569B?style=for-the-badge&logo=Flutter&logoColor=white&link=https://github.com/EWHA-LUX/ONCE-FE"/></a>&nbsp;&nbsp;<a href="https://github.com/EWHA-LUX/ONCE-BE"><img src="https://img.shields.io/badge/Back--End-6DB33F?style=for-the-badge&logo=Spring Boot&logoColor=white&link=https://github.com/EWHA-LUX/ONCE-BE"/></a></p>|
 
[Return TOP](#list-of-teamsprojects)
 
# Team-08
| (1) 과제명 |실시간 집중도 분석으로 순수 공부 시간 집계 서비스 : Learning Mate
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 08-ECST |
| (3) 팀원 역할 분담 | 이희원(2171087): 리더, 백엔드 서버 프로그래밍, 프론트엔드(UI/UX 프로그래밍) 보조<br>이하나(2171089) : 팀원, 프론드 엔드(UI/UX 프로그래밍)<br>김지윤(2171085) : 팀원, AI프로그래밍, 프론트엔드(UI/UX 프로그래밍) 보조 |
| (4) 팀 지도교수 | 오세은 교수님 |
| (5) 팀 멘토 | 이한솔 / 노서치 / CTO |
| (6) 과제 키워드(keywords) | 자기주도적 학습, 집중도 감지, 실시간 영상 처리 |
| (7) 과제 내용 요약 | AI 기술을 통해 사용자의 학습 태도를 분석하고, 집중도에 따라 자동으로 스톱워치를 작동시키며, 실시간으로 분석 결과를 시각화하는 혁신적인 서비스를 개발하고자 합니다. |
| (8-1) 과제: 문제의 정의 | 대학생, 공무원 시험 수험생, 그리고 입시생 등 자기 주도적 학습을 하는 이들은 자신이 학습에 효율적으로 시간을 쓰는지 객관적인 지표가 없습니다. 이들에게는 외부에서 학습을 관리해주는 제3자가 없기 때문에, 스스로 학습 방향과 효율을 점검해야만 합니다. 이 과정에서 대부분은 스톱워치를 이용해 공부한 시간을 측정하며 학습을 진행합니다. 그러나, 학습과 무관한 다른 활동(예: 학습 중 딴 짓, 화장실 사용, 물 마시기, 잠시 자리를 비우는 등)을 위해 스톱워치를 일시정지하는 것은 귀찮고, 잊어버리기 쉬운 작업입니다. 또한, 이는 학습에 실제로 집중한 시간을 정확하게 측정하는 데 부족합니다. 이러한 문제는 일일 학습 목표량을 정확하게 설정하는 것을 어렵게 만들며, 자가 학습 효율성에 대한 명확한 진단을 내리는 데 장애가 되고 있습니다. 결과적으로, 학습자는 자신이 얼마나 학습에 시간을 할애하고 있는지, 추가적인 시간 투자가 필요한지를 판단하고 구체적인 학습 계획을 수립하는 데 있어 어려움을 느끼고 있습니다. |
| (8-2) 과제: 기존연구와의 비교 | 구르미 캠 스터디<br>"구르미 캠 스터디"는 사람들이 서로 공부하는 모습을 공유하고, 클라우드를 통해 스터디를 진행하는 서비스입니다. 이 서비스는 설치가 필요 없어 편리하며, 스톱워치 기능을 통해 공부 시간을 측정할 수 있습니다. 또한, 측정된 공부 시간을 기반으로 순위를 매겨 다른 사용자의 공부량도 확인할 수 있습니다. <br>그러나, 실제로 서비스를 이용한 결과 중에는 하루에 21시간이나 공부한 사용자를 발견하였습니다. 이는 현실적으로 이해하기 어려운 숫자입니다. 공부한 시간이 정확하게 측정되지 않을 수 있고, 랭킹 시스템을 악용하여 타이머를 조작한 사용자들이 있을 수 있습니다. <br>우리의 서비스는 사용자들의 공부 모습을 캠으로 실시간으로 측정하고,  AI 기술을 활용하여 공부 여부를 정확히 확인합니다. 이를 통해 랭킹 시스템의 공정성과 정확성을 보다 향상시킬 수 있습니다.<br><br>열품타<br>“열품타"는 To do list를 작성하여 목록별로 자신의 공부를 측정할 수 있습니다. 이때, 각 공부 목록에 시간 측정이 가능하고, 다른 공부 목록을 넘어갈 때, 현재 공부 목록의 시간 측정은 중지되고 다음 공부 목록의 시간 측정이 시작됩니다. 또한, 스터디 모임을 생성하여 그룹 내에 다른 사람들과 측정한 공부시간을 공유하여 좋은 경쟁력을 가져 집중력을 유지 시켜줍니다.<br>To-Do List로 공부 목록을 만들어 시간 측정이 가능한 기능은 좋은 학습 서비스입니다.   그러나, 사용자가 직접 타이머를 제어하여 공부 시간을 측정하는 시스템은 순수 학습 시간을 정확하게 파악하기 어렵게 만들 수 있습니다. 타이머를 시작하고 공부를 시작해도, 중간에 휴대폰을 확인하거나 잠깐 쉬어 앉거나 화장실에 가는 등의 행동이 발생하면 가짜 공부 시간이 추가될 수 있습니다. 이러한 문제를 해결하기 위해 우리 서비스는 AI 기술을 도입하여 사용자의 행동을 식별하고, 공부 이외의 활동을 감지하여 공부 시간 집계에 포함되지 않도록 합니다. 이를 통해 학습자는 자신의 정확한 공부 시간을 파악할 수 있습니다. |
| (8-3) 과제: 제안 내용 |  앞서 지속적으로 제기되었던 시간 측정의 정확성 문제에 대한 해결책으로, 우리는 teachable machine 기술을 도입할 것입니다. 이를 통해 사용자가 현재 어떤 행동을 취하고 있는지를 실시간으로 파악하고, 그 결과를 그래프 및 수치로 시각화하여 제공할 것입니다. 공부 중이라고 인식되는 경우에만 스톱워치가 작동되어 순수 공부 시간을 측정합니다. 그러나, 물을 마시거나, 졸거나, 학습 상황에 맞지 않는 웃음을 짓고 있는 등의 활동이 감지될 경우에는 스톱워치가 자동으로 공부 시간 측정이 중단됩니다. 이러한 방식으로, 우리의 서비스를 통해 순수한 공부 시간을 정확하게 측정할 수 있게 될 것입니다. |
| (8-4) 과제: 과제의 주요 기능 | 기능1. 자동 타이머 기능 : 오픈 소스의 Teachable Machine을 도입하여 사용자의 행동 을 분석하여 학습 행동이라고 판단될 때에만 공부 시간이 측정됩니다.<br>기능 2. 정확한 순수 공부 시간 측정 : 비학습 행동(휴식, 졸음, 물 섭취, 자리 이탈, 하품, 엎드리기 등)이 감지되면, 타이머가 중지됩니다. 반대로 온전한 학습 행동을 실시하면 타이머는 작동됩니다.<br>기능 3. 실시간 집중도 score 피드백 : Teachable Machine을 통해 사용자의 행동을 감지하여 즉각적으로 집중도를 그래프로 시각화됩니다. 집중도 그래프를 기록하여 사용자가 과거의 데이터를 한 눈에 볼 수 있습니다. |
| (8-5) 과제: 구현 방법 | 서버: Django<br>기능 및 역할: Django를 사용하여 RESTful API를 구현합니다. 이 API는 클라이언트(React 앱)로부터 사용자 데이터, 학습 진행 상황, 피드백 요청 등을 받아 처리합니다. <br>개발 절차:<br>모델 정의: 사용자 데이터, 학습 진행 상황 등을 저장할 데이터베이스 모델을 Django ORM을 사용해 정의합니다.<br>API 뷰 개발: Django의 View를 활용하여 데이터 처리 및 응답 로직을 개발합니다. 이 과정에서 Django Rest Framework의 도구들을 사용해 RESTful API의 구성을 용이하게 합니다. 이를 통해 API 개발의 복잡성을 줄이고, 개발 속도를 향상시킬 수 있습니다.<br><br>클라이언트: React<br>기능 및 역할: React를 사용하여 사용자 인터페이스를 구현합니다. 이 인터페이스는 사용자로부터 데이터를 수집하고, Teachable Machine에서 처리된 데이터를 시각적으로 표현하는 역할을 합니다.<br>개발 절차:<br>컴포넌트 설계: 사용자 경험(UX)을 고려하여 필요한 컴포넌트(예: 로그인 폼, 학습 진행 상황 대시보드 등)를 설계합니다.<br>상태 관리: React의 상태 관리 기능을 활용하여 사용자 입력, 서버 응답 등의 상태를 관리합니다. 필요에 따라 Redux나 Context API를 사용할 수 있습니다.<br>API 통신: Axios 등의 HTTP 클라이언트 라이브러리를 사용하여 Django 서버와의 REST API 통신을 구현합니다.<br>Stopwatch : React와 Redux를 활용하여 구현됩니다. To-do-list의 각 목록에 연결되어, 사용자의 학습 상태에 따라 동작합니다. 훅을 사용하여 스톱워치의 활성화 상태, 일시정지, 시간을 상태 관리합니다. Redux Store에서 학습 상태에 따라 스톱워치가 자동으로 시작되거나 리셋됩니다. 스톱워치가 활성화되고 일시 정지되지 않았을 때, 매 10밀리초마다 시간 상태를 업데이트 합니다. 스톱워치가 리셋됐을 때, Redux Action을 디스패치하여 Redux Store의 상태를 업데이트 합니다. 스톱워치의 활성 상태와 동기화되어 애플리케이션의 다른 부분과 상태 정보를 공유할 수 있게 합니다.<br>그래프 도입 : React 프로젝트에 Chart.js 라이브러리를 통합합니다. 차트 렌더링을 위해 Line은 라인 차트를 그리기 위한 React-Chartjs-2 컴포넌트이며, ChartJS와 필요한 차트 요소들은 차트의 기능을 확장하고 구성하기 위해 등록됩니다. 실시간으로 파트가 업데이트 되기 위해, React의 상태 관리 기능을 활용하여 차트 데이터를 동적으로 업데이트합니다.<br><br>데이터베이스: MySQL<br>기능 및 역할: MySQL을 사용하여 사용자 데이터, 학습 데이터 등의 정보를 저장합니다. Django 서버에서 ORM을 통해 데이터베이스와의 상호작용을 관리합니다.<br>구성: 데이터베이스 스키마는 프로젝트의 요구 사항을 철저히 반영하여 설계됩니다. 이 구성 과정에는 사용자 정보를 저장하는 테이블, 각 학습 세션의 상세 정보를 포함하는 테이블, 그리고 학습 결과를 기록하는 테이블 등이 포함됩니다. 각 테이블은 효율적인 데이터 관리와 접근을 위해 적절히 인덱싱되고, 관계 설정을 통해 데이터 무결성이 유지됩니다.<br><br>인공지능: Teachable Machine<br>기능 및 역할: Teachable Machine을 사용하여 사용자의 학습 데이터를 분석하고, 학습 진행 상황에 대한 피드백을 제공합니다.<br>Django 서버가 Teachable Machine 모델과의 통신을 관리합니다.<br>구현: Teachable Machine에서 제공하는 API를 사용하여, 학습 모델을 서버에 통합합니다. 사용자로부터 입력 받은 데이터를 모델에 전달하고, 분석 결과를 사용자에게 피드백으로 제공합니다. |
| (8-6) 과제: 세부 기술 | FE : React 라이브러리와 Tailwind CSS를 활용하여, 직관적이고 반응형의 웹 인터페이스를 구현했습니다.<br>애플리케이션 내의 핵심 기능인 스톱워치를 To Do 리스트의 목록들과 연결하기 위해 Redux를 사용하여 각 컴포넌트의 상태를 중앙에서 관리하고, 사용자 인터페이스의 일관성과 반응성을 보장했습니다.<br>Google의 Teachable Machine에서 수신된 데이터를 기반으로 Chart.js를 활용하여 그래프를 실시간으로 렌더링합니다. 이는 사용자의 학습 행동을 시각적으로 분석할 수 있게 해 주며, 데이터는 지속적으로 업데이트됩니다. 또한, React 기반의 스톱워치를 통해 사용자의 실제 학습 시간을 정확하게 측정하고 반영합니다.  <br>BE : MySQL을 사용하여 데이터를 저장하고 관리하는 Django 기반의 백엔드 시스템을 통해 
구성되어 있습니다. Django는 강력한 ORM을 제공하여 데이터베이스 작업을 간소화하고, 보안이 강화된 웹 애플리케이션을 빠르게 개발할 수 있도록 지원합니다.<br>백엔드와 프론트엔드(React) 사이의 통신은 REST API를 통해 이루어집니다. 이 방식은 서버와 클라이언트 간에 효율적이고 안정적인 데이터 교환을 가능하게 하며, 웹 브라우저에서 직접적인 API 호출을 통해 필요한 데이터를 비동기적으로 불러오고 처리할 수 있도록 합니다.<br>최종적으로, 저희 서비스는 서버리스 아키텍처를 사용하지 않고, 클라이언트 사이드에서 동적인 기능을 처리하기 위해 Django 서버를 통한 REST API를 활용하여 데이터를 관리하고 있습니다.
<br>AI: Google의 오픈 소스 플랫폼인 Teachable Machine과 TensorFlow Lite를 도입하였습니다. 웹캠을 통해 수집된 사용자의 이미지 및 동영상 데이터는 Teachable Machine에서 처리되어, 학습된 결과를 로컬 스토리지에 저장합니다. 이후, 저장된 데이터는 React 애플리케이션으로 전송되어 사용자 인터페이스에 통합되며, 이를 통해 사용자는 자신의 행동 패턴을 시각적으로 확인할 수 있습니다. <br><br>모듈 1: TensorFlow Lite와 Teachable Machine을 활용한 학습 진행 상황 모니터링과 Chart.js으로 학습 진행 상황 시각화<br><br>i) 기능 설명<br>이 모듈은 Teachable Machine을 활용하여 사용자의 학습 진행 상황을 실시간으로 모니터링합니다. 사용자가 수행하는 학습 활동(예: 필기, 집중, 핸드폰사용, 졸음 등)이 정해진 기준에 부합하는지를 평가합니다. 사용자의 학습 데이터를 수집하고, 그 데이터를 기반으로 개인별 맞춤 피드백을 제공합니다.<br>TensorFlow Lite를 통해 학습된 모델을 React와의 통합을 통해 클라이언트 사이드에서 경량화하여 실행함으로써, 더욱 빠르고 효율적인 데이터 처리와 반응속도를 구현합니다. 이를 통해 Chart.js를 활용하여 이 모든 학습 데이터와 피드백 반응을 시각화합니다. 사용자는 그들의 학습 패턴과 진행 상황을 명확하게 이해할 수 있습니다.<br><br>ii) 설계 내용<br>Teachable Machine과 Teachable Machine 모델을 통해 사용자로부터 입력 받은 데이터(예: 이미지, 오디오, 비디오 등)를 분석합니다. 학습 성공 여부를 판단하는 알고리즘을 개발하여, 사용자가 제대로 된 학습을 진행하고 있는지 실시간으로 확인합니다.<br>TensorFlow Lite는 이 모델을 경량화하여, 브라우저나 모바일 장치에서도 높은 성능을 유지할 수 있도록 합니다. 이렇게 경량화된 모델은 클라이언트 사이드에서 실행되어, 데이터 처리와 반응속도가 획기적으로 개선됩니다.<br>또한, 사용자의 학습 진행 상황과 피드백 반응을 시각적으로 표현하기 위해 Chart.js를 활용합니다. 이 시각화 도구는 사용자가 자신의 학습 패턴과 진행 상황을 명확하고 직관적으로 이해할 수 있게 돕습니다. 학습 데이터를 기반으로 한 개인별 맞춤 피드백은 사용자에게 매우 구체적인 가이드를 제공하여, 학습 효율을 극대화하는 데 중요한 역할을 합니다.<br>이러한 통합적 접근 방식은 사용자 경험을 극대화하며, 학습 과정의 효율성을 크게 향상시킵니다.<br><br>모듈 2: React-Redux를 통한 To-do-list의 목록을 상태관리하여 캠 버튼과 스톱워치의 기능을 자동으로 동시 활성화
<br><br>
i) 기능 설명<br>

React-redux는 JavaSript 기반 애플리케이션의 상태 관리를 위한 라이브러리입니다. React 자체의 상태 관리는 컴포넌트 기반으로 이루어지기 때문에 복잡한 애플리케이션에서 여러 컴포넌트 간에 상태를 공유하고 관리하는 것이 어렵기 때문에 Redux를 사용하여 애플리케이션의 모든 상태를 중앙 집중화 형식으로 관리하여, 여러 컴포넌트에서 상태를 쉽게 공유하고 효율적으로 관리할 수 있습니다.<br>ii) 설계 내용<br>Redux Store는 애플리케이션의 모든 상태를 중앙 집중화하여 관리하며, 이를 통해 To-do 항목의 텍스트 관리와 사용자의 학습 상태 같은 정보를 저장합니다. <br>만약 To-do를 수정하거나 학습 상태의 활성화 여부를 변경하고 싶을 때는, 리듀서를 통해 이러한 요구사항을 구현합니다. 리듀서는 특정 액션에 반응하여 상태를 업데이트하는 역할을 담당합니다.<br>To-do 리스트의 각 항목에 있는 버튼을 클릭할 때 스톱워치와 캠을 동시에 제어하기 위해, 학습 상태를 관리하는 액션 크리에이터를 사용합니다. 이는 사용자가 학습을 시작하거나 중지할 때 관련 상태를 적절히 조정합니다. 이는 사용자의 상호작용에 따라 필요한 상태 변화를 트리거합니다.<br>React 컴포넌트는 useSelector 훅을 사용하여 Redux store의 상태를 컴포넌트에 바인딩하고, useDispatch 훅을 사용하여 액션을 디스패치합니다. 이 연결을 통해 React 컴포넌트는 Redux 상태를 실시간으로 반영하며 사용자 인터페이스를 업데이트합니다.<br>이러한 방식은 상태 관리의 일관성을 보장하며, 애플리케이션 전체에서 상태를 효율적으로 동기화하고 관리할 수 있게 합니다.
|
| (8-7) 과제: 기대 효과 및 의의 | 1. 정확한 학습 시간 측정과 자동 타이머 시스템<br>우리 서비스는 '공부'로 인식되는 행동 및 활동에 한해 공부 시간을 기록합니다. 이를 통해 사용자는 자신의 학습량을 정확히 파악할 수 있습니다. 또한, 사용자들은 학습 과정에서 타이머를 직접 제어할 필요 없이 AI가 자동으로 시간을 측정하여 번거로움을 줄여줍니다. 이를 통해 사용자들은 타이머에 신경쓰지 않고 자유롭게 학습할 수 있습니다.<br>2. 사용자의 학습 자가 진단 평가 <br>사용자의 학습 태도 데이터 기록을 통해 사용자는 학습 자가 진단이 이루어집니다. 학습 과정에서 학습 외의 자신의 무의식적인 행동을 발견하고 그에 따른 개선할 수 있는 기회를 제공합니다. 만약 사용자가 공부 방해 요소 행동을 하지 않았다면, 자신의 학습 태도에 스스로 칭찬하며 자신감을 얻고 학업 성취도를 향상시킬 수 있습니다.<br>3. 주도적인 학습 대상자에게 적합<br>타 어플과 달리 우리 서비스는 사용자의 행동 감지가 포함되어 정확한 공부 타이머 서비스가 제공됩니다. 극대의 순수 공부량 및 공부 시간이 필요한 공시생, 대학생들에게는 아주 효과적인 서비스가 될 것을 기대합니다.<br>4. 실시간 집중도 score 기반으로 즉각적인 학습 태도 개선 반영<br>사용자의 학습 행동 기반으로 집중도 분석 결과값이 실시간으로 그래프로 시각화되어 사용자가 자신의 집중 수준을 즉시 확인하고, 필요한 경우 학습 태도를 적절히 조정할 수 있습니다. |
| (9) 데모 내용 | (회원가입,로그인 성공 후)To-do-list 목록에 공부 목록 등록 후, 캠 start 버튼 누르기 -> 사용자의 학습 태도 파악 -> 학습 상태 여부에 따른 스톱워치 자동 작동 및 중지와 함께 실시간으로 사용자의 집중도 분석 결과값 시각화 -> 집중도 분석 페이지를 통해 사용자의 과거 집중도 분석 데이터 조회 |
| (10) 기타 | SW구조도<br>![image](https://github.com/hanacse/CapstoneDesign-24-1H/assets/144085570/f9e104f7-847b-4cdc-8572-a3d84321b09f)
|
 
[Return TOP](#list-of-teamsprojects)
 
# Team-09
| (1) 과제명 | AI 기반 교내 스마트 중고거래 플랫폼
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 09-강철몽둥이 |
| (3) 팀원 역할 분담 | 김해인(1771017): 리더, 개발, 백엔드<br>조주연(2076392): 팀원, 기획, 프론트엔드<br>최혜민(1876431): 팀원, 디자인, 백엔드 |
| (4) 팀 지도교수 | 반효경 |
| (5) 팀 멘토 | 최철호 / 온새하 / 대표 |
| (6) 과제 키워드(keywords) | 중고거래,대학생,시간표매칭 |
| (7) 과제 내용 요약 | 캠플'은 대학교 내 중고 거래를 위한 AI 기반 플랫폼으로, 사용자의 수업 시간표를 기반으로 한 거래 시간/장소 매칭과 적정가 자동산출 기능을 제공합니다. 이를 통해 거래의 편의성과 신뢰도를 높이며, 학교 커뮤니티 기능을 통해 사용자 간 소통과 거래의 안전성을 강화합니다. '캠플'은 교내 중고 거래의 활성화와 사용자 만족도 향상을 목표로 합니다. |
| (8-1) 과제: 문제의 정의 | 현재 대학생들 사이에서 중고 거래는 흔하지만, 거래 장소와 시간 조율의 어려움, 물품의 적정 가격 파악의 어려움, 그리고 거래의 신뢰도 문제가 주요한 장애물로 남아있습니다. 이러한 문제들은 거래자 간의 신뢰를 저하시키고, 중고 거래의 활성화를 방해합니다. |
| (8-2) 과제: 기존연구와의 비교 | 다른 연구나 프로젝트에서는 중고 거래 플랫폼에 사용자 평가 시스템을 도입하거나, 공공장소에서의 안전한 거래를 위한 '안전거래소'를 설치하는 방법을 제안했습니다. 또한, AI 기반 가격 추천 시스템을 통해 물품의 적정 가격을 제시하는 방법도 있습니다.<br><br>장점 / 단점 비교<br>사용자 평가 시스템: 거래 후 사용자 간 평가를 통해 신뢰도를 제고할 수 있으나, 초기 사용자 확보가 어렵고, 부정적인 평가로 인한 분쟁이 발생할 수 있습니다.<br>안전거래소: 실제로 안전한 거래를 보장할 수 있으나, 고정된 장소에 의존해야 하며, 모든 사용자에게 접근성이 좋은 위치를 확보하는 것이 어렵습니다.<br>AI 기반 가격 추천 시스템: 물품의 적정 가격을 쉽게 파악할 수 있으나, 시장 변동이나 특수한 물품의 경우 정확도가 떨어질 수 있습니다. |
| (8-3) 과제: 제안 내용 | 캠플'은 교내 중고거래의 특수성을 고려하여 개발된 플랫폼으로, 다음과 같은 해결책을 제안합니다.<br><br>시간표 매칭/스케쥴링 시스템을 통해 거래 장소와 시간 조율의 편의성을 대폭 향상시키며, 교내에서의 거래이기 때문에 신뢰도도 높습니다.<br><br>자체 제작한 품질 등급 시스템과 거래 이력 데이터를 기반으로 중고 물품의 적정 가격을 자동으로 산출해 사용자가 합리적인 가격에 거래할 수 있도록 돕고, 시장의 활성화를 촉진합니다 |
| (8-4) 과제: 과제의 주요 기능 | 1.교내 중고거래 플랫폼<br>2.거래장소/시간 자동 스케쥴링 기능<br>사용자의 수업 시간표를 기반으로 거래자와 판매자가 공강 시간에 만날 수 있는 최적의 시간과 장소를 자동으로 추천합니다. 이는 거래 장소와 시간 조율의 편의성을 대폭 향상시키며, 교내에서의 거래이기 때문에 신뢰도도 높습니다.<br>3.중고물품 적정가 추천 알고리즘<br>자체 제작한 품질 등급 시스템과 거래 이력 데이터를 기반으로 중고 물품의 적정 가격을 자동으로 산출합니다. 이는 사용자가 합리적인 가격에 거래할 수 있도록 돕고, 시장의 활성화를 촉진합니다. |
| (8-5) 과제: 구현 방법 | React Native나 Flutter와 같은 크로스 플랫폼 개발 프레임워크를 사용, Adobe XD, Sketch, Figma와 같은 도구를 사용하여 사용성을 고려한 디자인을 구현합니다. |
| (8-6) 과제: 세부 기술 | 1.사용자 관리 엔진<br> 1) 인터페이스: 사용자 인터페이스는 간결하고 직관적인 로그인 및 등록 화면으로 구성됩니다. 소셜 로그인 옵션(예: Google, Facebook)을 제공하여 사용자가 쉽게 접근할 수 있도록 합니다. 2) 인증 방식: Firebase Authentication을 사용하여 이메일 및 패스워드 기반 인증과 함께 다양한 소셜 로그인 방식을 지원합니다. 이는 보안성 높은 인증 절차를 보장하며, 개발자가 인증 관련 로직을 직접 관리할 필요가 없도록 합니다. 3) 데이터베이스 연동: 사용자의 프로필 정보는 Firebase의 Firestore 또는 Realtime Database에 저장되며, 사용자가 자신의 정보를 업데이트할 때 실시간으로 데이터베이스에 반영됩니다. 4) 보안 및 개인정보 보호: 사용자 데이터는 암호화되어 저장되며, 파이어베이스의 보안 규칙을 통해 데이터의 안전한 접근이 보장됩니다.<br> 2. 데이터 처리 엔진<br> 1) 비동기 처리: 사용자의 요청 처리 시, 비동기적으로 데이터를 처리하여 애플리케이션의 반응성을 향상시킵니다. JavaScript의 async/await 패턴을 활용하여 클린 코드를 유지합니다. 2) 캐싱 전략: 자주 접근하는 데이터는 로컬 캐시에 저장하여 빠른 데이터 조회를 지원합니다. 이는 네트워크 지연을 최소화하고 사용자 경험을 개선합니다. 3) 외부 API 연동: 날씨 정보, 지도 서비스 등 필요에 따라 외부 API를 호출하여 애플리케이션의 기능을 확장합니다. Axios 라이브러리를 사용하여 외부 API와의 통신을 관리합니다. 4) 데이터 검증 및 적합성 평가: 사용자로부터 입력된 데이터는 서버 측에서 검증되어야 합니다. 데이터의 형식, 유효성을 검사하여 애플리케이션의 안정성을 보장합니다. |
| (8-7) 과제: 기대 효과 및 의의 | 시간표 매칭 시스템을 통해 거래의 편의성을 높이고, 교내 중고 거래 플랫폼인 만큼, 사용자 간의 신뢰도가 높아지며 거새 과정에서 발생할 수 있는 위험을 줄여줍니다. 적정가 자동산출 기능을 통해 합리적인 가격에 거래를 진행할 수 있고 가격에 대한 불필요한 논쟁을 줄여줍니다. |
| (9) 데모 내용 |   |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-10
| (1) 과제명 | 잇터뷰(iterview) : IT 취준생을 위한 CS 기술 구두 면접 대비 & 학습 플랫폼
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 10-Qt |
| (3) 팀원 역할 분담 | 이서진(2176258):	팀장, 프론트엔드 개발, UI 디자인<br>임채영(2176316): 백엔드 개발, GPT 튜닝, 채점 알고리즘 설계<br>이채원(2168022): AI 개발, STT, TTS, 표정 분석, 모델 서버 구축 |
| (4) 팀 지도교수 | 심재형 |
| (5) 팀 멘토 | 맹수연 / SAP / 개발자 |
| (6) 과제 키워드(keywords) | 기술 면접, 종합적 평가와 첨삭, 반복 학습 |
| (7) 과제 내용 요약 | iterview는 **IT 분야에서의 기술 구두 면접 대비 및 학습을 위한 플랫폼**으로, 사용자는 맞춤형 면접을 선택할 수 있어 효율적인 학습이 가능합니다. 비언어적 특성 분석을 포함한 객관적인 점수와 첨삭을 제공하며, 면접 기록과 피드백을 아카이빙하여 성장을 추적할 수 있습니다. 이를 통해 사용자는 자신의 지식 수준과 부족한 부분을 파악하여 개선할 수 있습니다. |
| (8-1) 과제: 문제의 정의 | 첫째로, 기술 분야의 면접은 특정 기술에 대한 이해와 능력을 검증하는 과정인 만큼, 기술적인 질문에 대한 실제 경험적인 연습이 필요합니다. 그러나 기존의 면접 연습 플랫폼은 주로 인성 면접 질문에 중점을 두어 왔기 때문에, 기술적인 측면에 대한 충분한 대비가 이루어지지 않았습니다.<br><br>둘째로, 수치화된 면접 결과를 얻을 수 없다는 한계가 있습니다. 이는 면접 성과를 객관적으로 평가하고 개선할 수 있는 중요한 요소입니다. 기술적인 면접에서는 정확한 기술적 지식과 능력을 확인하기 위해 객관적인 평가가 필요한데, 기존 플랫폼은 이를 충분히 제공하지 못하고 있습니다.<br><br>그렇기 때문에 이러한 한계를 극복하기 위해 기술 분야의 면접 연습 플랫폼이 필요합니다. 이를 통해 사용자들은 실제 기술적인 질문에 대한 대비가 가능하며, 수치화된 결과를 통해 자신의 역량을 정확히 파악할 수 있습니다. 이는 취업 준비자들에게 실질적인 도움을 줄 수 있을 것입니다. |
| (8-2) 과제: 기존연구와의 비교 | [pramp] <br> code 위주의 기술 면접 플랫폼으로 사용자끼리 서로 면접자와 면접관 역할을 돌아가면서 연습을 할 수 있습니다. code 등 볼 수 있는 자료들이 제시된다는 장점이 있으나, 혼자 연습할 수 없고, 채점 결과나 면접자에 대한 비언어적 표현이나 평가를 받을 수 없다는 단점이 있습니다.<br><br>[사람인 Ai 면접 코칭] <br> chatGPT 기반 면접 연습 플랫폼으로 면접 질문을 자동으로 생성하여 제공한다는 장점이 있습니다. 그러나 직무 관련 면접보다는 인성 면접 위주의 질문을 제공한다는 단점이 있습니다. <br><br>[비교 및 개선] <br> pramp의 경우 IT 분야에 특화되어 있으나, 비언어적 표현에 대한 평가가 부족하고 사람인 Ai 면접 코칭의 경우 질문을 자동으로 생성해 주지만 IT 직무 관련 질문은 제공하지 않는다는 한계가 존재합니다. iterview는  IT 분야 특정 질문 제공 및 첨삭, 표정, 말 더듬는 시간 비율 분석 등의 비언어적 표현에 대한 평가를 제공하여 이를 개선하고자 합니다.|
| (8-3) 과제: 제안 내용 | 1. 사용자가 자신이 원하는 과목을 선택하여 진행하는 맞춤형 면접으로 높은 효율성 제공<br>2. 면접 중 사용자의 표정, 말 더듬는 시간, 응답 지연 시간 등 다양한 비언어적 특성을 분석하여 제공<br>3. 사용자의 면접 기록과 피드백 결과를 아카이빙, 재학습하며 성장과정 트래킹 가능<br>이 세가지 아이디어를 통해 사용자는 “내가 무엇을 알고 무엇을 모르는지를 아는” 메타인지 학습이<br>가능하게 되어 자신의 부족한 지식이 무엇인지 인지할 수 있을 것으로 기대합니다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 과목 선택 기능<br>사용자는 자신이 원하는 컴퓨터 과학 분야의 특정 주제나 기술에 대한 면접을 선택할 수 있습니다. 이를 통해 사용자는 자신의 관심 분야나 역량을 중점적으로 향상시킬 수 있습니다.<br>2. 면접 채점 및 수치화<br> iterview는 사용자의 면접을 종합적으로 평가하고, 비언어적인 특성뿐만 아니라 답변의 정확도도 평가합니다. 이를 통해 사용자에게 객관적인 수치화된 평가 결과를 제공합니다. 이는 사용자가 자신의 역량을 정확하게 파악하고 개선할 수 있는 기반을 마련해줍니다.<br>3. 면접 오답 노트 기능<br> 사용자는 자신의 면접 기록과 피드백 결과를 아카이빙할 수 있습니다. 이를 통해 사용자는 자신의 성장 과정을 추적하고, 부족한 부분을 식별하여 재학습할 수 있습니다. 이는 사용자가 지속적인 학습과 성장을 위한 피드백을 제공합니다.<br>4. ChatGPT API 연동<br> 사용자의 답변을 채점하고 피드백을 생성하기 위해 ChatGPT를 활용합니다. 이를 통해 사용자는 실제 면접과 유사한 상황에서 자신의 답변을 평가받을 수 있습니다.<br>5. 음성 분석 및 STT 기술<br> 면접 음성을 텍스트로 변환하기 위해 음성 분석 및 STT(Speech-to-Text) 기술을 사용합니다. 이를 통해 사용자는 면접 응답을 텍스트로 확인하고 분석할 수 있습니다.<br>6. 표정 감정 인식 FER 기술<br> 면접 영상에서 표정을 감지하고 감정을 분석하기 위해 FER(Facial Expression Recognition) 기술을 사용합니다. 이를 통해 면접자는 자신의 표정에 대한 피드백을 받아 개선할 수 있습니다.|
| (8-5) 과제: 구현 방법 |![시스템 아키텍처](https://github.com/TEAM-ITERVIEW/CapstoneDesign-24-1H/assets/89545462/94c4357d-8d3a-437d-a03e-c72c086bc62b)<br> **[프론트엔드]** <br>Typescript, Next.js로 개발하여, Vercel로 배포된 웹 어플리케이션을 제공합니다.<br> **[백엔드]** <br> Node.js, Nginx를 이용한 API 개발 및 서버 구축, PostgreSQL를 통한 DB 구축, Github action을 통한 CI/CD, AWS를 통해 배포하여 프론트엔드와 통신합니다. <br> **[ML]** <br>openCV를 사용하여 학습한 표정인식 모델, Librosa mfcc를 사용하여 학습한 음성 분석 모델, Google Cloud TTS를 기능을 제공하는 API 서버를 Flask를 통해 구축하였고 AWS로 배포하여 프론트엔드와 통신합니다.|
| (8-6) 과제: 세부 기술 |**1.비언어적 표현 분석**<br>librosa MFCC 면접 음성 분석 전 특성 추출 및 벡터화 비언어적 표현(‘음', '어'와 같은 추임새) 학습 시킨 CNN 모델로 언어적 표현과 분류, pydub 0.25.1 speech Recognition 모듈을 사용해 진행, 침묵 구간, 지연 시간 (비언어적 표현)을 계산하여 전체 발화 시간 대비 비율을 제시합니다.<br>**2. 표정 분석**<br>openCV를 이용한 얼굴 인식, 7가지 표정을 학습한 CNN 모델을 이용하여, 표정 감정을 분석하여 제시합니다.<br> **3. 채점 및 피드백 생성**<br>gpt 프롬프팅을 통하여, STT로 텍스트화한 사용자의 답변을 채점 및 수치화하여 제공합니다.|
| (8-7) 과제: 기대 효과 및 의의 |사용자는 원하는 과목을 선택하고, 그에 대한 기술 질문에 답변하면서 '내가 무엇을 알고 모르는지에 대한 메타인지 학습'이 가능합니다. 또한 구체적 수치와 첨삭을 통해서 면접에서 개선해야할 부분을 학습할 수 있습니다. 또한 일회성 연습에 그치는 것이 아니라, 재답변 기능을 통해 이전 답변과 비교하여 성장 과정을 트래킹할 수 있습니다.|
| (9) 데모 내용 |1. CS 기술 모의 면접<br>사용자가 CS 과목을 선택하면 그에 따른 질문을 제공하고, 가상 면접관의 음성과 함께 면접을 진행합니다. 사용자 답변 중 캡처된 사진을 통한 표정 분석, 답변 음성에 대한 비언어적 표현 분석 및 tts를 진행합니다.<br>2. 모의 면접 채점 결과 및 첨삭<br>면접에 대한 답변 텍스트를 프롬프팅된 생성형 AI로 채점하고 첨삭합니다. 이후 비언어적 표현과 함께 면접에 대한 피드백을 제공합니다.<br>3. 학습 노트를 통한 재학습 및 아카이빙 기능<br> 1, 2번 기능을 통한 면접 결과를 저장 후 학습 노트로 제공합니다. 이후 사용자는 재답변 기능을 통해 이전 결과와 비교하여 확인할 수 있습니다.
| (10) 기타 ||
 
[Return TOP](#list-of-teamsprojects)
 
# Team-11
| (1) 과제명 | 망하지망고 : 망고 초보 재배자를 위한 이미지 객체 검출 및 분류 기반 농작물 질병 식별 앱 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 11-로켓단 |
| (3) 팀원 역할 분담 | 박서연(2144010): 팀장, UI 디자인, React Native 프런트엔드 개발, 애플리케이션 배포<br>정유진(2062084): 팀원, Spring Boot 백엔드 개발, AWS 관리, 인공지능 개발<br>조하은(2144026): 팀원, Spring Boot 백엔드 개발, AWS 관리, 인공지능 개발<br>최윤지(2171050): 팀원, UI 디자인, React Native 프런트엔드 개발, 애플리케이션 배포 |
| (4) 팀 지도교수 | 반효경 |
| (5) 팀 멘토 | 박재현/프리랜서/개발자 |
| (6) 과제 키워드(keywords) | 망고, 질병, 대처 |
| (7) 과제 내용 요약 | 저희 팀의 주제는 “고소득 작물인 망고의 잎 사진 분석을 통해 망고의 질병을 식별하여 망고 초보 재배자들이 망고의 질병에 빠르게 대처할 수 있도록 도와주는 모바일 앱 서비스”입니다. 망고 재배 관련 정보를 쉽게 얻지 못하는 재배자들이 잎 사진을 찍어 올리기만 하면 망고의 질병 식별 및 질병에 따른 대처 방법 정보를 신속하게 알려주어 실패 없는 망고 재배 경험을 제공하고자 합니다. |
| (8-1) 과제: 문제의 정의 | [재배가 까다로운 작물, 망고]<br>망고는 매년 꾸준히 재배면적이 늘고 있지만 아직 재배 기술이 보편화되지 않아 재배 농가의 망고 재배 성공률은 비교적 낮은 편입니다. 반드시 유지해야 할 재배 조건을 지키지 않을 경우 열매가 열리지 않거나 열매가 열리더라도 품질이 좋지 않아 실질적으로 소득으로 이루어지지 않습니다.<br><br>[망고 병해충 관리 정보, 여러 사이트에 흩어져 있고 개인의 상황에 적용하기 어려움]<br>현재 여러 사이트 및 유튜브, 블로그 등에서 망고 재배 관련 정보를 제공하고 있습니다. 그러나 망고의 질병 진단 및 대처 방법에 대한 정확한 정보를 제공하는 것은 국가농작물병해충관리시스템 뿐이고, 이 마저도 일방적인 정보 제공이기 때문에 재배자 개인의 망고 재배 상황에 맞는 대처 방법을 알기는 어렵습니다.<br><br>[국가농작물병해충관리시스템의 병해충상담, 24시간 소요]<br>국가 농작물병해충관리시스템(NCPMS)에서 농업종사자 개인 재배 상황에 맞추어 농촌진흥청의 분야별 전문가가 병해충 관련 상담을 제공하나, 이는 6단계 [로그인-사진 촬영-상담내용 작성-상담신청 접수-전문가 답변 작성-답변 확인] 로 이루어지며 이는 평균 24시간이 소요됩니다.<br><br>위와 같은 이유로, 망고 질병에 대해 빠르게 알고, 대처 방법에 대한 정보 및 망고 재배 관련 정보를 한꺼번에 신속하게 제공하는 서비스가 필요합니다. |
| (8-2) 과제: 기존연구와의 비교 | 대표적인 해외 식물 직별 식별 앱 서비스인 [Agrio - Plant health app]와의 비교를 진행해보겠습니다. Agrio는 재배자와 작물 조언자가 식물 질병, 해충 및 영양 결핍을 예측, 식별 및 치료할 수 있도록 돕는 정밀 식물 보호 솔루션입니다. 인공 지능과 컴퓨터 비전 알고리즘을 활용하여 농작물 관리 및 식물 질병 식별을 돕는 서비스입니다.<br><br>[Agrio]는 [망하지망고]와 비교했을 때, 더욱 높은 수준의 기술력을 구현함으로써 재배자들의 식물 재배 및 총체적인 관리에 도움을 주고 있습니다. 그러나 구독 서비스가 아닌 무료 버전을 사용하면 질병 식별의 정확도가 낮아지고, 현재 영문 서비스만 제공한다는 점이 한계로 작용합니다. |
| (8-3) 과제: 제안 내용 | 망고 잎의 질병 여부를 파악하기 위해 이미지 객체 인식 및 분류 딥러닝 모델을 사용하였습니다. YOLOv5를 사용하여 망고 잎과 병변부위 이미지 객체를 추출하고, resnet50을 사용하여 해당 잎에 대한 정상/질병 여부와 어떤 질병인지 판단합니다. React Native 프레임워크와 Spring 프레임워크를 활용하여 각각 프런트엔드와 백엔드를 분리하여 모바일 어플의 화면과 서버를 개발합니다. 누구나 다운받아 사용할 수 있는 어플이므로 AWS EC2(Ubuntu 22.04)와 RDS(MySQL)를 사용하여 클라우드 서비스에서 서버를 구축하여 많은 사용자들이 사용할 수 있도록 합니다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 망고 질병 검사를 통한 망고 질병 정보 및 질병에 따른 대처 방법 정보 제공<br>2. 망고 재배 관련 정보(팁)들을 모아서 제공 |
| (8-5) 과제: 구현 방법 | 본 팀의 최종 산출물은 사진을 통한 망고 질병 식별 및 대처법 제공 모바일 애플리케이션 서비스입니다. 어플리케이션 개발은 Android Studio로 진행합니다. 망고잎 사진 데이터셋을 기반으로 작물 질환 진단을 위한 딥러닝 모델 설계는 다음과 같습니다. VGG16를 활용해 정상 잎과 질병이 있는 잎을 구분하고, 질병이 있는 망고 잎 이미지에 대하여 객체 검출 모델인 YOLOv5를 사용하여 바이러스에 감염 또는 질병이 발생한 부분을 검출합니다. 이후 이미지 분류 모델인 VGG16을 사용하여 감염 부분에 대한 특징을 추출하고 질병을 분류합니다. 딥러닝 모델 학습을 위한 데이터셋은 creative commnons의 ‘Mango Leaf Disease Dataset(Ali, Sawkat; Ibrahim, Muhammad ; Ahmed, Sarder Iftekhar ; Nadim, Md. ; Mizanur, Mizanur Rahman; Shejunti, Maria Mehjabin ; Jabid, Taskeed (2022), “MangoLeafBD Dataset”, Mendeley Data, V1, doi:10.17632/hxsnvwty3r.1)’의 8 class, 4000 장의 이미지를 사용합니다. 서버 측 개발은 다음과 같은 기술을 사용하여 진행합니다. AWS로 서버 구축 후 MySQL RDB를 사용하여 데이터를 저장하고 관리합니다. 서버 소프트웨어로 NGINX 웹 서버와 Tomcat WAS를 사용합니다. Java 언어 및 Spring framework를 사용하여 MVC 아키텍처를 구축합니다. Docker를 사용하여 서버 배포 및 관리를 수행합니다.클라이언트 측 개발은 다음과 같은 기술을 사용하여 진행합니다. Java Script 언어 및 HTML, CSS, React Native 프레임워크를 사용하여 동적인 모바일 화면을 구축합니다.|
| (8-6) 과제: 세부 기술 |- [망고 질병 식별 기능] : tensorflow, numpy 등의 라이브러리를 사용하여 YOLOv5와 망고 잎 질병을 식별할 수 있는 Resnet50 모델을 개발합니다. 이후 앱 BE에서 인공지능을 사용할 수 있도록 flask를 사용하여 인공지능 api를 생성하여 spring 프레임워크로 구축한 앱 백엔드에서 연결해 판단 정보를 받아옵니다. <br>- [망고 질병 식별 결과 및 대처 방법과 망고 재배 팁 정보 제공 기능] : MySQL DB와 JPA를 사용하여 백엔드 서버에서 망고 식별 결과 및 대처 방법, 망고 재배 팁 정보를 제공합니다. 백엔드 서버는 Spring Framework를 사용합니다. |
| (8-7) 과제: 기대 효과 및 의의 |고소득 작물인 망고는 재배 기술이 아직 보편화되지 않았기 때문에 재배 성공률이 낮은 편입니다. 이에 따라 초보 재배자는 망고 재배에 있어 큰 어려움을 겪습니다. 재배 중인 망고의 잎에서 문제를 발견했을 때 사진 촬영 및 업로드를 통해 정확한 원인을 신속하게 확인할 수 있고, 적절한 조치 방법을 바로 알 수 있어 망고 작물 손실을 최소화할 수 있습니다. 빠른 질병 식별과 대처법 제공 서비스를 통해 망고 초보 재배자의 재배 성공률은 크게 올라갈 것입니다. 뿐만 아니라 한반도의 기후가 아열대화 됨에 따라, 아열대 과일을 재배하는 농가는 더욱 증가할 것으로 보입니다. 2021년 기준으로 보면 한국에서 가장 많이 재배되고 있는 아열대 과일은 망고로 재배 면적은 76.8헥타르로 집계되었습니다. 망고는 현재 제주도를 비롯해 충남 부여, 전남 영광, 경남 통영·함안 등 전국 200여 곳의 농가에서 폭넓게 재배 중입니다. 이후 저희 서비스 ‘망하지망고’는 망고와 같은 아열대작목으로 그 범위를 확장시킬 수 있을 것임을 기대합니다. 팜인사이트에 따르면, 현재 아열대작목 가운데 망고, 파파야, 용과, 올리브의 재배면적은 최근 3년간 꾸준히 증가하고 있습니다. 이와 같은 아열대작목을 타겟팅하여 서비스를 확장한다면 농가 재배자들에게 충분히 경쟁력있는 서비스로 발전할 수 있을 것입니다. |
| (9) 데모 내용 | [데모 내용] 1. 로그인 화면: <br>- 로그인 과정 <br>2. 홈 화면: - 망고 진단하러 가기 버튼 - 최근 진단 기록 3개 표시 - 오늘의 날씨 제공을 통한 망고 재배 환경 표시 <br>3. 마이페이지 화면: - 회원 정보 확인 <br> 4. 진단 기록 리스트 화면 - 카메라 연동 및 갤러리 사진을 통한 망고 사진 업로드 - 망고 질병 진단 과정 - 망고 질병 증상 및 원인 분석, 대처 방법 정보 제공|
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-12
| (1) 과제명 | 어린이를 위한 비주얼 프로그래밍 기반 코딩 학습 모바일 게임: 메르헨 코더
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 12-팀팀탱탱후라이팬 |
| (3) 팀원 역할 분담 | 김미진(1976046):  리더, 그래픽 소스 제작, 유니티 프론트엔드(게임 시스템)<br>김지우(2026007): 팀원, 유니티 프론트엔드(게임 시스템, 데이터 관리 시스템)<br>이도현(1876263): 팀원, 유니티 프론트엔드(게임 시스템, 데이터 관리 시스템), Node.js 백엔드|
| (4) 팀 지도교수 | 김명 교수님 |
| (5) 팀 멘토 | 이정현 / 주식회사 젬팩 / 대표이사 |
| (6) 과제 키워드(keywords) | 어린이코딩교육, 비주얼프로그래밍, 모바일게임 |
| (7) 과제 내용 요약 | 2022 교육과정 개정으로 공교육에서의 코딩의 중요성이 높아지고, 이에 따라 코딩 사교육 기관도 늘어나면서 높은 사교육비로 인한 교육 격차가 심화되고 있다. 이를 해결하기 위해 초등학생을 타겟으로 스스로 재미있게 코딩을 배울 수 있는 모바일 게임, 메르헨 코더를 제작한다. 메르헨 코더는 동화 세계를 배경으로 하여 문제 상황을 코딩을 통해 해결한다는 독특한 컨셉과 스토리를 가지고 있으며, 유니티와 C# 스크립트를 활용하여 직접 개발한 비주얼 프로그래밍 도구와 이를 활용해 해결할 수 있는 다양한 코딩 문제를 제공한다. 이용자는 메르헨 코더 플레이 경험을 통해 코드의 전체적인 구조를 이해하고 컴퓨팅 사고력 및 문제 해결력을 기를 수 있다. |
| (8-1) 과제: 문제의 정의 | 1. 코딩 교육 플랫폼에 대한 관심 증가 <br>- 교육부는 2022 개정 교육과정 개정에 코딩 교육을 필수화하겠다고 발표했다. <br>- 개정 교육과정에 따르면, 초등학생과 중학생이 한 학기 의무적으로 들어야 하는 정보 수업 시간을 최소 2배 이상 확장한다. <br>이처럼 학교 교실에서의 코딩 교육의 비중이 늘어나자 ‘코딩 사교육’ 또한 급부상했다.<br><br>2. 사교육 비용으로 인한 교육 격차 심화<br>-재능교육이 2023년 9월에 발표한 설문조사 결과에 따르면, 유·초등 학부모의 35%가 자녀가 코딩 사교육을 받고 있거나 받아 본 경험이 있다고 응답했다. <br>- 서울특별시가 발표한 자료에 따르면 코딩 학원의 월 교습비는 최대 60만원이며, 월평균교습비는 29.5만원에 달한다. <br><br>이러한 배경에서 우리 팀은 어린이를 위한 쉽고 재미있는 코딩 학습 서비스의 필요성을 느꼈다. |
| (8-2) 과제: 기존연구와의 비교 | 1. 스크래치<br>- 블록 코딩 방식의 구조적 한계점이 존재한다. 코드가 복잡해질수록 전체 구조를 파악하기 어렵다. <br>- 자체적으로 제공되는 문제가 없으며 창작과 공유에 초점을 맞춘 서비스이다. 따라서 문제 해결력을 기르기에 적합하지 않다. <br>- 튜토리얼이 미비하다. 가이드 동영상을 제공하고 있으나 대부분 영어이며 한글 자막을 지원하지 않기 때문에 학생이 스스로 학습하기 어렵다. <br><br> 2. 로도코도 <br>- 간단한 길찾기 문제의 반복이며 게임에 스토리가 존재하기 않기 때문에 지속적인 학습 흥미 유발이 어렵다.<br>- 서버 저장이 지원되지 않아 사용자의 학습 지속 가능성 및 접근성이 하락할 수 있다. 어플을 재설치했을 때, 진행 상황이 초기화되어 처음부터 문제를 해결해야 한다. 자신만의 모바일 기기를 소유하고 있지 않을 가능성이 높은 어린 학생들의 경우 다른 기기를 사용했을 때 처음부터 다시 플레이하는 것이 부담될 수  있다. |
| (8-3) 과제: 제안 내용 | <메르헨 코더>는 기존 코딩 교육 서비스들과 비교했을 때 다음과 같은 특징 및 개선점을 갖는다.<br><br>1. 새로운 방식의 비주얼 프로그래밍 도구<br>프로그램의 시작부터 끝까지 선으로 연결된 새로운 프로그래밍 도구를 개발하여, 프로그램의 흐름과 논리 구조를 이해하는데 더 도움이 되되록 한다. <br><br>2. 플랫폼 자체 문제 제공<br>점진적인 학습을 도울 수 있도록 난이도가 조정된 문제들을 직접 제공함으로써 이용자의 학습과 문제 해결력을 증진한다.<br><br>3. 친절한 튜토리얼<br>새로운 개념이나 풀이 방식을 배울 때마다 사진 및 그림을 활용하여 친절하게 설명하며, 단순히 설명 뿐만 아니라 사용자가 개념과 노드의 사용법을 충분히 익힐 수 있도록 캐릭터의 지시를 따르며 함께 진행하도록 한다. <br><br>4. 흥미있는 스토리텔링<br>동화 컨셉의 흥미있는 스토리를 제공하여 이용자가 지속적으로 학습할 수 있도록 하고, 코딩을 배우는 과정을 지루하지 않고 재미있게 느끼도록 한다. <br><br>5. 서버 저장 지원<br>사용자가 두 대 이상의 기기를 옮겨가면서 플레이할 수 있도록 서버 저장을 지원하여 지속적인 학습을 가능하게 한다. |
| (8-4) 과제: 과제의 주요 기능 |<br>1. 프로그래밍 학습 도구 '노드' 제공 : 노드는 비주얼 프로그래밍을 기반으로한 프로그래밍 학습 도구로, 유니티의 ‘비주얼 스크립팅'을 차용하여 설계되었다. 기존의 블록 코딩과 달리 명령어간의 연결을 선으로 표현하여 논리적 흐름과 데이터 흐름을 시각화한 인터페이스를 제공한다. 기능에 따라 크게 8가지의 타입(시작/끝, 입력, 액션, 자료형, 변수, 연산, 제어, 함수)으로 분류되며, 총 44개의 종류가 있다. 이를 통해 자료형, 변수, 연산, 조건 등의 프로그래밍 기본 개념을 학습할 수 있다. 노드는 크게 3가지 요소로 구성된다.<br><br>![노드의 구성 요소](https://github.com/MerchenCoder/UnityBuildMerchenCoder/assets/105702023/13b30f29-5267-4fa5-b1bc-750e01349881)<br><br>- 라벨 : 노드의 이름이 표시되는 부분으로 노드의 이동고 삭제 이벤트를 처리한다.<br>- 플로우 포트(Flow Port) : 입/출력으로 구분되며, 플로우 포트 간의 연결을 통해 프로그램의 흐름을 구성할 수 있다. 노드 간의 연결된 플로우를 따라 순차적으로 실행된다.<br>- 데이터 포트(Data Port) : 입/출력으로 구분되며, 데이터 포트 간의 연결을 통해 데이터를 전달한다. 자료형에 따라 포트 색깔이 다르며, 입력과 출력 포트 간에 자료형이 일치하는 경우에만 연결이 가능하다.<br><br>2. 학습하기: 사용자가 프로그래밍을 통해 문제를 해결하면서 학습할 수 있도록 스토리 기반 게임으로 구성되어 있다.<br>- 챕터 선택 : 두 개의 챕터가 제공되며, 챕터 1부터 순차적으로 진행한다.<br>- 스토리 진행 : 챕터를 선택하면 NPC와의 대화를 통해 스토리를 진행한다. <br>- 문제 제공 : 스토리 진행 중 NPC가 특정 문제 상황을 제시하며, 사용에게 해결을 요청한다.(문제는 주로 NPC가 처한 상황을 돕는 형태로 제시된다.)<br>- 튜토리얼 : 새로운 개념을 학습하거나 새로운 노드를 사용해야하는 경우 개념 설명과 튜토리얼이 제공된다. 설명과 지시, 반응 등의 구성을 반복하여 게임 속 캐릭터와 사용자의 상호작용을 통해 개념을 학습할 수 있도록 한다.<br>- 프로그래밍 & 채점 : 제공되는 에디터 창에서 코드를 작성한 후, 실행을 통해 코드의 결과를 시각적으로 확인할 수 있다. 제출시 테스트 케이스를 기반으로 채점을 하여 코드의 정/오답을 판단한다.<br><br>3. 복습하기: 사용자가 푸는 데 어려움을 느꼈던 문제를 복습하고 싶거나, 이미 풀었던 문제를 다른 방식으로 풀어보고 싶을 때 이미 클리어한 문제에 한해서 문제를 다시 풀어볼 수 있는 복습하기 기능을 제공한다. <br><br>4. 가구 상점 : 보상으로 획득한 재화로 가구를 구매하고 적용하여 방을 꾸밀 수 있는 기능을 제공한다.|
| (8-5) 과제: 구현 방법 |![poster_sw_architec_final](https://github.com/MerchenCoder/UnityBuildMerchenCoder/assets/105702023/f8cbb7bd-5aef-40a8-95e9-df8b0fd1e183)<br><br>시스템은 크게 클라이언트, 서버, 그리고 데이터 저장 영역(RDS, S3)으로 구성된다.<br><br>**클라이언트**<br> 1. 게임 시스템 :  사용자가 스토리를 진행하며 프로그래밍을 학습할 수 있도록 세가지 모듈을 설계하였다. 다이얼로그 시스템을 통해 NPC와의 대화를 관리하고, 노드 시스템을 통해 사용자가 비주얼 프로그래밍 도구로 코드를 작성 및 실행할 수 있게 한다. 또한, 채점 시스템을 통해 작성된 코드를 테스트 케이스 기반으로 코드의 채점이 이루어진다.<br>2. 데이터 관리 시스템 : 플레이어의 게임 진행상황을 저장할 뿐만 아니라, 게임 진행에 필요한 데이터를 적절하게 가져오도록 관리하는 시스템이다.<br>3. 사용자 인증 모듈, 네트워크 관리자 : 사용자의 계정을 생성하고 데이터를 서버에 저장하기 위해, 사용자 인증 모듈과 네트워크 관리자를 설계했다. 이 두가지 모듈을 통해 사용자는 계정을 생성하고, 서버에 안전하게 데이터를 저장하고 불러올 수 있다.<br><br>**서버**<br>1. 계정 관리 모듈 : 클라이언트의 회원가입, 로그인, 계정 삭제 요청을 처리한다. 데이터베이스에 적절한 쿼리를 보내 사용자 테이블에 데이터를 삽입, 조회, 삭제한다.<br>2. 사용자 데이터 관리 모듈 : 데이터베이스에 사용자의 게임 데이터를 저장하거나 조회하는 쿼리를 실행하여 사용자의 게임 및 학습 기록을 관리한다.<br>3. 정적 파일 관리 모듈 : IAM 사용자를 통해 부여받은 권한으로 S3 버킷에 접근하여 정적 파일(이미지, 텍스트 파일 등 게임 실행에 필요한 자원)을 읽어오고, 이를 Unity 클라이언트에 전송한다.|
| (8-6) 과제: 세부 기술 |1. 프로그래밍 학습 도구 '노드' 설계 및 구현 : 하나의 노드가 실행되는 과정은 다음과 같다.<br>- 데이터 가져오기 : 데이터 입력 포트에 연결된 데이터를 가져온다.<br>- 고유 작업 수행: 가져온 데이터를 기반으로 노드의 고유 작업을 수행한다. (예 : 연산 노드 - 연산을 수행, 말하기 노드 - 데이터를 출력)<br>- 결과 저장: 데이터 출력 포트를 가진 노드는 작업 결과를 저장하여 다음 노드에서 사용할 수 있도록 한다.<br>- 다음 노드 찾기: 현재 노드의 여러 플로우 출력 포트 중 흐름을 따라갈 포트를 찾고, 다음에 실행할 노드를 결정한다.<br><br>이를 위해 아래와 같이 노드를 설계하여 구현하였다.<br>- DataInPort : 데이터 입력 포트의 연결 상태와 전달되는 데이터를 관리한다.<br>- DataOutPort : 포트 간의 연결과 포트의 드래그 이벤트 처리하며, 데이터 전송을 관리한다.<br>- IFollowFlow : 노드의 흐름을 제어하기 위한 인터페이스로, NextFlow() 메소드는 흐름을 따라갈 플로우 출력 포트(FlowoutPort)를 반환한다.<br>- INode : 노드의 실행 및 데이터 처리를 담당하는 인터페이스로 Execute() 메소드는 노드의 고유한 기능을 수행하며, ProcessData()는 데이터를 처리하고 결과를 저장한다.<br>- 이 외에도 여러 클래스가 존재한다.<br><br>2. 노드 시스템(코드 실행 시스템) : 노드로 작성된 프로그램 코드는 NodeManager에서 관리되며, 다음 순서로 실행된다.<br>- 사용자가 코드를 작성하고 '실행' 버튼을 클릭하면 NodeManager에서 시작 노드를 찾는다.<br>- 시작 노드를 currentNode로 설정해 반복문을 시작한다.<br>- currentNode의 실행 함수(Execute())를 호출하여 노드의 작업을 수행한다.<br>- currentNode의 NextFlow()를 호출하여 흐름을 따라갈 플로우 출력 포트를 찾는다.<br>- 찾은 포트를 통해 연결된 노드를 찾고, 이를 currentNode로 한다.<br>- currentNode가 끝 노드에 도달할 때까지 위 과정을 반복한다.<br><br>3. 채점 시스템 : 프로그램 코드의 실행 결과만으로 문제의 정답 여부를 판단하는 경우 사용자가 문제의 의도대로 코드를 작성했는지 확인하기 어렵다. 예를 들어, 더하기 문제에서 '더하기' 연산을 사용한 코드와 단순히 데이터를 출력하는 코드는 실행 결과가 같지만, 후자는 의도와 다르게 작성된 코드다. 이를 해결하기 위해 ‘코딩 테스트’에 사용되는 테스트 케이스를 통한 채점 방식을 차용하여 채점 시스템을 구현하였다.<br>- 문제에서 주어지는 값 외에도 입력값을 변경했을 때 올바른 결과를 출력하는지를 확인하기 위해 문제마다 테스트 케이스를 생성했다.<br>- 입력 노드를 추가하여 사용자가 테스트 케이스의 입력값을 사용할 수 있도록 했다.<br>- TestManager 시스템은 코드의 실행 결과와 테스트 케이스의 출력 배열을 비교하여 정오답을 판단한다.|
| (8-7) 과제: 기대 효과 및 의의 |**1. 절차적 사고력 & 컴퓨팅 사고력 증진**<br>쉽고 직관적인 노드 프로그래밍을 통한 절차적 사고력 & 컴퓨터 사고력을 증진한다. 실제로 22명의 사용자를 대상으로 <메르헨 코더>의 베타테스트와 설문조사를 진행한 결과, 노드 프로그래밍의 UI가 직관적이어서 만족스럽고, 코딩의 원리를 이해하기 쉬우며 프로그램의 흐름을 정확히 파악할 수 있었다는 응답들이 존재했다. 또한 40%의 사용자가 게임의 수비고 직관적인 프로그래밍 방식이 도움이 된다고 응답했다. <br><br>**2. 학습에 대한 흥미와 참여 유지**<br>재미있는 스토리와 문제 풀이로 프로그래밍 학습에 장기적인 흥미와 참여를 유지한다. 진행했던 설문조사의 주관식 응답 중, "아이가 코딩에 관심을 가지게 되었다", "코딩을 재미있게 배울 수 있는 방법인 것 같다." 등, 재미와 프로그래밍 학습에 대한 흥미의 측면에서 긍정적인 반응을 보였다. <br><br>**3. 텍스트형 프로그래밍 학습으로 긍정적 전이효과**<br>노드를 이용한 프로그래밍 학습이 텍스트형 코딩 언어 학습에 유의미한 도움을 줄 수 있을 것이다. 실제로 <메르헨 코더>를 플레이한 사용자들을 대상으로 학습 내용와 관련된 파이썬 개념을 설명하고 퀴즈를 낸 결과, 응답자의 85%가 60% 이상의 정답을 맞춘 것을 확인할 수 있었다. |
| (9) 데모 내용 |1. 등록된 사용자 계정으로 로그인한다.<br>2. ’학습하기’ 버튼을 누르고 ‘챕터 1 춤추는 마을’을 선택한다.<br>3. 진행 중이던 게임을 이어서 진행한다. NPC와의 대화를 통해 미션을 받는다.<br>4. 미션에서 주어진 문제를 풀기 위해 ‘문제 풀이 씬’으로 이동한다. <br>5. '변수' 및 '값 설정하기', '값 가져오기' 노드에 대해 학습하기 위해 설명서 페이지를 보여주며 설명하는 튜토리얼이 시작된다. <br>6. 캐릭터의 지시에 따라 실제로 노드를 사용해보면서 개념을 익힐 수 있도록 튜토리얼을 진행한다. <br>7. 주어진 노드를 사용하여 올바른 코드를 작성한 후 우측 상단의 ‘실행’ 버튼을 눌러 실행 결과 창을 확인한다.<br>8. ‘제출’ 버튼을 눌러 제출 결과가 성공한 것을 확인하고 보상을 수령한다.<br>9. 메인(홈) 씬으로 돌아가 ‘복습하기’ 버튼을 눌러 현재까지 푼 문제를 다시 풀 수 있는 복습하기 기능을 소개한다. <br>10. '꾸미기 모드'를 활성화하여 보상으로 얻은 재화로 가구 상점에서 가구를 구매하고 적용한다. |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-13
| (1) 과제명 | Agent.I : Generative Agent를 적용한 Human-like NPC와 상호 작용하는  사회 시뮬레이션 게임
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 13-스윗팡이크루 |
| (3) 팀원 역할 분담 | 정다소(2071043) : 팀장, Django Back-end<br>장재원(1976343) : 팀원, Unity Front-end<br>성원희(2176180) : 팀원, Back-end, Chat GPT prompt engineering |
| (4) 팀 지도교수 | 심재형 |
| (5) 팀 멘토 | 김도균 / 넷스트림 / CTO |
| (6) 과제 키워드(keywords) | Generative AI, Human-like NPC, 시뮬레이션 게임 |
| (7) 과제 내용 요약 | Agent.I는 기존의 일방향적인 NPC와의 소통을 뛰어넘어, Generative Agent를 활용하여 Human-like NPC와의 상호작용하는 사회 시뮬레이션 게임입니다. 플레이어는 스스로 사고하고 행동하는 NPC와 상호작용하며 '사이비 종교 확산 방지'라는 목표를 이루어내야 합니다. 이 과정에서 플레이어는 시시각각 달라지는 게임의 흐름을 통해 다양한 게임 플레이 경험과 즐거움을 느낄 수 있습니다. |
| (8-1) 과제: 문제의 정의 | 기존 게임에서 NPC는 유저에게 게임의 진행 방향을 알려주고 유저와의 소통을 통해 게임의 재미를 증진시켜주는 역할을 맡았습니다. 하지만 기존의 NPC는 고정된 선택지와 정해진 대사의 반복으로 인해 일방향적인 소통이 이루어졌고, 이로 인해 유저의 참여도와 세계관의 신뢰도가 감소하는 문제를 가지고 있었습니다. 이러한 문제점을 인식하고, 최근 생성형 AI를 NPC에 적용하는 시도가 증가하고 있습니다. 하지만 연구 결과, 인공지능 NPC 게임은 체험을 풍부하게 만들지만, 대화 기능과 시스템 간의 연결에 미흡하다는 평가를 받고 게임 시스템과 밀접하게 연관되지 않는다는 지적을 받고 있습니다.  |
| (8-2) 과제: 기존연구와의 비교 | 최근 게임 업계에서는 앞서 언급한 문제점들을 인식하고, 해결하기 위해서 AI를 이용한 챗봇을 NPC에 적용하여 유저와 대화할 수 있는 시스템을 도입하는 등 생성형 AI를 NPC에 적용하는 시도가 증가하고 있습니다. 이러한 방식으로 인공지능을 NPC에 도입한 결과, 인공지능을 도입하지 않은 게임들보다 체험을 풍부하게 만들고, 게임의 유연성과 재미를 증진시킨다는 장점이 있습니다. 하지만 현재 생성형 AI를 도입한 게임들은 게임과의 결합에서 해당 기능의 성숙도가 아직 부족하고, 대화 기능과 시스템 간의 연결이 미흡하다는 평가를 받아 사용성 평가에서 낮은 수치를 보인다는 단점을 가지고 있습니다. |
| (8-3) 과제: 제안 내용 | 기존 게임의 획일적인 상호작용에서 벗어나기 위해 NPC에 AI를 적용하여 실제 사람과 상호작용하는 듯한 경험을 제공합니다. Human-Like NPC를 제작하기 위해 연구 논문 [Generative Agents: Interactive Simulacra of Human Behavior]에서 연구한 Generative Agents의 구조를 반영합니다.  Generative Agent는 NPC들이 스스로 직접 생각하고 다음 행동을 결정하여 여러가지 새로운 이벤트를 생성한다는 점에서 정해진 패턴에 따라 움직이던 기존 게임에서의 NPC들과 다른 양상을 보여줍니다. <br><br>Generative Agent들이 게임의 승패를 결정하며 게임 시스템의 핵심을 이룹니다. 시나리오는 '종교 집회'의 목적을 가진 사이비 종교의 ‘주교 NPC’를 유저가 저지하는 내용입니다. 주교는 대화를 통해 집회를 퍼트리고 다른 NPC들은 종교 집회에 올지 안 올지 결정합니다. 유저는 NPC들과 대화하면서 퀴즈를 통해 종교 집회의 참석자 수를 낮출 수 있습니다. |
| (8-4) 과제: 과제의 주요 기능 | [능동적이고 상호 소통 가능한 NPC 제작]<br><br>1. AI 기반의 NPC 행동 결정 시스템 (Generative Agent)<br>    - 페르소나와 메모리 시스템을 가지고 스스로 행동을 결정하는 NPC 제작<br>    - 주변의 다른 NPC를 인지하고, 대화할 수 있음<br>    - 대화 내용을 메모리에 저장하고 새로운 정보를 추론할 수 있음<br>    - 스스로 장소를 이동하거나 이모지로 자신의 행동을 표현할 수 있음<br><br>2. 페르소나 기반의 AI 챗봇<br>    - 페르소나의 정보와 AI 기반으로 유저와 대화하며 예측 불가능한 양방향 소통을 제공함 |
| (8-5) 과제: 구현 방법 | 스스로 행동을 결정하는 NPC는 다음 세가지 과정으로 구성하여 구현됩니다. <br>1. Perceive : 주변의 다른 NPC를 인지하고, 대화할 수 있습니다. 주변의 NPC의 존재를 확인하고, 대화하기 적절한 상대이면 대화를 시도합니다.<br>2. Memory System : 대화 내용을 메모리에 저장하고 새로운 정보를 추론할 수 있습니다. 이를 통해 인간처럼 사고하는 과정을 모방하고 고차원적인 정보를 메모리에 저장할 수 있습니다.  <br>3. Act : 스스로 장소를 이동합니다. 이모지와 텍스트로 자신의 행동을 표현할 수 있습니다.<br>이 과정을 약 20초마다 모든 NPC에서 반복하며 자신만의 메모리 시스템을 만들어갑니다. |
| (8-6) 과제: 세부 기술 | 1. Django / AWS EC2 <br> - Unity 엔진에서 NPC가 생성하는 정보를 받아옵니다.<br> - 게임 NPC들의 페르소나 정보 및 기억을 Chat GPT3.5로 전송하여 GPT Prompt를 생성합니다. <br> - GPT Prompt로 결정된 대화 및 행동을 Unity 엔진으로 전송합니다.<br> - 유저와 NPC의 대화 정보를 실시간으로 전송하고 저장합니다. <br>2. Chat GPT 3.5<br> - Chat GPT 3.5는 서버에서 전송받은 데이터를 통해 대화를 생성합니다.<br> - GPT Prompt를 이용하여 NPC들의 행동을 결정합니다. <br>3. Unity<br> - Django 서버로부터 전달받은 NPC 페르소나 정보 및 기억을 프론트엔드 차원에서 구현합니다.<br> - Unity 엔진을 이용하여 Windows 운영체제를 기반으로 하는 PC게임 빌드 파일을 구성합니다.<br> Unity에서 생성된 정보를 Django 서버로 전달합니다. 이를 NPC의 페르소나를 기반으로 GPT Prompt를 작성하여 Chat GPT 3.5에 전달합니다. Chat GPT는 전달받은 prompt를 기반으로 각 NPC의 대화를 생성하고 행동을 결정합니다. 이렇게 생성된 NPC의 대화와 행동은 Django 서버를 통해 Unity로 전달됩니다. Unity에서는 서버에서 전달받은 데이터를 기반으로 NPC의 대화를 UI로 구현하고, Behavior Tree를 통해 NPC들의 행동을 구현합니다.|
| (8-7) 과제: 기대 효과 및 의의 | 1. 현실감과 예측 불가능한 NPC : 생성형 AI를 기반으로한 스스로 판단하고 상호작용하는 Human-like NPC를 게임에 적용함으로써, 유저에게 현실감 있는 게임 세계를 제공합니다. NPC는 각자의 페르소나에 기반한 행동 패턴을 갖추며, 유저가 상호작용을 시도하면, 정해진 패턴이 아니라 고유한 행동패턴을 기반으로 때에 따라 다르게 반응합니다. 이를 통해 유저들은 획일화된 플레이가 아닌, 생동감 있는 플레이를 할 수 있습니다.<br>2. 게임 플레이의 다양성 : 생성형 AI를 기반으로 하는 NPC가 게임에 도입되면, 유저의 선택과 행동에 따라 게임의 흐름이 변화합니다.이를 통해 유저는 각각의 상황에 따른 게임 플레이 전략을 세워야하고 새로운 문제에 대응해야 합니다. 이로써 유저들의 게임 경험을 더욱 개인화하고 다양한 게임 플레이를 즐길 수 있습니다.<br>3. 생성형 AI의 게임적 활용 : 생성형 AI가 게임에 도입된 사례가 많지 않다는 점에 주목하여 이 프로젝트는 생성형 AI를 게임 환경에 효과적으로 적용하고 최적화하는 기술적인 도전 과제를 이행하고 있습니다. 이에 대한 결과물은 게임 산업에서 생성형 AI 기술을 더욱 확장하는 토대가 될 수 있습니다.|
| (9) 데모 내용 | 1) Agent의 행동을 ChatGPT를 이용하여 생성하고 이모지와 텍스트로 출력<br>2) Agent가 다른 Agent를 인식하여 대화하는 기능<br>3) Agent와 유저가 대화하고 퀴즈를 푸는 기능 <br>4) 최종 결과창 <br> |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-14
| (1) 과제명 | PitchFinder: 사용자 음높이 기반 가요 필터링 서비스 개발
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 14-CoB |
| (3) 팀원 역할 분담 | 이나현(2076292): 팀장, 전반적인 일정 관리, 메인, 마이페이지 뷰 개발<br>김채리(2071018): 데이터 수집 및 서버 API 개발<br>김선영(2071010): 음역대 측정 뷰 및 기능 개발 |
| (4) 팀 지도교수 | 이형준 교수님 |
| (5) 팀 멘토 | 김유리 / SAP / 개발자 |
| (6) 과제 키워드(keywords) | 음역대, FFT, 노래 |
| (7) 과제 내용 요약 | ‘들을’ 노래가 아닌 ‘부를’ 노래를 찾기 위해 개인 음역대를 측정하고 측정된 음정을 기반으로 노래를 필터링 하여 추천하는 서비스 |
| (8-1) 과제: 문제의 정의 | 노래방에 가서 평소 자주 들었던 노래를 불러봤다가 너무 어려웠던 경험,<br>분명 시작 음정이 낮아서 야심차게 불렀는데 갑자기 높아진 음역대에 삑사리가 난 경험, 다들 한번씩 있지 않으셨나요?<br><br>개인의 음역대는 다양하고 이에 따라 잘 '부를 수 있는' 노래는 달라집니다. 우리는 노래방에 가거나 공연 무대에 서기 위해 노래를 고를 때 어떤 노래가 부르기 쉽고 내게 맞을지 오랜 시간을 고민합니다.<br><br>자주 듣는 노래 순위를 보여주는 스트리밍 서비스의 차트와 노래방에서 많이 불린 노래들을 보여주는 인기 차트는 전혀 다르고, 포털 사이트에서는 '노래방 노래 추천 남자' '노래방 노래 추천 20대'와 같은 검색어들이 검색됩니다. 부르기 좋은 노래를 추천받고 싶은 수요는 많지만 듣기 좋은 노래를 추천해주는 기존 서비스들은 이 수요를 충족시키지 못하고 있습니다. |
| (8-2) 과제: 기존연구와의 비교 | **접근성 좋은 객관적인 음역대 측정 기능의 부재**<br>-   개인이 음역대를 측정할 때 영상이나 글로 추상적으로 설명하는 음역대 측정 컨텐츠로 주관적으로 판단하는 방식만 있습니다. <br>-   현재 정교하고 객관적으로 음역대 측정을 하기 위해서는 장비나 전문가가 필요합니다. <br>**선호도 기반의 기존 노래 추천 서비스**<br>-   노래 추천 서비스를 제공하는 기존 음원 플랫폼들은 협업 필터링 알고리즘을 이용하여 이용자로부터 수집한 피드백 데이터와 다른 이용자의 경험을 바탕으로 판단합니다.<br>-   이때 사용하는 데이터들은 전부 이용자들이 '들은' 노래를 기반으로 판단하기 때문에 개인이 듣고 싶은 노래의 선호도에는 잘 맞을 수 있으나, '부르기 편한' 노래를 추천해주는 것과는 거리가 멉니다. <br><br>실제 기존 서비스 사례와 피치파인더 서비스를 비교하겠습니다.<br>![Untitled](https://github.com/K-CoB/pitch-finder-backend/assets/79985974/1c857cfd-93a5-4569-94f7-aca68f57b525)<br>-   멜론과 Spotify 같이 들을 음악을 추천해주는 서비스는 시중에 많이 있습니다. 하지만 이러한 서비스들은 부를 음악, 즉 음역대에 기반한 음악을 추천해주는 것이 아닌 장르나 취향에 기반하여 ‘들을’ 음악을 추천해주기 때문에 피차피인더와 지향점이 다릅니다.<br>-   그렇다면 피치파인더의 핵심인 음역대 측정은 어떨까요? 기존에도 개인의 음정을 측정하려는 시도는 있었습니다. Vocal Pitch Monitor와 TJ 퍼펙트 스코어 같은 서비스는 둘다 음정 측정은 가능하지만, 순간의 음정을 측정하는 것에 그칠 뿐, 그에 따른 음역대를 알려주거나 노래를 추천해주지는 않습니다.<br><br>**결론**: 따라서 음악 추천 과정에서 사용자의 음정을 반영하는 서비스는 기존에 없었습니다. 뿐만 아니라 기존 서비스들은 노래방 기기가 필요하거나, 특정 OS에서만 이용이 가능하는 등 접근성이 떨어지는 한계 또한 존재했습니다. 하지만 저희 피치파인더는 모바일 웹앱 서비스로, OS에 상관없이 서비스에 접근할 수 있습니다.|
| (8-3) 과제: 제안 내용 | 사용자의 음역대를 측정해서 최고 음정, 최저 음정, 정확도가 높았던 음정들을 기반으로 사용자가 쉽게 잘 부를 수 있는 노래를 추천해줍니다.<br><br>1. 개인 음역대 측정<br>사용자가 지정된 노래를 부르거나 지정된 미션을 수행하고 이를 녹음하게 하는 방식의 음역대 측정을 통해 사용자로부터 정확도가 높은 음정, 낮은 음정, 최고 음정, 최저 음정 등 추천에 필요한 데이터를 뽑아냅니다.<br><br>2. 노래 추천<br>음역대가 사용자의 최고음정 ~ 최저음정 사이에 존재하는 노래들만 필터링합니다. 필터링된 노래들 중 노래별로 유저의 정확도가 높은 음정 순서대로 정렬합니다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 사용자가 제공되는 샘플 음원을 부르면 음역대를 측정한다.<br>&emsp; a.  내장된 마이크를 이용하여 음성을 인식한다 <br>&emsp; b.  마이크를 통해 추출한 사용자의 음성을 주파수로 변환한다. <br>&emsp; c.  주파수로 변환된 값을 통해 음정과 옥타브를 계산한다. <br>&emsp; d.  이분탐색 알고리즘을 이용하여 최고음정과 최저음정을 측정한다. <br>2. 음역대에 맞는 노래 1~10순위를 추천해준다.<br>3. 순위에 있는 노래를 클릭하면 해당 노래의 유튜브 링크로 이동한다.<br>4. 고음/저음 연습을 통해 도달할수 있는 음역대의 노래들도 추천 |
| (8-5) 과제: 구현 방법 | <img width="953" alt="Untitled (1)" src="https://github.com/K-CoB/pitch-finder-backend/assets/79985974/39c22ea7-a723-4ee2-9af9-d6ffd1fa2b73"> 전체적인 시스템 구조는 크게 프론트, 백, 데이터 3가지로 나눌 수 있습니다. <br>1.  AudioContext 기기에 내장된 마이크와 연결하여 음성 데이터를 받아옵니다. <br>2.  음역대 측정을 위한 FFT (Fast Fourier Transform) 사용자의 음성 데이터를 주파수 영역으로 변환하여 음정을 측정합니다.<br> 3.  프론트엔드 : 전반적인 플랫폼 구동 및 유저와 상호 작용<br>&emsp;-   Typescript 기반 React SPA 모바일웹 - 일회성(웹), 높은 접근성(모바일)<br>&emsp;-   Recoil - 사용자 음정 데이터를 전역상태로 관리<br>&emsp;-   React-Query, Axios - 서버 API 연결<br>&emsp;-   styled-components or TailwindCSS (미정) - 스타일링<br>4.  백엔드: 클라이언트와 통신<br>&emsp;-   SpringBoot, JPA<br>&emsp;-   MySQL - Spotify API나 Keggle과 같은 음원 데이터를 수집하여 노래 데이터베이스를 구축<br>&emsp;-   음정에 따른 음원 데이터 수집을 위해 beautifulsoup을 기반으로 크롤링하는 프로그램을 직접 개발하였고 spotify api를 사용하여 데이터를 수집|
| (8-6) 과제: 세부 기술 | ![Untitled (2)](https://github.com/K-CoB/pitch-finder-backend/assets/79985974/be1272a3-b071-4b92-9b66-9212e362f558)<br>**기능**<br>1.  사용자의 음성 인식 및 측정 기능 <br>2.  노래 추천 기능<br><br>먼저 음성 인식 및 측정 시스템은 AudioContext API를 이용하여 사용자의 음성을 내장 마이크를 통해 받아들입니다. 그리고 사용자의 음성 데이터를 상관 함수를 통해 주파수로 변환합니다. 그리고 주파수로 변환한 값을 통해 도레미에 해당하는 음계와 옥타브를 계산합니다.<br>음정 측정 과정에서 너무 많은 시간을 소비할 경우 유저의 피로도와 소요 시간이 늘어나게 됩니다. 이를 예방하기 위해 최소한의 시도로 최고음정과 최저음정을 찾을 수 있도록 이분탐색 알고리즘을 이용하였습니다.<br>다음으로 노래 추천 시스템은 음원의 기본 정보와, 음원의 최고, 최저 음정 정보를 포함하고 있는 음원 데이터를 이용합니다. 앞서 추출한 음정 데이터를 바탕으로 음역대에 기반한 노래를 추천해줍니다.|
| (8-7) 과제: 기대 효과 및 의의 |1.  **개인화된 음악 경험**<br>사용자는 더 이상 부를 때 음역대의 불일치로 고민하지 않고 자신의 음역대로 부를 수 있는 노래를 골라 부를 수 있습니다. 노래방이나 공연에서 노래를 부를 때 보다 쾌적한 경험을 얻을 수 있습니다.<br>2.  **다양한 음악 체험**<br>'개인의 음정 기반'이라는 기존에 없던 시스템을 기준으로 음악을 탐색할 기회를 제공하기 때문에 한정적이지 않은 새로운 노래들을 발견할 수 있습니다.사용자의 음악적 호기심을 확장시키고 새로운 장르나 아티스트를 탐험하는 데 도움이 됩니다.<br>3.  **새로운 기준 제시**<br>'듣기 위한' 기준으로 판단하던 기존 노래 추천 시스템에서 벗어나 완전히 새로운 기준을 제시합니다. 당근마켓은 거래 플랫폼이라는 영역에서 온라인 거래가 아닌 직거래라는 새로운 개념을 만들어냈습니다. 피치파인더는 노래 추천 플랫폼이라는 영역에서 선호도나 장르가 아닌 음정이라는 새로운 기준의 패러다임을 제시합니다.<br>4.  **노래방 산업 활성화**<br>추후 노래방 기기와 연동하게 된다면 노래방 기기에서 볼 수 있는 컨텐츠(현재 랜덤 룰렛이나 주사위 돌리기 등의 미니게임 같은 컨텐츠들이 존재)의 일환으로 이용자들에게 보다 즐거운 노래방 경험을 제공합니다. |
| (9) 데모 내용 |**1.  중간 발표** <br>- 사용자 음성 인식<br>- 사용자 음역대 측정: 최고, 최저 음정 추출<br>- 추출한 데이터를 바탕으로 음악 추천 페이지로 이동<br>- 음원데이터 크롤링<br> **2.  졸업 발표**<br>- 사용자 음성 인식<br>- 사용자 음역대 측정: 최고, 최저 음정 추출<br> - 측정된 음역에 맞는 노래 10개 추천<br>- 연습으로 도달할 수 있는 노래 추천<br> <img width="254" alt="Untitled" src="https://github.com/CSE-pebble/Modern-JS-Tutorial-Study/assets/89910703/46794661-b3b6-44e7-a655-4fbed8ad672e"> <img width="256" alt="Untitled (1)" src="https://github.com/CSE-pebble/Modern-JS-Tutorial-Study/assets/89910703/8de22766-22c4-4984-97be-d66244c68bec">|  |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-15
| (1) 과제명 | 다시: 은퇴한 시니어 전문가를 위한 긱 워킹 채용 플랫폼
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 15-감자도리 |
| (3) 팀원 역할 분담 | 최한비(2076429): 리더, UI/UX 디자인, 프론트엔드 및 백엔드 개발<br>권태영(2171004): 팀원, UI/UX 디자인, 프론트엔드 개발, 이력서 텍스트 추출 AI 개발<br>김서현(2176063): 팀원, 백엔드 개발, 서비스 아키텍처 설계 및 배포, 인재풀 추천 AI 알고리즘 개발 |
| (4) 팀 지도교수 | 김명 교수님 |
| (5) 팀 멘토 | 이채은 / 삼성전자 / 사원 |
| (6) 과제 키워드(keywords) | 시니어 전문가, 긱 워킹, 채용  |
| (7) 과제 내용 요약 | '다시'는 고령화되는 사회 속에서 은퇴 후에도 경력을 살려 시니어 전문가로 활약할 수 있도록 기업에게 저렴하고 전문적인 긱 워커를 추천해주는 채용 플랫폼이다. 은퇴 후 본인의 전문성을 충분히 살리지 못하는 시니어와 유동적인 노동 수요를 가진 기업을 연결하는데 초점을 두고 있다. 시니어 친화적 UI, AI 추천 알고리즘을 이용한 빠른 매칭과 저렴한 중개 수수료를 통해 여타 채용 플랫폼과의 차별성을 확보했다. 이외에도 텍스트 인식 AI 및 생성형 AI를 통해 시니어 전문가의 이력서 및 전문가 소개 작성을 돕는다. |
| (8-1) 과제: 문제의 정의 | 은퇴 후에도 경력을 살려 일하고 싶은 시니어가 많지만, 현실적인 이유로 재취업에 어려움을 겪고 다른 일자리로 이직해야 하는 전문가 비율이 높았다. <br><br>기존 시니어 일자리 플랫폼은 저숙련 노동 직업군 위주인데다 시니어가 사용하기에 UI가 복잡하다는 문제가 있었다. 또한 기업 입장에서도 원하는 조건을 일일이 필터링하여 인재를 찾아야 한다는 불편함이 있었다. <br><br>이러한 문제 상황과 더불어 기업의 필요에 맞게 초단기 노동을 제공하는 긱 워커(Gig Worker)의 수가 증가하고 있다는 채용 시장의 변화를 발견했다. 이에 은퇴한 시니어 전문가가 기업의 수요에 맞게 단기로 일할 수 있도록 기업과 시니어를 매칭해주는 시니어 긱 워킹 채용 플랫폼을 고안하게 되었다. |
| (8-2) 과제: 기존연구와의 비교 | <b>[시니어 채용 서비스]</b><br><b>1. 중장년 워크넷</b><br>채용 방식: 공고에 직접 지원<br>장점: 구직, 전직 등을 위한 다양한 서비스를 지원한다.<br>&emsp;&emsp;&ensp;채용 공고 검색, 필터링 기능이 상세하다.<br>단점: 전문성을 살릴 수 있는 분야를 대상으로 한 공고가 적다.<br>&emsp;&emsp;&ensp;- 개발로 검색했을 때 공고는 17건 정도였다. 반면 보건, 의료 분야는 900건이 넘는다.<br>&emsp;&emsp;&ensp;- 따라서 우리 서비스의 타겟층인 경력을 갖춘 중장년은 선택의 폭이 줄어든다.<br><br><b>2. 올워크</b><br>채용 방식: 공고에 직접 지원, 헤드헌팅<br>장점: 채용 공고, 교육, 컨설팅을 지원한다.<br>&emsp;&emsp;&ensp;시니어(40대 이상) 맞춤 공고만 제공한다.<br>&emsp;&emsp;&ensp;헤드헌팅 프로그램을 제공한다.<br>단점: 헤드헌팅의 경우, 헤드헌터가 의뢰인과 미팅을 통해 인재를 파악한 후 제공하는 형식으로 기업에서 원하는 인재를 직접 찾기는 어렵다.<br>&emsp;&emsp;&ensp;7단계의 헤드헌팅 프로세스를 가지며, 시스템이 자동화되어 있지 않아 기업에서 인재를 추천받기까지 시간이 소요된다.<br><br><b>3. 리멤버 헤드헌팅</b><br>채용 방식: 헤드헌팅<br>장점: 400만 이상의 인재를 보유하여 국내 최대 규모의 인재풀을 제공한다.<br>&emsp;&emsp;&ensp;전용 AI 서치 솔루션을 활용하여 추천한다.<br>단점: 리멤버 앱(명함, 이력서 업로드 앱)을 사용하는 모든 회원을 대상으로 이직 오퍼를 보낼 수 있어 등록된 인재풀 인원이 모두 이직을 희망한다고는 볼 수 없다.<br><br><b>4. 링크드인</b><br>채용 방식: 공고에 직접 지원, 인재풀<br>장점: 경력직 고급 인재풀이 형성되어 있다.<br>단점: 각 인재가 희망하는 급여 수준이 공개되어 있지 않다.<br>&emsp;&emsp;&ensp;한국의 전통적인 채용 플랫폼 형식이 아닌 SNS 형태의 웹사이트라 처음 서비스 이용에 장벽이 있다.<br>&emsp;&emsp;&ensp;기업 사용자의 경우 월 158,919원에 30개의 메시지를 보낼 수 있어 상당한 비용이 소요된다.<br>&emsp;&emsp;&ensp;통계 분석 플랫폼 Ranktracker의 'The 62 Best LinkedIn Statistics for 2023'에 따르면, 플랫폼 사용자의 2%만이 55세 이상이다.<br><br><b>[긱 플랫폼]</b><br><b>1. 크몽 엔터프라이즈</b><br>채용 방식: 헤드헌팅<br>장점: 찾는 전문가의 직군/직무, 채용 형태(외주/상주, 원격), 프로젝트 제목을 입력하여 프로젝트를 등록하면 전담 매니저가 프리랜서를 연결해준다.<br>단점: 매니저가 매칭해준 인재들만 조회할 수 있다.<br>&emsp;&emsp;&ensp;계약까지 평균 일주일 정도의 기간이 소요된다.<br><br><b>2. 원티드 긱스</b><br>채용 방식: 프로젝트 지원, 프리랜서 매칭<br>장점: 긱 워커들에게 인공지능을 이용해 적합한 일자리를 매칭한다.<br>&emsp;&emsp;&ensp;매칭 매니저가 기업과 긱 워커의 채용 과정을 일대일로 조율한다.<br>단점: 주 직업군이 개발과 디자인으로 한정되어 있다.<br><br><b>3. 탤런트뱅크</b><br>채용 방식: 공고에 직접 지원, 인재풀<br>장점: 프로젝트 형식으로 채용해 기업의 비용 부담이 적다.<br>&emsp;&emsp;&ensp;전문가는 기업 고객의 프로젝트 의뢰 분야에 따라 인공지능(AI) 매칭으로 맞춤형 프로젝트를 추천받을 수 있다.<br>&emsp;&emsp;&ensp;전문가의 자기소개에 기업 고객의 고민, 프로젝트 내용, 예상 산출물, 프로젝트 기대효과를 적을 수 있게 하여 정형화된 이력서 형식을 개선했다.<br>단점: 프로젝트의 상한 가격에 제한을 두지 않아 전문가들이 수행한 전체 프로젝트의 평균단가는 2022년 3분기 기준 1000만 원까지 상승하여 기업 사용자 입장에서는 가격적 부담이 될 수 있다.<br>&emsp;&emsp;&ensp;2022년 기준 50대, 60대 가입자 비중이 각각 52.5%→42.4%, 27.0%→18.7%로 감소했다.<br><br>‘다시’는 오랜 경력을 갖춘 시니어 전문가 인재풀을 바탕으로 기업에게 인재를 추천하고, 그 과정에서 인재의 정보를 투명하게 공개하는 것이 강점이다. 우리 서비스는 업무 한 줄 소개를 바탕으로 검색 과정을 대폭 간략화 하여 기업이 AI 매칭 알고리즘을 통해 필요에 맞는 전문가를 쉽고 빠르게 소개 받을 수 있도록 했다. 또한 중개수수료 및 인건비를 낮추어 저렴한 가격에 고급 인력에 접근할 수 있다는 이점을 두었다. 추천 받은 전문가의 이력서 및 전문가 소개가 마음에 든 경우 기업이 채용 제안을 보내는 형식으로 서비스를 구성하여, 기업이 구인 공고를 등록하면 전문가가 그에 지원하는 기존의 수동적인 구인구직 방식과 차별점을 두었다. |
| (8-3) 과제: 제안 내용 | 고령화되는 사회 속에서 은퇴 후에도 전문가로 활약할 수 있도록 ‘은퇴한 시니어 전문가를 위한 긱 워킹 채용 플랫폼, 다시’를 해결책으로 제시한다. ‘다시’는 경험과 전문성을 살릴 수 있는 핵심 직업군 7개(경영지원, 영업기획, 마케팅, IT, 엔지니어링, 생산제조, 의료)를 대상으로 서비스하며, 큰 버튼과 굵은 글씨 등 시니어 맞춤형 UI와 더불어 AI를 이용한 쉽고 빠른 인재풀 검색 기능을 제공한다.  |
| (8-4) 과제: 과제의 주요 기능 | **1. 텍스트 인식 AI를 활용한 이력서 작성**<br>시니어 전문가는 이미 잘 다듬어진 이력서를 보유한 경우가 많기 때문에, 귀찮게 모든 항목을 새로 입력할 필요가 없도록 기존에 갖고 있던 이력서 파일을 활용할 수 있게 했다. 시니어가 이력서를 pdf 형태로 업로드하면 CLOVA OCR 및 OpenAI를 활용해 핵심 정보만 추출한 후 자체 제공하는 이력서 양식을 채운다. 이후 희망 근무 분야, 기간, 급여, 업무 형태(상주/원격)등 희망하는 근무 환경에 대한 정보를 추가로 입력할 수 있다. <br><br>**2. 생성형 AI를 활용한 전문가 소개 초안 작성**<br>기업이 조회하는 인재풀에는 이력서와 전문가 소개가 함께 등록된다. 기업의 수요를 잘 파악하고 있는 시니어 전문가가 그에 맞춰 기업에 제공할 수 있는 서비스를 전문가 소개란에 능동적으로 서술하여 기업에 어필할 수 있도록 했다. 또한 소개와 함께 희망 근무 조건을 명확하게 명시하여 기업이 각 전문가의 역량과 그에 따른 비용을 빠르게 비교할 수 있도록 했다. 또한 입력한 이력서 정보를 바탕으로 생성형 AI를 활용하여 트렌디한 자기 어필 소개 문구를 작성해주는 기능도 도입 고려 중이다. 이러한 전문가 정보 구성을 통해 단순 정보 나열로 이루어진 기존의 수동적 이력서를 탈피하고자 했다. <br><br>**3. AI 인재 추천** <br>기업은 "멀티플레이어 전략 보드 게임 개발"과 같이 업무 한 줄 소개를 입력하여 상황에 맞는 인재를 추천 받을 수 있고, 직군/스킬/경력/급여 필터링을 통해 원하는 조건에 맞게 검색할 수 있다. 기업이 입력한 줄글 형태의 업무 한 줄 소개에서 핵심 키워드를 추출하여 적합도가 높은 순서대로 이력서를 노출한다. 기업은 검색 결과 목록에서 각 인재의 키워드 및 평점을 확인한 후 마음에 드는 인재가 있다면 전문가 상세 페이지 열람을 통해 이력서 및 전문가 소개를 확인할 수 있다. 검색 외에도 기업 사용자는 가장 조회수가 높은 순서, 가장 최근에 이력서를 등록한 순서 등으로 인재풀을 정렬한 결과를 확인할 수 있다.<br><br>**4. 채용 제안 및 수수료 정산**<br>마음에 드는 인재를 찾은 경우 기업은 채용 제안을 보낼 수 있다. 기업 사용자가 희망 근무 형태 및 기간, 급여, 업무 소개를 작성하여 제출하면 시니어 사용자가 채용 제안 알림을 받는다. 시니어 사용자는 근무 조건을 확인하고 채용 제안을 수락 또는 거절할 수 있다. 제안을 수락한 경우 제안 월급의 10%에 해당하는 중개 수수료를 기업 사용자가 결제한다. 결제를 마치면 기업 사용자는 시니어 사용자의 전화번호 및 이메일 주소 등 연락처를 열람할 수 있다. <br><br>**5. 리뷰 작성**<br>시니어와 기업의 계약 기간이 지난 경우 기업 사용자는 시니어 사용자에 대해 리뷰를 작성할 수 있다. 채용 제안 관리 페이지에서 ‘완료된 계약’으로 필터링하면 리뷰 작성 버튼이 노출되고, 기업 사용자는 각 계약 건에 대한 평점, 해시태그 및 후기 줄글을 작성할 수 있다. 제출된 리뷰는 시니어 전문가 상세 페이지 및 인재풀 페이지에 노출된다. 5점 만점으로 된 평점이 먼저 노출되고, 평점이 적혀 있는 버튼을 누른 경우 어떤 기업이 해당 사용자에 대해 무슨 코멘트를 남겼는지 상세 리뷰를 확인할 수 있는 리뷰 페이지로 전환된다. |
| (8-5) 과제: 구현 방법 | ![image](https://github.com/hanby-choi/hanby-choi/assets/76518934/14c26bb7-7d7a-421a-9c1b-24c4883d9ae6) **1. React & Django를 이용한 웹 서비스 구축**<br>시니어 및 기업 사용자의 서비스에 대한 접근성을 높일 수 있도록 반응형 웹 페이지를 개발했다. 프론트엔드는 React, TypeScript, SCSS를 이용했고 백엔드는 Django, MySQL, AWS를 통해 구현했다. 시니어가 무리 없이 서비스를 사용할 수 있도록 크고 굵직한 UI로 구성하였고, 어디서든 사용할 수 있도록 모바일 및 PC 웹 뷰를 모두 제공한다.<br><br> **2. 텍스트 인식 AI를 활용한 이력서 작성** <br>시니어 회원이 PDF 형식의 이력서 파일을 업로드하면, 학력과 경력사항 정보를 추출하여 필수 필드를 자동으로 작성할 수 있다. 이를 위해 Naver CLOVA OCR 기술을 활용하여 텍스트를 추출하고, 개인정보 마스킹 후 Open AI를 이용하여 JSON 형식으로 포맷팅하여 반환한다.<br><br>**3. 생성형 AI를 활용한 전문가 소개 초안 작성**<br>‘다시’는 인재풀에 등록되는 이력서와 함께 전문가 소개도 제공한다. 시니어 전문가는 마크다운 에디터를 이용해 기업의 요구사항에 맞추어 자신이 강점을 가진 역량에 대해 능동적으로 서술한다. 더 쉽고 빠르게 전문가 소개를 완성할 수 있도록 생성형 AI로 초안 작성을 도와주는 기능을 제공한다. 이력서 정보를 바탕으로 Open AI를 활용하여 트렌디한 소개 문구를 작성할 수 있다.<br><br>**4. AI 인재 추천**<br>기업이 입력한 줄글 형태의 업무 한 줄 소개에서 핵심 키워드를 추출하여 적합도가 높은 순서대로 이력서를 노출하는 기능이다. KoNLPy를 이용하여 핵심 키워드를 추출하고, scikit-learn을 이용하여 업무 소개 검색어와 NCS 직업역량 키워드 간의 유사도를 계산한다. 또한, 기업이 요구한 스킬, 경력, 급여에 따른 점수를 합산해서 검색 결과를 반환한다. |
| (8-6) 과제: 세부 기술 |**1. 텍스트 추출 AI**<br>텍스트 추출 AI는 기존 이력서 파일에서 학력 및 경력 정보를 추출하기 위해 OCR 기술과 JSON 형식으로 포맷팅하는 기술이 필요하다. OCR 기술은 한글 인식에서 높은 정확도를 보여준 네이버 클라우드 플랫폼의  CLOVA OCR을 선택했다. CLOVA OCR은 문서 처리에 용이한 가로 문자 인식을 제공하며, 인식 대상의 레이아웃을 분석하고 글자를 읽는 순서와 방향을 추정하여 문자를 인식한다. 프론트엔드와 백엔드 간 REST API 통신을 위해 OCR 추출 결과를 JSON 형식으로 가공하고자 했다. OCR 기술로 추출한 정보를 처리하기 위해 OpenAI의 gpt-3.5-turbo-instruct 모델을 사용했다. 이 모델은 작업 지향적이며 추가 프롬프트 없이도 지시를 이해하고 처리하여 응답할 수 있기 때문에 선택했다. 이러한 터보 모델을 통해 포맷팅 작업을 빠르고 정확하게 수행할 수 있도록 했다. 또한, 적절한 정보를 추출하도록 텍스트의 y축 오차 범위를 지정하여 동일한 문단으로 판정하도록 했다. 그리고 OpenAI를 활용하는 과정에서 개인정보 누수가 발생하지 않도록 데이터 포맷팅 전에 이름, 주소, 전화번호 및 메일 주소 등 개인정보를 마스킹하는 코드를 추가하여 검증 과정을 거쳤다.<br><br>**2. 인재 추천 AI**<br>인재 추천 시스템에서는 기업 사용자의 업무 한 줄 소개 검색어와 시니어 전문가의 이력서 간의 유사도를 측정하는 기술이 필요하다. ‘만들다’, ‘만들고’, ‘만드는’ 등 같은 단어가 다르게 활용되더라도 하나의 의미로 인식하도록 띄어쓰기 기준으로 단순 키워드를 추출하지 않고 명사 형태로만 키워드를 추출하고자 KoNLPy의 형태소 분석기 중 Hannanum 명사 추출기를 활용했다. 또한, 기업 사용자가 간단한 검색어를 입력해도 원하는 인재를 효과적으로 찾을 수 있도록 scikit-learn의 TF-IDF 벡터화를 이용하여 모든 이력서에서 공통적으로 나타나는 단어에 대해서는 패널티를 부여하고, 희귀하게 나타나는 단어에 대해 높은 점수를 부여했다. 직무와 직접적인 관련이 없는 ‘능력’, ‘경험’과 같은 일반적인 단어들을 stop word로 설정하여 유사도 계산에서 제외했다. 유사도 점수 계산 후에는 기업 사용자가 공고에 요구하는 스킬셋, 경력 범위, 급여 범위 조건을 설정할 수 있도록 하여 각각 반영비를 고려하여 최종 점수를 산출했다.|
| (8-7) 과제: 기대 효과 및 의의 |**1. 시니어 전문가의 사회 재진출 및 재취업 영역 확장**<br>기존 시니어 대상 채용 플랫폼은 저숙련 노동 직업군 위주로 일자리를 알선하여 직업군과 근무 형태가 제한적이라는 한계가 있었다. ‘다시’를 통해 시니어 전문가는 단기 프로젝트에 참여하여 경력을 유지할 수 있게 된다. 이를 통해 시니어들은 보유한 지식을 활용하여 다양한 직업군에서 활약할 수 있으며, 직업적 성취를 이루어 자기 효능감을 높일 수 있다.<br><br>**2. 기업을 위한 개방적이고 저렴한 전문가 영입 플랫폼 구축**<br>‘다시’의 업무 한 줄 소개 기반 AI 매칭은 기업이 필요로 하는 인재를 빠르고 효율적으로 발굴할 수 있도록 한다. 이를 통해 기존의 폐쇄적이고 고비용의 전문가 영입 방식을 보완하여 개방적이고 비용 효율적인 플랫폼을 제공한다.   기업은 합리적인 가격에 경험이 풍부한 시니어 전문가를 영입하여 프로젝트에 바로 투입할 수 있는 인재를 얻을 수 있다.<br><br>**3. 시니어와 기업 간 선순환 형성**<br>시니어는 은퇴 후에도 ‘다시’를 통해 자신의 기술과 지식을 바탕으로 단기 프로젝트에 참여함으로써 활약할 수 있다. 동시에 기업은 노련한 전문가를 쉽고 빠르게 섭외하여 프로젝트에 필요한 인재를 확보할 수 있다. 이를 통해 시니어와 기업 간의 선순환 관계가 형성되는 것을 목표로 하고 있다.<br><br>**4. 정부 사업 연계**<br>서비스가 확장되면 보건복지부 시니어인턴십 사업, 고용노동부 신중년 경력형 일자리 사업 등 정부사업에 참여하는 기업과 시니어 전문가를 매칭하는 업무를 수행할 수 있다.|
| (9) 데모 내용 |1. 로그인: 시니어 사용자가 [다시: 은퇴한 시니어 전문가를 위한 긱 워킹 채용 플랫폼](https://dasi-expert.com)에 정보를 입력하여 로그인한다.<br>2. 이력서 자동완성: 기존 이력서 파일을 업로드하여 학력과 경력사항 정보를 자동으로 작성한다.<br>3. 이력서 작성: 직군 및 직무, 총 경력, 보유 스킬 및 자격증 등 필수 정보를 입력하여 이력서를 작성한다.<br>4. 전문가 소개 작성 및 인재풀 등록: 전문가 소개 탭으로 이동해 키워드와 전문가 소개를 작성하고, 인재풀 등록 버튼을 클릭해 인재풀에 이력서를 등록한다.<br>5. AI 인재 추천: 인재풀 조회에서 업무 한 줄 소개를 검색하여 추천 결과를 확인한다. 근무 형태, 직군 및 직무, 보유 스킬 및 자격증, 총 경력, 근무 기간, 급여로 필터링할 수 있다.|
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-16
| (1) 과제명 | 주변 소리를 인식하여 상황별 알람을 받을 수 있는 서비스: 쫑긋 
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 16-깡총 |
| (3) 팀원 역할 분담 | 박현정 |
| (4) 팀 지도교수 | 이민수 |
| (5) 팀 멘토 | ... |
| (6) 과제 키워드(keywords) | ... |
| (7) 과제 내용 요약 | ... |
| (8-1) 과제: 문제의 정의 | ... |
| (8-2) 과제: 기존연구와의 비교 | ... |
| (8-3) 과제: 제안 내용 | ... |
| (8-4) 과제: 과제의 주요 기능 | ... |
| (8-5) 과제: 구현 방법 | ... |
| (8-6) 과제: 세부 기술 | ... |
| (8-7) 과제: 기대 효과 및 의의 | ... |
| (9) 데모 내용 | ... |
| (10) 기타 | ... |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-17
| (1) 과제명 | AI를 활용하여 맞춤형 건강 조언을 제공하는 과민대장증후군 관리 어플리케이션, BellyWelly
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 17-출발드림팀 |
| (3) 팀원 역할 분담 | 송채원(2076216): 팀장, 딥러닝 YOLOv8, FastAPI, PyTorch, Python<br>안채연(2076232): 팀원, 프론트엔드 <Progressive Web App> TypeScript, React.JS<br>김예지(2176082): 팀원, 백엔드 Java, Springboot, MySQL, AWS Ubuntu, Docker |
| (4) 팀 지도교수 | 오세은 |
| (5) 팀 멘토 | 정좌연 / LG CNS / 책임(PM) |
| (6) 과제 키워드(keywords) | 과민대장증후군, 헬스케어, 습관 개선  |
| (7) 과제 내용 요약 | BellyWelly는 과민대장증후군으로 고통받는 사람들의 평소 습관 개선을 돕는 모바일 서비스이다. AI 객체 인식을 통해 사용자의 식단을 분석하고 자동 기록하며, 사용자가 섭취한 음식과 영양소를 기반으로 포드맵을 분석한다. 또한 프롬프트 엔지니어링을 활용하여 배변 및 스트레스 기록을 기반으로 한 사용자별 건강 상태를 요약하고 맞춤형 건강 관련 조언을 제공한다. |
| (8-1) 과제: 문제의 정의 | 현대 사회에 불규칙적인 생활 패턴과 스트레스로 인해 장 건강에 큰 영향을 받는 사람들이 점차 증가하고 있다. 국내에서 연간 약 150만명의 과민대장증후군 환자가 발생했고, 이들은 일상 생활에 큰 불편을 겪고 있다. 대부분의 사람들은 자신의 장 건강 상태를 정확하게 알지 못하며, 자신에게 맞는 건강한 식습관과 생활 패턴을 구축하는 것에 어려움을 느끼고 있다. 하지만 이들의 문제를 해결할 수 있는 사용성 좋은 어플리케이션은 현재 부재하다. 따라서, 사용자 개개인의 식습관, 배변 상태, 스트레스 지수 등을 효과적으로 기록하고 분석하여, 개인별 맞춤형 건강 관리 방안을 제공할 수 있는 서비스의 필요성이 점점 커지고 있기에, 과민대장증후군 개선을 위한 헬스케어 서비스를 제안한다.<br><br>이 서비스는 다음과 같은 대상 고객에게 특히 유용할 것이다:<br>1. 과민대장증후군(IBS) 환자: 진단을 받은 후 적절한 식단과 생활 습관을 찾기 위해 어려움을 겪고 있는 환자들.<br>2. 소화기 건강에 관심이 많은 일반인: 장 건강을 개선하고 유지하려는 사람들.<br>3. 건강한 생활 습관을 구축하고자 하는 사람들: 자신의 건강 상태를 모니터링하고 개선하기 위해 체계적인 관리가 필요한 사람들.<br><br>이를 통해, 우리의 서비스는 장 건강 관리에 어려움을 겪고 있는 다양한 사용자들에게 맞춤형 솔루션을 제공함으로써, 그들의 건강한 삶을 지원하는 것을 목표로 한다. |
| (8-2) 과제: 기존연구와의 비교 | 1. 관련 임상 연구<br>과민대장증후군 환자들에게 특정 음식이나 영양소가 어떠한 영향을 미치는지에 대한 연구로, FODMAP 제한식이 과민대장증후군의 증상을 완화하는지에 대한 연구<br>- 과민성장증후군 치료에서 저포드맵식이의 역할은? (박경식(Kyung Sik Park), 대한소화기학회지,<br>https://kiss-kstudy-com-ssl.access.ewha.ac.kr/Detail/Ar?key=3573105 )<br>→ 영양사의 식이 조언을 동반한 LFD 섭취를 통해 IBS(과민성장증후군) 환자에서 위장 관련 증상들을 상당히 개선시킬 수 있음과 이와 함께 다균종 생균제를 같이 투약함으로써 증상 개선에 도움이 되는 Bifidobacterium 종의 분포를 증가시킬 수 있음을 제시함<br><br>2. 서비스 및 시스템 조사결과 및 한계점<br>(1) 과장님케어 - 건강한 장건강 관리 서비스<br>[기능]<br>- 장관리를 전문으로 하는 앱으로 증상과 식단, 배변, 복약기록을 통해 일주일 단위로 레포트를 받아보고 전문 영양사에게 1:1 질문을 할 수 있는 앱<br>- 커뮤니티 기능을 토대로 장에 관한 고민이 있는 사람들이 모여 함께 질문도 올리고 답변도 받을 수 있음.<br>[한계점]<br>- 식단 입력 시에 한정된 종류의 음식 리스트 중에서 입력해야하므로 불편함<br>- 음식 리스트가 스크롤을 계속 내려야 하는 드랍다운 형식으로 되어있어 사용성 면에서도 불편함<br>- 앱 사용 중 로딩이 오래 걸리는 일이 매우 잦음<br>- 커뮤니티 기능에서 전문 영양사와 1:1 식단 상담이 가능하지만 단순한 질답 형식에 불과하여 사용장 대한 지속적인 관리가 이루어지지 않음<br><br>(2) 피비오 - 식이기록, 배변기록, 건강관리, 헬스케어<br>[기능]<br>- 스스로 장내 미생물 생태계인 마이크로바이옴을 모니터링 하면서 건강하게 관리할 수 있도록 돕는 마이크로바이옴 헬스케어 솔루션<br>- 식이 기록을 통한 마이크로바이옴 관리<br>- 배변로깅을 통한 장내 마이크로바이옴 모니터링 및 솔루션 제공<br>- 포드맵 검색<br>[한계점]<br>- 배변 상태 기록 시, 삭제는 가능하지만 수정이 불가능하고 세부 기록을 할 수 없음<br>- 음식 섭취전 먹을 재료에 대한 포드맵을 직접 검색해야하는 수고로움이 있음<br><br><관련 용어 및 자료><br>1. FODMAP<br>포드맵(FODMAP)이란, 식이 탄수화물의 일종으로, 장에서 잘 흡수되지 않고 남아서 발효되는 올리고당, 이당류, 단당류, 폴리올을 말한다.<br>http://www.samsunghospital.com/home/healthInfo/content/contenView.do?CONT_SRC_ID=32421&CONT_SRC=HOMEPAGE&CONT_ID=4188&CONT_CLS_CD=001021003005<br>→ 사용자가 섭취한 음식에서 과당(단당류), 유당(이당류), 자당(이당류), 맥아당(이당류)의 함유량 분석<br><br>2. 브리스톨 대변 척도(Bristol Stool Scale)<br>The Bristol stool scale is a diagnostic medical tool designed to classify the form of human feces into seven categories. It is used in both clinical and experimental fields. It was developed at the Bristol Royal Infirmary as a clinical assessment tool in 1997, and is widely used as a research tool to evaluate the effectiveness of treatments for various diseases of the bowel, as well as a clinical communication aid; including being part of the diagnostic triad for irritable bowel syndrome.<br> (브리스톨 대변 척도는 인간의 대변 형태를 일곱 가지로 분류하기 위해 고안된 진단 의료 도구로, 임상 및 실험 분야에서 모두 사용된다. 1997년 브리스톨 왕립의학원에서 임상평가 도구로 개발되었으며, 과민대장증후군 진단에 포함되는 등 다양한 장 질환에 대한 치료 효과를 평가하는 연구 도구로 널리 사용되고 있다.)<br>https://en.wikipedia.org/wiki/Bristol_stool_scale<br>→ 배변 기록의 점수를 산출하는 데 사용 |
| (8-3) 과제: 제안 내용 | 1. AI를 이용한 식단 기록<br>- 사용자가 먹은 음식 사진을 업로드<br>- AI 기술로 음식 자동 인식<br>- 사용자가 섭취한 음식의 저포드맵/고보프맵 정보와 영양소를 분석<br><br>2. 사용자 분석 레포트 제공<br>(1) 식단 분석<br>- 사용자가 기록한 식단을 토대로 주요 영양소 섭취량 및 권장량 비교<br>- 사용자가 섭취한 음식 중 장에 가장 좋은/좋지 않음 5가지 음식 정보 제공<br>- 사용자에게 영양소 및 건강 관련 조언 제공<br><br>(2) 배변활동 분석<br>- 사용자가 배변 빈도, 상태, 색상 등의 정보 입력<br>- 배변 패턴 분석 및 추정 지표 제공<br>- 배변 패턴과 장 건강 간의 연관성 분석 후 GPT API를 활용하여 개선점 제공<br><br>(3) 스트레스 분석<br>- 사용자의 일일 스트레스 정도 입력<br>- 기간별 스트레스 정도 그래프<br>- 스트레스와 장 건강 간의 연관성 분석 후 GPT API를 활용하여 개선점 제공<br><br>3. GPT API를 활용한 AI 영양사<br>- 사용자가 기록했던 식단을 보완해줄 수 있는 식단 추천 기능<br>- 사용자가 입력한 두 가지 음식 중에서 장건강에 더 괜찮은 영향을 미치는 음식을 골라주는 기능 |
| (8-4) 과제: 과제의 주요 기능 | 1. 식단 인식 및 포드맵 분석<br>- 사용자가 먹은 음식 사진을 업로드<br>- AI 기술로 음식 자동 인식<br>- 사용자가 섭취한 음식의 저포드맵/고포드맵 정보와 영양소 분석<br><br>2. 배변 활동 기록<br>- 사용자의 배변 활동을 일기처럼 기록 (빈도, 형태, 색상, 긴박감, 소요시간)<br><br>3. 스트레스 정도 기록<br>- 1일 1회 사용자의 스트레스 단계 입력<br><br>4. 주간 분석 레포트<br>(1) 식단 분석<br>- 일주일치 식단의 포드맵 및 영양소 분석<br>- 사용자가 섭취한 음식 중 장에 좋은/좋지 않은 5가지 음식 정보 제공<br>(2) 배변활동 및 스트레스 분석<br>- 주간 기록 결과를 시각적으로 표현한 분석 그래프 제공<br>- 프롬프트 엔지니어링을 활용하여 주간 상태 요약 및 피드백 제공<br>(3) 총평<br>- 프롬프트 엔지니어링을 활용하여 총평 및 피드백 제공<br><br>5. AI 챗봇<br>(1) 식단 추천<br>- 사용자 기록을 기반으로 부족한 부분을 보완해줄 수 있는 식단 추천<br>(2) 음식 선택<br>- 사용자가 입력하는 2가지 음식 중 가장 장 건강에 도움이 되는 음식 선택<br> |
| (8-5) 과제: 구현 방법 | 1. 프론트엔드<br>- 카카오 sdk를 이용하여 사용자 카카오 계정으로 서비스 로그인<br>- html input 태그를 이용하여 이미지 file 업로드<br>- 서버에 presigned url 요청 후 받은 url로 접근하여 s3에 이미지 업로드<br>- s3에서 응답받은 이미지 url로 내부 서버 및 fast api 요청<br>- 이미지 업로드 api 호출하여 서버에 raw 이미지 파일 전송<br>- api 응답으로 받은 이미지 url을 이용하여 식단 인식 fast api 호출<br>- 응답으로 받은 식단 인식 결과 노출<br>- react-datepicker 라이브러리를 이용하여 달력 기능 구현<br>- Chart.js 라이브러리를 이용하여 도넛 그래프 및 꺾은선 그래프 구현<br><br>2. 백엔드<br>- AWS SDK for Java 2를 이용하여 S3 presigned url 발급<br>- Spring Cloud AWS S3를 이용하여 S3에 이미지 업로드<br>- Spring Cloud Open Feign Client를 이용하여 kakao API 호출하여 카카오 로그인 구현<br>- Spring Security, JWT 토큰을 이용한 권한 설정<br>- 프롬프트 엔지니어링 및 Open AI API를 이용하여 레포트 생성<br>- AI 서버의 API 호출하여 레포트 생성 및 식단 추천 API 개발<br>- AWS EC2, Nginx를 이용하여 웹서버 구축<br>- AWS RDS, MySQL을 이용한 데이터베이스 구축<br>- Github Actions, Docker를 이용한 CI/CD 구축<br>- Certbot을 이용하여 SSL 인증서 발급 후 HTTPS 연결<br>- Springdoc OpenAPI를 이용한 API 명세서 생성<br><br>3. 딥러닝<br>- 음식 이미지 및 해당 음식의 재료와 영양소 정보를 포함하는 대규모 데이터셋 수집 후 Roboflow를 활용하여 데이터셋을 구성하고 관리<br>- 데이터 수집 후, YOLOv8 학습을 위한 데이터 형식 이미지와 레이블링된 바운딩 박스 정보에 맞게 전처리<br>- YOLOv8를 사용하여 음식을 인식하는 모델 학습.<br>- FastAPI를 사용하여 사용자가 이미지를 업로드할 수 있는 API 엔드포인트 생성.<br>- 업로드된 이미지를 YOLOv8 모델에 전달하여 음식 인식 수행.<br>- 재료 및 영양소 정보와 함께 분석 결과를 사용자에게 반환.<br>- GPT-4o API 연동 및 프롬프트 엔지니어링, 데이터 가공 및 모델 튜닝<br>- CoT전략과 LangChain 기술을 활용한 주요 함수 정의 및 프롬프트 최적화<br>- GPT API를 FastAPI로 서빙 후 엔드포인트 구현 및 JSON 요청 바디 파싱 |
| (8-6) 과제: 세부 기술 | 1. 식단 기록<br>(1) 이미지 입력 및 업로드<br>- 사용자는 클라이언트를 통해 식단 관련 이미지를 업로드<br>- 클라이언트는 서버에 raw 이미지 파일 전송하여 s3에 이미지 업로드<br>- 서버에서 응답으로 받은 이미지 url을 이용하여 식단 인식 fast api 호출<br><br>(2) 이미지 처리 및 분석<br>- AI 모델은 전달받은 URL을 통해 이미지를 다운로드하고 파일 시스템에 저장<br>- 저장된 이미지는 YOLOv8 모델을 통해 객체 탐지가 수행되며 음식 항목들이 탐지<br>- 탐지된 음식에 대한 라벨 정보가 리스트 형태로 저장되어 JSON 형식으로 클라이언트에 반환<br><br>(3) 사용자 수정 및 최종 결과 저장<br>- 반환된 리스트가 사용자에게 제공되며 잘못된 라벨이 있는 경우 수정할 수 있음<br>- 수정된 최종 결과는 클라이언트에 의해 저장<br><br>(4) 영양 성분 및 포드맵 결과 제공<br>- 서버는 저장된 최종 음식 결과를 바탕으로 장건강과 관련된 영양성분 및 포드맵 정보를 분석하여 클라이언트에 반환하여 사용자에게 제공<br><br>2. 주차별 사용자 분석 레포트 제공<br>(1) 사용자 데이터 수집 및 정리<br>- 사용자는 식단, 배변 활동, 스트레스 수준 등의 정보를 주차별로 기록<br>- 식단 정보에서 중요 영양성분, 포드맵 정보, 배변 활동과 스트레스 수준은 기록된 빈도와 지수로 데이터를 구조화하여 정리<br><br>(2) 프롬프트 엔지니어링을 통한 분석 프롬프트 구성<br>- 분석할 내용(장건강과 관련한 영양소, 배변, 스트레스 수준)에 따른 구체적인 분석 목표 설계<br>- 사용자의 건강 관련 데이터를 DB에서 추출하여 설정된 분석 목표에 따라 구체적인 질문이나 분석 요청을 프롬프트 형태로 작성<br><br>(3) GPT API를 통한 분석 및 레포트 생성<br>- 앞서 작성된 프롬프트를 GPT API에 전달하고, GPT는 사용자 데이터를 분석하여 결과를 생성<br>- 생성된 레포트는 사용자에게 제공되며, 사용자는 이를 통해 자신의 건강 관련 목표 달성 상태를 확인하고 필요한 개선 조치를 취할 수 있음<br><br>3. AI 챗봇<br>(1) 사용자 데이터 연동<br>- 사용자가 이전에 기록한 식단 정보를 저장한 DB를 연동하고, 주차별 식단 정보를 조회<br><br>(2) 프롬프트 엔지니어링을 통한 프롬프트 구성<br>- DB에서 조회한 사용자의 식단 정보와 입력을 바탕으로 GPT API에 전달할 프롬프트를 구성<br>- 구성된 프롬프트를 GPT API에 전달하고 분석 결과를 요청<br>- GPT로부터 반환된 결과를 분석하여 사용자에게 적합한 식단과 장 건강에 좋은 음식 정보를 도출하여 사용자에게 제공 |
| (8-7) 과제: 기대 효과 및 의의 | 1. 개인화된 건강 관리: 사용자는 AI 기반 식단 분석을 통해 개인 영양소 과부족을 파악하고, 개선 조언을 받아 더 균형있는 식습관을 형성할 수 있다.<br>2. 개인별 유익/유해 음식 파악: 개인별 맞춤 식단 분석으로 균형있는 식습관을 형성할 수 있다.<br>3. 건강 데이터 모니터링: 사용자는 배변 활동과 스트레스 수준을 기록하고 분석하여 자신의 건강 상태를 식별함으로써 장 건강을 더 잘 이해하고 증상의 변화를 주시할 수 있다.<br>4. 개선된 장 건강: 사용자들은 개인화된 식단 조언을 통해 증상을 관리하고, 과민대장증후군 개선에 맞는 올바른 식사 습관을 통해 장 건강을 개선할 수 있다.<br>5. 간편한 기록으로 사용성 향상: 기록 과정을 단축하여 사용자의 꾸준한 기록을 유도한다.|
| (9) 데모 내용 |HDMI 케이블을 이용하여 맥북을 강의실 모니터에 연결하고, iPhone 화면을 맥북에 미러링한 후, iPhone 상에서 어플리케이션을 실행하여 시연<br><br>[시연 순서]<br>- 카카오 로그인- 메인화면- 식단 기록- 배변 기록- 스트레스 기록- 분석 레포트- AI 챗봇 - 마이페이지 |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-18
| (1) 과제명 | Prompirit: Automatic Prompt Engineering Assistance to Improve AI-Generative Art Using User Emotion
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 18-뽀로로에디 |
| (3) 팀원 역할 분담 | 김한나(2071019) 팀장, Text Emotion Recognition, Emotion label append & prepend, LMER model 피팅 통계 분석, 논문 작성<br>방선유(2076181) 팀원, Style keyword append, 설문지 제작, ANOVA 및 Pearson 통계 분석, 논문 작성<br>이현 (2070064) 팀원, Text tokenization & Keyphrase extraction, Style keyword append, 평균 및 정규화 통계, 논문 작성 |
| (4) 팀 지도교수 | 오유란 교수님 |
| (5) 팀 멘토 | 김민주 / 서강대학교 인공지능학과 대학원 / 석사과정  |
| (6) 과제 키워드(keywords) | Prompt Engineering, Text-to-Image Generative AI, Emotional and art technology |
| (7) 과제 내용 요약 | 사용자의 감정을 ﻿핵심 요소로 고려하여 AI 생성 이미지를 개선하는 프롬프트 엔지니어링 Prompirit 제안 및 효과성 평가 |
| (8-1) 과제: 문제의 정의 | - 프롬프트 엔지니어링이 필요하다: 많은 사람들이 생성형 AI를 이용할 때 원하는 결과물이 나오지 않아 여러 차례 프롬프트 입력을 되풀이한다. 이 과정에서 도움을 줄 수 있는 것이 바로 프롬프트 엔지니어링이다. 챗지피티, 달리, 스테이블 디퓨전 등 텍스트 프롬프트를 이용한 생성형 AI의 등장은 많은 파장을 불러일으켰지만 사람이 사용하는 텍스트에는 기계가 이해하지 못하는 부분이 다량 존재하며, 결과물이 예측을 벗어나는 경우 또한 많다. 그러나 프롬프트 엔지니어링을 거친 텍스트는 사용자의 요청을 비교적 명확하게 전달할 수 있고, 따라서 이미지 생성형 AI의 경우 프롬프트와 이미지 간의 일치도 향상에 기여한다.<br><br> - 이미지 생성형 인공지능의 결과물의 감정 표현력을 높여야한다: 인간에게 감정은 매우 중요하다. 특히 감정의 표현은 자기 표현, 자기 인식, 창의성을 풍부하게 하며 건강과 웰빙에 필수적인 요소이다. 그러나 지금의 컴퓨터는 인간과 달리 감정을 느끼고 공유하는 능력이 부족하다. Generative AI의 등장으로 컴퓨터 비전 분야에서는 감성과 예술의 관계를 중심으로 Emotion based art generation 연구가 진행되고 있다. 그럼에도 불구하고, 사용자의 의도와 정서적 참여가 부족하여 생성 AI가 생성한 이미지에 대해 부정적인 반응이 있었다. 하지만 이러한 고정관념에도 불구하고 Demmer et al.은 감정을 불러일으키는 AI 예술 작품의 잠재력을 보여주었다. 이렇듯 시각 예술에 있어 감정이 중요한 측면으로 논의되므로, 우리는 텍스트 프롬프트를 입력하는 사용자의 감정을 활용하여 프롬프트를 강화하고 이미지 생성형 AI의 한계를 극복하고자 한다.|
| (8-2) 과제: 기존연구와의 비교 |1.  Design Guidelines for Prompt Engineering Text-to-Image generative models <br> - 주제와 스타일 수식어를 포함하도록 구조화된 프롬프트의 내용 일치도와 심미성을 고려하여 성공 및 실패 모드를 조사했다.<br> - 그러나, 이미지의 감정 표현력은 고려하지 않았다.<br><br> 2. AffectGAN: Affect-Based Generative Art Driven by Semantics <br> - GAN (generative adversarial networks)을 이용해 특정 감정을 표현하는 예술적 이미지 생성을 시도하였다.<br>- 그러나 유저에게 자유로운 입력을 받는 대신, A <emotion> <genre> (e.g., “a happy cityscape”)의 양식을 따르도록 하였다. <br><br> 3. RePrompt: Automatic Prompt Editing to Refine AI-Generative Art Towards Precise Expressions<br> - 지금까지의 연구는 주로 사용자의 내용적 의도를 전달하고 미적인 만족도를 높이는 데에만 초점이 맞춰져 있었다. 리프롬프트는 이미지 생성형 AI 정확한 감정 표현을 위해 텍스트 프롬프트를 조정하는 것을 중점으로 한다. 프롬프트 편집 과정은 주어진 텍스트에서 먼저 각 단어의 품사(POS)를 라벨링하고, 명사, 동사 또는 형용사가 아닌 단어를 제거하는 것이며, 원본 프롬프트를 그대로 이용하는 것보다 이미지 생성을 개선하는 데 효과적임을 증명했다. 이들은 감정을 고려한 프롬프트 엔지니어링이 이미지 생성을 개선하는 데에 효과적이며, 특히 부정적인 감정에 대해서는 IEA (이미지-감정 조화) 측면에서 향상되었다는 것을 시사했다.<br> - 그러나, 이 연구는 단어 기준으로 텍스트 맥락을 분석해 의미의 손실이 있었고, 현재의 접근 방법이 구문과 의미에 제한되어 있다고 지적하며, 향후에는 style과 같은 시각적 요소를 고려해야 한다고 주장했다.|
| (8-3) 과제: 제안 내용 |<br>최근 발전한 text-to-image 생성형 AI 모델들은 간단한 텍스트 프롬프트를 이용해 고품질의 이미지를 만들어내는 능력을 보여주고 있다. 그러나 아직까지는 생성형 AI가 감정을 정확하게 반영한 이미지를 만들어내는 능력은 부족하다. 따라서 우리는 감정의 표현력과 미학성을 개선하기 위한 자동 프롬프트 엔지니어링인 'Prompirit'을 제안한다. 우리는 사용자가 입력하는 자유로운 형식의 텍스트 입력을 개선하기 위해 사용자의 감정과 스타일 키워드를 포함하는 다양한 접근법을 탐구했다. 통계적 분석과 100명의 응답자를 대상으로 한 사용자 평가에서 Prompirit는 이미지-감정의 일치도와 생성된 이미지의 미학성을 현저히 향상시키는 동시에 원본 텍스트 입력의 내용을 정확하게 전달하는 것으로 나타났다. 이러한 결과를 바탕으로, 우리는 프롬피릿이 감정을 잘 표현하는 이미지를 효과적으로 생성할 수 있음을 시사한다. <img width="770" alt="스크린샷 2024-06-05 오후 6 56 37" src="https://github.com/hyuni0316/CapstoneDesign-24-1H/assets/79395147/2ee94cc2-301a-4a7f-8f82-f2c85c63c74a"> |
| (8-4) 과제: 과제의 주요 기능 |1. Text Emotion Recognition<br> - 입력된 텍스트에서 사용자의 감정을 인식한다.<br><br>2. Text tokenization & Keyphrase extraction<br> - 자유로운 형식의 텍스트를 프롬프트에 적합한 형태로 편집한다.<br><br> 3. Adding Emotion Labels<br> - Text Emotion Recognition 모델로 인식한 감정 라벨을 강조한다.<br> - 이를 위해 고안한 여러 방법 중 감정 라벨을 prepend하고, 감정 라벨의 동의어 중 중요도가 높은 3개를 append하여 강조하는 방식을 채택한다.<br><br> 4. Adding Style modifiers<br> - 추출한 감정과 관련된 스타일 키워드를 자동으로 추가한다. <br><br> **⇒ 최종 프롬피릿의 루브릭** <br><br> - 다양한 유즈케이스를 커버할 수 있기 때문에 사용자의 발화 그 자체 또한 프롬프트로 활용될 수 있으며, trial-and-error를 방지할 수 있으므로 이미지 생성 AI 기술의 사용 장벽을 낮추었다. <br> - 이미지의 감정 표현력과 심미성을 증진시키면서도 텍스트의 문맥 손실을 최소화하였다. |
| (8-5) 과제: 구현 방법 | ![image](https://github.com/hyuni0316/CapstoneDesign-24-1H/assets/79395147/e6907d06-0bfc-4491-985f-bf2092a25c1f) <br><br> **(A) Preprocess: 감정 라벨링과 텍스트 토큰화를 통해 Main Process를 위한 set up 진행**  <br> <br> **1. Text Emotion Recognition model**  <br> - 일상생활의 대화에 가까운 프롬프트에서도 사용자의 감정을 인식하기 위함  <br> - 부정감정 4개(anger, disgust, fear, sadness)와 긍정감정 4개(contentment, excitement, awe, amusement)로 분류 <br> - Empathetic Dialogues와 GoEmotions 데이터셋을 사용하여 RoBERTa 를 Fine tuning <br> - 하이퍼파라미터: learning rate 2e-5 / batch size 16 / maximum length 128 / 2 epochs ( 정확도: 0.8973 ) <br><br> 2. **Text tokenization & Keyphrase extraction (Remove stopwords & Append one keyphrase) → KeyBERT**  <br> - 구어체와 문어체를 모두 입력으로 받고, 프롬프트에 적합한 형태로 편집하기 위한 과정  <br> - stopwords를 제거하고, KeyBERT를 이용해 중요어구를 추출해 한번 더 추가함  <br> <br><br> **(B) Main Process: 이미지의 감정 표현력과 심미성 향상을 위한 Emotion Label과 Style Modifiers 추가** <br> <br> **Emotion Labels** <br> - 프롬프트에 감정 라벨을 추가하는 것이 생성되는 이미지의 감정 표현력을 향상함은 선행연구에서 증명되었다 <br> → Text Emotion Recognition 모델로 인식한 사용자 감정 label를 프롬프트 앞에 추가한다. <br> - 이 외의 감정 라벨을 추가하는 다양한 방식을 고안하고 실험함 <br><br> 1. 모델이 제시하는 확률에 따른 **강조 형용사 추가** ( Carrillo et al. )<br> - 각 형용사가 감정 강조에 미치는 영향을 나타낸 가중치 이용 <br> - e.g. “extremely”: 95%, “very”: 75% <br><br> 2. **동의어 추가**를 이용한 감정 라벨 반복 및 강조 ( Wang et al. ) <br> - FAISS와 AnglE를 이용해 사용자 감정 동의어 중 프롬프트와 유사도가 높은 감정 3개를 선정하고 프롬프트 뒤에 추가 <br> - 감정 label는 앞에, 유의어는 뒤에 붙임으로써 image-emotion alignment는 높이고 image-text alignment의 loss는 최소화한다. <br> - WordNet과 SenticNet에서 중복된 단어와 문맥별 단어(예: revolt, repel, four-star, first class)를 제거한 감정 동의어를 수집해 corpus를 구축 <br> - cosine similarity를 고려하고 성능 저하를 피하는 corpus에서 상위 3개의 동의어를 선택 <br> - AnglE를 사용해 입력으로 들어온 원본 텍스트와 감정 동의어 간의 유사도를 계산 <br><br> - 최종적으로 감정을 강조하는 네가지 방식을 비교함 <br> - E1: 감정 라벨 <br> - E2: 강조 형용사 + 감정 라벨 <br> - E3: 감정 라벨 + 동의어 추가 <br> - E4: 강조 형용사 + 감정 라벨 + 동의어 추가 <br>![image](https://github.com/hyuni0316/CapstoneDesign-24-1H/assets/79395147/853d1f4f-81e2-496a-86bf-1f0ae4ed1967) <br><br> **Style Modifiers** <br> - 감정을 고려하면서 Style keywords를 적용하는 두가지 방식을 고안하고 비교 <br><br> 1. **사용자 감정과 일치하는 Artemis 데이터셋 캡션에서 키워드 추출** <br> - 클러스터 생성 <br> - LLaMA-2로 데이터 셋의 캡션에서 스타일 관련 키워드 추출 <br> - 추출한 키워드가 포함된 텍스트 데이터를 BERT 임베딩 시킨 후 t-SNE 차원 축소 진행 <br> - 계층적 클러스터링 진행 (자식 노드 최대 30개) <br> - 입력 텍스트와 가장 가까운 클러스터를 찾아, 해당 클러스터의 스타일 키워드들 중 TF (Term Frequency) 점수가 높은 상위 3개의 키워드 추출<br><br> 2. **RAG** 기능으로 **스타일 수식어 리스트**에서 키워드 선택 <br> - MidJourney-Styles-and-Keywords-Reference에서 수집한 스타일 키워드를 color, dimensionality, style, light, perspective로 분류해 리스트로 정리 <br> - 내용에 급격한 스타일 변화가 일어나는 수정자보다는,이미지의 시각적 요소에 변화를 주는 수정자들을 선택 <br> - RAG: LangChain을 통해 LLaMA-2에 입력 텍스트와 감정 라벨을 query로, 스타일 수식어 리스트를 context로 제공 <br> - vector space에서 text chunk를 나타내는 임베딩은 사전 훈련된 모델 sentence-transformers/all-MiniLM-L6-v2를 사용하여 다운로드 <br> - 이 임베딩을 저장하고 retrieve할 vector store로는 ChromaDB를 사용<br> - emotion, aesthetic, context를 모두 고려하여 3개 키워드 선택 <br><br> - 최종적으로 style modifier를 적용하는 두가지 방식을 비교함 <br> - S1: 사용자 감정과 일치하는 Artemis 데이터셋 캡션에서 키워드 추출 <br> - S2: RAG 기능으로 스타일 수식어 리스트**에서 키워드 선택 <br> ![image](https://github.com/hyuni0316/CapstoneDesign-24-1H/assets/79395147/66682ec6-f7a6-4a4f-93f8-fb946fa5bb8f) <br><br> **Data Analysis** <br><br> - BERT의 최대 처리 가능한 토큰 길이를 고려하여 검증 및 테스트 데이터셋에서 1,000개의 프롬프트(감정당 125개의 프롬프트)를 선택 <br> - 이미지 생성은 Stable Diffusion 2.1을 사용 <br> - 평가지표 <br> - **IEA** (Image-Emotion Alignment): 이미지와 감정 라벨 간의 코사인 유사도, CLIP Score 기반 <br> - **ITA** (Image-Text Alignment): 이미지와 input 텍스트 간의 코사인 유사도, CLIP Score 기반 <br> - **Aesthetic Score**: 이미지의 심미적 품질 <br> <br> → 위 3가지 평가지표를 이용해 총 1,000개 이미지에 대한 결과 분석 <br> - BERT의 최대 처리 가능한 토큰 길이를 고려하여 검증 및 테스트 데이터셋에서 1,000개의 프롬프트(감정당 125개의 프롬프트)를 선택 <br> - 이미지 생성은 Stable Diffusion 2.1을 사용 <br><br> - 평가지표 <br> - **IEA** (Image-Emotion Alignment): 이미지와 감정 라벨 간의 코사인 유사도, CLIP Score 기반 <br> - **ITA** (Image-Text Alignment): 이미지와 input 텍스트 간의 코사인 유사도, CLIP Score 기반 <br> - **Aesthetic Score**: 이미지의 심미적 품질 <br> <br> → 위 3가지 평가지표를 이용해 총 1,000개 이미지에 대한 결과 분석 <br> <br> **분석** <br><br> ![image](https://github.com/hyuni0316/CapstoneDesign-24-1H/assets/79395147/c584f93b-a9e3-4758-af88-91853689d3a4) <br><br> 1. **선형혼합회귀모델 (LMER) 피팅** <br><br> - 고정 효과: 프롬프트 엔지니어링 방법 <br> - 랜덤 효과: 각 프롬프트의 ID <br> - 독립 변수: IEA, ITA, Aesthetic Score <br> - 이후 fixed 및 interaction effect에 대한 분산 분석 (ANOVA)과 사후 검정 (post-hoc test) 수행 <br><br> → 각 방법이 통계적으로 유의미한 차이를 보였음을 입증 <br><br> **정규화 진행** <br><br> ![image](https://github.com/hyuni0316/CapstoneDesign-24-1H/assets/79395147/436c4cc5-c862-49af-8ec1-a9eb4f7184f2) <br><br> **분석 결과** <br> - 선형혼합회귀모델 (LMER) 피팅: E3+S2 가 IEA, Aesthetic Score 에서 가장 높은 점수를 보임 <br> - 정규화: E3+﻿S2 가 가장 좋은 결과를 보임 <br> - E3+﻿S2을 Main Process 파이프라인으로 채택 <br> <br> **→ 최종 프롬피릿의 루브릭: 원본 텍스트 → 감정 라벨 + 토큰화 된 텍스트 + 감정 동의어 3개 + 스타일 키워드**|
| (8-6) 과제: 세부 기술 | - PyTorch<br> - CLIP: https://github.com/openai/CLIP → ITA, IEA 계산 <br> - ChromaDB: https://github.com/chroma-core/chroma → vector store for RAG <br> - BERT: https://huggingface.co/docs/transformers/model_doc/bert → Text Emotion Classification (Dataset: Emphathetic Dialogues, GoEmotions) <br> - KeyBERT : https://github.com/MaartenGr/KeyBERT → key phrase extraction - FAISS: https://github.com/facebookresearch/faiss → 텍스트 유사도 기반 서치 <br> - LangChain: https://github.com/langchain-ai/langchain → style modifier 선정 (Dataset: Artemis) <br> - LLaMA-2: https://huggingface.co/docs/transformers/model_doc/llama2 → style modifier 선정<br> - Stable Difussion : https://huggingface.co/stabilityai/stable-diffusion-2-1 → 이미지 생성 <br>- DALL·E 3: https://openai.com/index/dall-e-3/ → User Evaluation 이미지 생성|
| (8-7) 과제: 기대 효과 및 의의 | [기대 효과] <br> • 미술 치료 및 이미지를 통한 심리 치료 등 감정 표출과 이해가 중요한 분야에서 사용이 가능하다.<br> • 어린 아이 또는 자폐 스펙트럼과 같이 감정을 표현하는 데 서툰 사람들을 대상으로 감정 이해도 향상 보조에 활용 가능하다.<br> • 마케팅이나 미디어 콘텐츠 제작 시, 특정 감정을 자극하는 이미지를 생성하여 대상 audience의 관심을 끌고, 메시지의 전달력을 강화할 수 있다. - 생성된 이미지의 감정 표현력과 심미성을 향상시키면서 텍스트의 맥락 손실을 최소화했다. <br><br> [의의] <br> - 감정 라벨을 추가하여 image-emotion alignment에 가장 효과적인 프롬프트 편집 방법에 대한 가설을 설계하고 실험했다. <br> - 입력 텍스트에서 추출된 감정 맥락에서 해당 감정을 극대화 시키는 이미지 스타일 수식어를 고안했다. <br> - 사용자(특히 비전문가)를 위한 end-to-end 프롬프트 최적화 방법을 제안한다.|
| (9) 데모 내용 |  1. Prompirit 논문 발표 <br> 2. Prompirit을 이용해 엔지니어링 된 프롬프트로 이미지를 생성하는 과정 시연 |
| (10) 기타 | [논문 링크]<br> https://sites.google.com/view/prompirit-pororoeddy/ <br><br>  [Conference] <br> 2024 IEEE 25th International Conference on Information Reuse and Integration for Data Science Accepted. San Jose, CA, USA from August 7 to August 9, 2024 발표 예정. <br><br> [References]<br> [1] Yunlong Wang, Shuyuan Shen, and Brian Y. Lim. 2023. RePrompt: Automatic Prompt Editing to Refine AI-Generative Art Towards Precise Expressions. In Proceedings of the 2023 CHI Conference on Human Factors in Computing Systems (CHI ’23), April 23–28, 2023, Hamburg, Germany. ACM, New York, NY, USA, 29 pages. https://doi.org/10.1145/3544548.3581402<br> [2] Jonas Oppenlaender. 2022. Prompt Engineering for Text-Based Generative Art. arXiv 1, 1. Retrieved from http://arxiv.org/abs/2204.13988<br> [3] Ankita Gandhi, Kinjal Adhvaryu, Soujanya Poria, Erik Cambria, Amir Hussain, Multimodal sentiment analysis: A systematic review of history, datasets, multimodal fusion methods, applications, challenges and future directions, Information Fusion, Volume 91, 2023, Pages 424-444, ISSN 1566-2535, https://doi.org/10.1016/j.inffus.2022.09.025.<br> [4] Amir Zadeh, Minghai Chen, Soujanya Poria, Erik Cambria, and Louis-Philippe Morency. 2017. Tensor Fusion Network for Multimodal Sentiment Analysis. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 1103–1114, Copenhagen, Denmark. Association for Computational Linguistics.<br> [5] Andrea Scarantino. 2017. How to Do Things with Emotional Expressions: The Theory of Affective Pragmatics. Psychological Inquiry 28, 2–3: 165–185. https://doi.org/10.1080/1047840X.2017.1328951 |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-19
| (1) 과제명 | 캣치타임: 효율적인 시간 관리를 돕는 타이머 기반 캐릭터 육성 게임
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 19-TMM |
| (3) 팀원 역할 분담 | 이가연(2176241) : 게임 시나리오 작성, 아이디어 개발, 기본 UI 구성 및 디자인, 프로그램 개발<br>한서연(2071052) : 그래픽 리소스 제작, 아이디어 개발, 데이터베이스 관리, 프로그램 개발<br>이자영(1971037) : 그래픽 리소스 제작, 아이디어 개발, 프로그램 개발, 프로젝트 자료 정리 |
| (4) 팀 지도교수 | 최병주 |
| (5) 팀 멘토 | 채윤호 / 나이트앤비숍 / 대표이사 |
| (6) 과제 키워드(keywords) | 타이머, 시간 관리, 캐릭터 육성 게임 |
| (7) 과제 내용 요약 | 일에 집중하지 못해 시간을 어영부영 소비하는 2-30대를 위해 게임성으로 동기를 부여하여 시간 관리를 돕는 모바일 2D 캐릭터 육성 게임 어플리케이션입니다. 게임 내의 타이머 기능을 작동시키면 휴대폰 제한 모드가 켜져 업무 시간에 일, 또는 공부에 온전히 집중할 수 있고, 일과 휴식 시간을 구분함으로써 각각의 시간을 효율적으로 사용할 수 있도록 시간 관리를 돕습니다. 동시에 계획 이행에 대한 보상으로 자신만의 귀여운 동물 마을을 꾸밀 수 있어 시간 관리를 일종의 오락으로 만듭니다. |
| (8-1) 과제: 문제의 정의 | 많은 20, 30대가 업무 및 공부를 비롯하여 해야 할 일에 의욕을 느끼거나 집중하지 못한다. 또한 일과 휴식 간의 구분을 확실히 하지 못하고 업무 시간과 휴식 시간이 혼재되게 내버려 두어 효율적인 시간 관리에 실패하는 경우가 비일비재하다. 이로 인해 결국 소요 시간 대비 생산 효율성이 저하되는 문제가 증가하고 있다. |
| (8-2) 과제: 기존연구와의 비교 | Habitica: 투두리스트를 체크해 경험치를 쌓아 캐릭터를 육성하고, 펫이나 탈 것을 모을 수 있는 게임. 데일리 루틴이나 뽀모도로 챌린지 등을 할 수 있다. 그러나 한국어 지원이 되지 않고 사용자가 일을 하지 않았음에도 임의로 리스트를 체크할 수 있다는 약점이 있다.<br>열품타: 타이머를 켜둔 동안 휴대폰으로 딴짓을 하려고 하면 타이머를 중지해 시간에 집계되지 않게 만든 시간 관리 어플. 다른 사용자들과 스터디그룹을 만들 수 있고, 백색소음이나 영단어, 뽀모도로 기능 등을 제공한다. 그러나 스스로의 의지가 없다면 동기부여가 되지 않는다는 약점이 있다.<br>Focus To-Do: 뽀모도로 타이머와 스케줄 관리 기능을 제공하는 앱. 제한모드(핸드폰 뒤집기, 앱 종료 금지)로 강제성을 부여하고 백색소음 기능으로 집중력 향상에 도움을 준다. 업무 달성에 따른 보상을 모아 나무를 키울 수 있는 미니 게임을 통해 성취감을 얻을 수 있다. 그러나 나무가 성장하는 것 외에 다른 스토리성이 없어 흥미를 느끼지 못할 수 있다. |
| (8-3) 과제: 제안 내용 | 간단한 조작으로 시간을 효율적으로 관리할 수 있고, 성공적인 시간 관리에 대한 보상으로 캐릭터를 꾸미는 등 개인의 취향을 담아 커스텀할 수 있는 서비스를 제공함으로써, 이를 이용한 효율적인 시간 관리를 통해 작업 능률, 속도 등을 향상시켜 생산 효율성을 높일 수 있는 동기를 부여하고자 한다.<br><br>1. 타이머 + 휴대폰 제한모드 기능으로 사용자가 설정한 시간 동안 강제적으로 휴대폰을 하지 못하도록 한다.<br>2. 타이머로 설정한 시간이 지나면 제한모드가 풀리고, 시간 관리에 대한 보상으로 게임 재화를 지급한다.<br>3. 지급된 재화로 아이템을 구매하여 캐릭터를 꾸미고 성장시킨다.<br>4. 이때 재화는 오로지 타이머 기능을 사용했을 때만 지급함으로써, 업무보다 게임 자체에 시간을 더 많이 쓰는 주객전도 상황을 막는다.<br><br>이러한 기능을 바탕으로 기존의 비슷한 어플리케이션과 같이 사용자의 시간 관리를 도우면서도, 사용자가 업무/공부를 지속할 동기를 부여하여 효율적인 시간 관리가 계속되도록 한다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 타이머 기능, 휴대폰 제한모드<br>- 사용자가 타이머에 일 시간과 휴식 시간을 입력하면, 각각의 타이머가 차례로 작동한다. 그리고 일 시간 타이머가 돌아가는 동안은 휴대폰 제한모드가 실행되어 강제적으로 사용자가 휴대폰을 하지 못하도록 한다.<br><br>2. 보상 지급<br>- 사용자가 타이머 기능 사용을 완료하면 재화를 지급한다.<br><br>3. 상점 기능, 아이템 보관함<br>- 상점에서 조경물과 액세서리를 구매해 마을과 캐릭터를 꾸밀 수 있다. 구매한 아이템은 아이템 보관함에서 확인 가능하다. <br><br>4. 친구 기능<br>- 친구 신청을 통해 친구를 추가할 수 있고, 친구의 마을을 방문하거나 친구의 리포트를 확인할 수 있다.<br><br>5. 리포트 기능<br>- 사용자의 누적된 타이머 기록을 주/월 단위로 시각적 자료인 그래프로 제공해 확인할 수 있게 한다. Unity에서 제공하는 그래프 기능을 이용하며 데이터 영역(사용자) 찾기 - 데이터 수집 - 시각화할 카테고리 추가 순으로 진행한다.<br><br>6. 설정 기능<br>- 사용자 계정 정보 확인, 음량 조절, 로그아웃, 계정 삭제 등의 조작이 가능하다.<br><br>7. 선물함<br>- 운영자가 사용자에게 이벤트 아이템 등을 지급할 때 사용되는 기능이다. |
| (8-5) 과제: 구현 방법 | 디바이스 - 안드로이드<br>게임엔진 - Unity<br>서버&데이터베이스 - Firebase |
| (8-6) 과제: 세부 기술 | FrontEnd - Unity로 어플리케이션의 화면과 각 화면에 따른 사용자 기능을 구현한다.<br>C# Script - 사용자가 기능 버튼을 누르면 작동하는 개발자 기능을 구현하고 백엔드와 연결한다.<br>BackEnd - Firebase를 유저 정보와 관련된 데이터베이스로, Unity의 PlayerPrefs를 게임 내 설정 정보와 관련된 데이터베이스로 사용한다. |
| (8-7) 과제: 기대 효과 및 의의 | 1. 타이머나 휴대폰 제한모드 등 게임의 기능을 이용하여 업무 집중이 어려운 현대인들에게 강제성을 동반한 도움을 줌으로써 시간을 효율적으로 사용할 수 있게 하고, 시간 대비 결과물의 완성도를 높인다.<br><br>2. 목표 달성 시 즉각적으로 보상이 주어지고, 시각적인 화면 변화를 보여주는 게임의 특성을 통해 비교적 빠르고 충족하기 쉬운 성취감을 제공함으로써 사용자에게 업무를 지속할 동기를 부여하며 의욕을 증진시킨다.<br><br>3. 일과 휴식의 구분을 명확히 함으로써 전체적인 삶의 질을 향상시키고, 게임 내 친구 기능을 통해 게임이라는 공통된 관심사를 즐기면서 서로의 연결고리를 이어갈 수 있게 도와 사용자들의 마음에 즐거움과 정서적 충족감을 준다. |
| (9) 데모 내용 | 1. 사용자가 어플리케이션을 켜면 가장 먼저 보이는 메인 화면(마을 화면)의 우측 하단에 있는 타이머 버튼을 누른다.<br>2. 만약 이전에 타이머를 사용한 적이 있다면 지난 시간 버튼을 통해 전과 같은 시간대로 타이머를 맞출 수 있고, 처음 타이머 기능을 사용하는 것이라면 자신이 원하는 시간을 직접 맞추거나 뽀모도로 버튼을 통해 간단하게 뽀모도로 기법에 따라 시간을 맞출 수 있다.<br>3. 하단의 시작 버튼을 누르면 먼저 일 시간 타이머가 돌아가기 시작하고, 동시에 휴대폰 제한모드 기능이 작동되어 사용자가 설정한 시간 동안 휴대폰의 다른 기능을 사용하지 못하게 한다.<br>4. 타이머로 설정한 일 시간이 끝나면 휴대폰 제한모드가 풀리고, 휴식 시간 타이머가 돌아가기 시작한다.<br>5. 휴식 시간까지 끝나게 되면 시간 관리 달성 완료 보상으로 게임 재화(다이아)가 지급된다.<br>6. 지급된 재화로 상점에서 아이템을 구매하고, 아이템 보관함에서 꾸미기를 진행한다.<br>7. 누적된 타이머 기록을 분석하여 제공된 사용자의 주간/월간 리포트를 확인한다.<br>8. 친구 목록 화면으로 이동해 새로운 친구를 추가하거나 자신에게 들어온 친구 요청을 수락할 수 있고, 친구의 시간 관리 리포트를 확인하거나 마을에 방문할 수 있다. |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-20
| (1) 과제명 | 쿡세이브: 식재료 관리를 통한 1인 가구의 식비 절감 지원 웹앱 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 20-쿠킹마마 |
| (3) 팀원 역할 분담 | 최예은(1971053) 팀장, AI 파트 담당<br>송지민(2076214) 팀원, 디자인, 프론트엔드 담당<br>차소연(2076404) 팀원, 백엔드 담당 |
| (4) 팀 지도교수 | 심재형 교수님 |
| (5) 팀 멘토 | 박한 / Deeply / CTO |
| (6) 과제 키워드(keywords) | 요리, 식비 절감, 식재료 |
| (7) 과제 내용 요약 | 쿡세이브는 비싼 외식비, 배달비가 부담 되지만 아직 요리에는 서툴고, 냉장고 속 식재료는 금방 상해 폐기하는 경우가 많은 초보 자취생들에게 ‘AI를 통한 간편한 식재료 등록’, ‘레시피 추천’, ‘식비 절감 통계’, ‘AI 챗봇 쿠쿠’ 를 제공하여 요리 해먹기를 바탕으로 식비 절감을 돕는 하이브리드 앱 서비스입니다. |
| (8-1) 과제: 문제의 정의 | 문제1. 1인 가구의 경우 대량으로 구매한 식재료를 기한 내에 소비하지 못해 식재료가 상해서 낭비하게 되는 경우가 많습니다. 또한, 20대 1인 가구의 경우 1인 식생활이 익숙치 않아 레시피나 재료 보관방법 등을 자주 검색해보곤합니다. 따라서 보유하고 있는 식재료를 쉽게 파악할 수 있고, 1인 가구의 식생활을 지원하는 통합적인 서비스가 필요합니다. <br>문제2. 물가 상승으로 1인 가구의 식비 부담은 점점 커지는 추세입니다. 이러한 상황에서 사용자가 효과적으로 식비를 조절할 수 있도록 식비 관리를 집중적으로 지원하는 서비스가 필요합니다.<br>문제3. 유용한 서비스라 해도 서비스를 사용할 때 거쳐야 하는 과정이 번거로우면 지속적으로 이용하기 어렵습니다. 의식주 중 하나인 식생활과 관련된 서비스는 사용자에게 이용의 편리함을 제공하여야 합니다. 따라서 1인 가구의 식생활 및 식비 절감을 지원하는 높은 사용성의 모바일 앱 서비스가 필요합니다. |
| (8-2) 과제: 기존연구와의 비교 | 1. ‘만개의 레시피’ 웹 서비스: <br>장점 : 여러 카테고리로 구분 다양한 레시피를 제공합니다. 또한, 요리에 사용되는 물품을 구매할 수 있습니다.<br>단점 : 레시피의 영상을 조회하려면 링크를 이용해 다른 서비스를 참조해야 되어 정보를 얻는 과정이 매끄럽지 못합니다.<br><br>2. ‘유리트 주간 식단’ 앱 서비스: <br>장점: 레시피 제공이나 식비에 대한 가계부 기능을 제공해주는 서비스입니다.<br>단점: 모든 기능들이 식단 관리에 초점이 맞춰져있고 식비 절감이라는 목표로 이어지지 않습니다.  또한 식재료 및 식단 모두 사용자가 직접 입력하는 형태입니다.<br><br>3. ‘레시피 냉장고’ 앱 서비스:<br>장점: 다른 사용자들과 레시피를 공유할 수 있는 커뮤니티 기능을 제공합니다. <br>단점: 식재료를 제공받은 카테고리 내에서 직접 입력 등록해야 합니다. 식재료별 가격 선택이 불가합니다. 레시피 추천이 보유한 식재료를 바탕으로 이루어지지 않습니다. 레시피마다 보유한 재료와 필요한 재료를 구분해서 보여주는 것 외의 요리 내역 저장 기능은 없습니다.<br><br>4. ‘거꾸로 레시피’ 앱 서비스: <br>장점: 식재료의 수량과 가격을 입력 받지 않으므로 식재료 등록에 소요되는 시간이 짧습니다. 식재료별 소비 기한을 자동으로 설정하고 알림을 제공합니다. 레시피 목록을 제공합니다. 레시피 북마크가 가능합니다.<br>단점: 식재료별 수량, 가격 선택이 불가합니다. 식재료의 가격을 등록하지 않으므로 비용 관련 내용을 확인할 수 없습니다.  사용자가 가진 식재료를 바탕으로 한 레시피 추천 기능이 없습니다.<br><br>5. ‘Pantry - 물건 유통기한관리’ 앱 서비스: <br>장점: 개인 냉장고 폴더를 만들어 물건의 바코드를 스캔하여 물건 및 재료 등록을 합니다. 등록한 재료를 바탕으로 한 아이템 검색 기능이 있습니다. 재료 리스트를 유통기한 순으로 정렬하여 조회할 수 있습니다. 유통기한 1일, 3일, 7일 전 알림 기능을 제공합니다. <br>단점: 바코드 스캔으로 물건을 등록할 경우 상품 이름만 자동으로 입력되고 이미지, 유통기한, 수량 등의 정보는 직접 입력해야 합니다. 재료의 가격을 선택할 수 없습니다. 유통기한 관리 기능 외의 다른 기능은 없습니다.<br><br>결론 : 위의 5가지 웹 및 앱 서비스를 분석한 결과, 식비 절감을 목표로 하여 통계를 제공하는 서비스가 부재함을 확인했습니다. 아래 다섯 가지 서비스 모두 식재료 등록 과정에서 식재료의 가격을 입력 받지 않으므로 식비 관련 내용은 확인이 불가하여 1인 가구의 식비 부담 문제에 대한 해결책이 될 수 없다고 판단했습니다. 또한 기존 서비스들은 가진 재료를 바탕으로 한 레시피 추천이 이루어지지 않아 식재료의 빠르고 적절한 소비를 도울 수 없으며, 제공되는 레시피 이외에는 자유로운 재료 선택이 불가합니다. 또, 대체적으로 레시피 선택 완료 후 식재료의 수량이 자동 차감되는 기능이 없어 단순히 레시피를 조회하는데에 그치는 경우가 대부분입니다. |
| (8-3) 과제: 제안 내용 | 문제1. 번거로운 식재료 등록 과정<br>⇒ Object Detection과 OCR 기술을 활용하여 카메라 렌즈로 식재료를 촬영하거나 주문내역 캡처본 및 영수증 촬영으로 식재료의 자동 등록이 가능하도록 했습니다. 이는 식재료 등록에 소요되는 시간을 줄이고 사용자가 스스로 텍스트를 입력하는 번거로움을 줄여 서비스의 사용성을 증대시킵니다. 이 방법의 경우 기술의 정확도에 따라 등록이 제대로 이루어지지 않을 수 있다는 단점이 있으나, 이를 보완하기 위해 사용자가 식재료의 정보를 부분적으로 수정할 수 있도록 개발을 진행했습니다.<br><br>문제2. 제한적인 레시피 추천<br>⇒ 기존 서비스의 경우, 데이터베이스에 등록되어있는 레시피 이외에는 추천이 불가능한 점을 ‘AI 챗봇 쿠쿠’를 도입하여 해결했습니다. AI가 제공하는 답변을 통해 선택지의 확장이 가능합니다. 또, 레시피 뿐만 아니라 식재료의 소비기한이나 보관방법 등 다양한 식재료 관련 사용자의 궁금증을 해결할 수 있도록 지원합니다. 뿐만 아니라 사용자가 제공되는 레시피 이외에도 원하는 재료를 직접 선택하여 레시피를 생성하는 기능 또한 제공하여 서비스 사용에 제한이 없도록 개발했습니다.<br><br>문제3. 비가시적인 식비 절감 효과<br>⇒ 기존 서비스는 서비스의 사용을 바탕으로 얼마 만큼의 식비를 절감했는지 그 내역을 제공하지 않습니다. 쿡세이브는 ‘예산 설정’, ‘월별 통계 제공’, ‘요리 내역 저장’을 통해 사용자들이 절감한 식비를 한눈에 파악할 수 있도록 하여 식비 절감 및 서비스 사용의 동기부여를 제공합니다. 뿐만 아니라, 레시피 선택 시에 자동으로 사용자가 선택한 식재료의 수량 만큼의 가격이 계산되고 저장되므로 사용자는 번거로운 계산 과정을 거칠 필요가 없습니다. |
| (8-4) 과제: 과제의 주요 기능 | 1. Object detection 및 OCR 기술을 통한 간편한 식재료 등록 <br>2. 등록한 식재료를 바탕으로 레시피를 추천<br>3. 레시피 선택 시 사용되는 식재료의 수량 자동 차감 및 비용 자동 계산<br>4. 식비 절감 내역 및 요리 히스토리를 보여주는 월별 통계 제공<br>5. 1인 가구의 식생활을 돕기 위한 정보를 제공하는 AI 챗봇<br>6. 서비스 사용 리마인드를 위한 푸시 알림 제공 |
| (8-5) 과제: 구현 방법 | 4-1. 디자인 <br>Figma를 활용하여 와이어프레임을 기반으로 모바일 뷰를 기본으로한 UI/UX 디자인을 완성했습니다. <br><br> 4-2. 프론트엔드<br> React.js와 Typescript를 이용하여 클라이언트단을 개발했습니다. 이때, 스타일링 라이브러리로는 styled-components를 활용하여 완성된 디자인을 바탕으로 퍼블리싱을 진행했습니다. 서버와의 http 통신은 axios 라이브러리를 통해 연결하여 실제 데이터를 화면에 연동했습니다. 추가로, Recoil을 활용하여 전역 상 태 관리를 하여 서비스의 완성도 및 효율성을 확보했습니다. 완성된 웹은 안드로이드 웹 뷰와 프로그레시브 웹앱을 통해 하이브 리드앱으로 변환했습니다. <br><br>4-3.백엔드 <br>Spring Boot 프레임워크를 이용하여 API를 구현한 후 AWS를 이용해 서버에 배포합니다. 로드밸런서로 웹 사이트에 https로 보안 접속이 가능하게 만듭니다. OCR API를 이용하는 기능은 프론트로부터 전달 받은 데이터와 함께 OCR 서버에 요청을 보낸 후 받은 응답을 프론트로 전달하도록 구현합니다. AI 모델은 API 와는 다른 별개의 서버를 구축해 배포합니다.<br><br> 4-4. AI <br> Pytorch를 사용하여 전체적인 AI 서버(flask 서버)를 개발합니다. 식재료 사진 인식에서 사용할 오브젝트 디텍션 파트에선 Yolo 버전8을 사용하기로 결정하였으며 학습 및 테스트를 tencent cloud의 tesla T4 GPU를 활용하여 진행합니다. 제작한 Flask API는 Gunicorn, uWSGI, Nginx를 연결하여 배포합니다. 영수증 인식에서 사용할 OCR 기술은 Naver Clova OCR API를 사용합니다. <br><br> 4-5 ChatBot <br> 챗봇 기능에는 Open AI의 GPT 3.5 Turbo 모델을 이용했습니다. 백엔드를 거치지 않고 프론트에서 바로 API 연결을 진행했으며 Recoil-persist 라이브러리를 이용하여 localStorage에 채팅 내역이 저장되도록 했습니다. |
| (8-6) 과제: 세부 기술 | 메인 기능인 Object Detection을 통한 식재료 등록에 사용된 세부 기술 및 프로세스는 다음과 같습니다.<br>1. 프론트에서 사용자가 사진을 입력합니다. (갤러리에서 사진 첨부 또는 촬영) <br>2. 입력한 사진은 http post 요청으로 AI의 yolo모델에 전달됩니다. <br>3. AI 파트는 yolo 모델의 인식 결과를 JSON의 형태로 프론트에 반환합니다. <br>4. 사용자는 반환된 인식 결과를 확인한 후 등록 완료를 눌러 http Post 요청을 통해 백엔드로 등록 내용을 전달합니다. <br>5. 백엔드는 받은 요청을 바탕으로 DB에 식재료를 저장합니다.|
| (8-7) 과제: 기대 효과 및 의의 | 1. 1인 가구는 쿡세이브를 통해 냉장고 속 식재료를 원활하게 관리할 수 있습니다.<br>2. 쿡 세이브는 사용자들이 가진 재료를 바탕으로 요리를 하도록 유도하기 때문에 식비 절감을 이끌어 냅니다. <br> 3. 사용자들은 자신의 식비 절감 통계 내역을 확인하여 예산 내의 합리적인 소비를 이어갈 수 있습니다. <br> 4. 배달과 외식이 아닌 직접 요리해먹는 습관은 식비 절감 뿐만 아니라 건강한 식습관 개선으로 이어질 수도 있다는 점에서도 의의를 갖습니다. |
| (9) 데모 내용 |1. 회원 가입한 정보로 서비스에 로그인합니다. <br>2. 재료의 정보를 직접 입력하여 등록합니다.<br>3. 사물 인식 기술을 이용해 재료를 인식한 후 그 결과를 이용해 재료를 등록합니다.<br>4. 재료의 수량, 아이콘 정보를 수정합니다.<br>5. 레시피 목록에서 요리할 레시피를 선택합니다.<br>6. 레시피 목록에서 특정 레시피를 북마크하고 북마크 레시피를 모아봅니다.<br>7. 요리에 사용할 재료를 선택합니다.<br>8. 사용한 재료와 레시피 정보를 요리 내역에서 확인합니다.<br>9. 요리 내역에 대한 통계를 확인합니다.<br>10. 한달 예산을 수정합니다.<br>11. 챗봇에 질문하고 응답을 받습니다.  |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-21
| (1) 과제명 | 일기장 속 친구 :감정 이해와 조언의 동반자 PSYLOG
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 21-AtoB |
| (3) 팀원 역할 분담 | 오윤재(2171030): 리더, 프론트엔드<br>윤주영(2171034): 백엔드, AI, 서버 배포<br>신다영(1976202): 백엔드, AI, 서버 배포 |
| (4) 팀 지도교수 | 윤명국 |
| (5) 팀 멘토 | 박성규/ Pango-Gy/ Software Engineer |
| (6) 과제 키워드(keywords) | 일기, 감정분석, 공감 |
| (7) 과제 내용 요약 | Psylog는 OpenAI의 fine tuning 기술을 활용해 사용자의 일기를 상담사 관점에서 깊이 이해하고 이에 대한 조언 및 공감을 제공합니다.<br><br> 또한, Naver Cloud의 CLOVA Sentiment 모델을 사용하여 단순히 글을 읽는 것을 넘어, 사용자의 감정을 3가지로 분류하고, 일기 내용에 내포된 감정 형태를 시각적으로 확인할 수 있도록 pie-chart를 통해 자신의 심리 상태를 한눈에 파악할 수 있도록 도와줍니다. 이를 통해 사용자는 자신의 감정 변화를 이해하고, 긍정적인 정신 건강을 유지하는 데 필요한 지원을 받을 수 있습니다. |
| (8-1) 과제: 문제의 정의 | 많은 사람들은 사회적 압력, 편견, 자신이 처한 환경 때문에 자신의 감정을 억누르거나 숨기게 됩니다. 감정을 솔직히 털어놓지 못하는 것은 스트레스를 유발하고 이는 정신 건강 문제로 이어지게 됩니다.<br>이러한 문제점을 해결하고자 자신의 속마음을 솔직히 털어놓고 공감 및 조언을 받고 싶은 현대인들을 타겟 사용자로 하여 PSYLog 사용자들이 타인에게 쉽게 털어놓을 수 없는 이야기를 해당 서비스를 통해 털어놓고 이에 대한 공감 및 조언을 제공하고자 합니다. |
| (8-2) 과제: 기존연구와의 비교 | 1) 일반 다이어리 서비스 : 기존의 다이어리 서비스들은 단순히 사용자가 작성한 일기를 저장하고 추후에 이를 다시 볼 수 있는 기능을 제공합니다. 이런 기존 서비스들과 달리 PSYLog는 사용자의 일기장 속 친구가 되어 사용자가 작성한 일기를 저장할 뿐만 아니라 이를 분석하여 사용자의 하루에 공감해주며 도움이 될 수 있는 조언을 제공합니다.<br>2) 심리 상담 AI 챗봇 : 감정 문제 해결을 위한 대화형 챗봇 서비스들은 사용자들과의 상호작용을 통해 공감 등의 반응을 즉각적으로 제공해주는 서비스입니다. 이러한 단순 대화형 챗봇과는 달리 PSYLog는 사용자의 일기를 통해 개개인의 전체적인 상황을 파악하여 감정 상태를 분석하기 때문에 더욱 심층적인 조언을 제공할 수 있습니다. 또한, 일기 작성을 통해 사용자들은 자세한 감정 표현을 할 수 있고, 이를 통해 더욱 정확하고 유의미한 분석을 제공할 수 있습니다.  |
| (8-3) 과제: 제안 내용 | 1.일기에 대한 공감 및 조언 제공: Psylog는 OpenAI의 fine tuning 기술을 활용하여 사용자의 일기를 깊이 이해합니다. 단순히 글을 읽는 것을 넘어, 사용자의 감정과 상황을 세심하게 분석합니다. 이를 통해 친근한 친구처럼 개인 맞춤형 공감과 조언을 제공합니다.<br>2. 감정 상태에 대한 가시적 분석 그래프 제공: CLOVA Sentiment 모델을 이용하여 사용자가 작성한 일기에 대한 감정 분류를 진행합니다. 이를 통해 사용자는 자신의 심리 상태를 수치를 통해 더욱 정확하게 파악할 수 있습니다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 일기 작성 및 저장<br>사용자가 프론트 화면을 통해 일기를 작성하고 저장하기 버튼을 누르면 html 코드를 통해 날짜, 기분, 제목, 내용 정보가 스프링 서버로 전달된다. Diary Save 모듈을 통해 일기에 대한 날짜, 기분, 제목, 내용 정보가 mysql DB에 전달되고 post_table에 저장된다.<br>2. 공감 및 조언 제공<br>일기 ID를 input으로 하여 Get Diary Content 모듈을 통해 DB에서 일기 내용을 불러오고, Get GPT Response 모듈을 통해 GPT 모델에 일기 내용을 input으로 전달한다. 이때, 스프링 서버와 GPT API 통신에는 Rest API를 이용한다. GPT가 공감 및 조언 내용을 생성하면, Rest API를 이용한 통신을 통해 그 내용을 스프링 서버로 받아와 DB에 응답 내용을 저장한다. 후에, 사용자가 일기를 조회할 때 Get Diary 모듈을 통해 공감 및 조언 내용을 DB에서 불러와 그 정보를 프론트 화면에 출력하여 사용자가 확인할 수 있도록 한다.<br>3. 감정 분류 차트 제공<br>일기 ID를 input으로 하여 Get Diary Content 모듈을 통해 DB에서 일기 내용을 불러오고, Analyze Sentiment 모듈을 통해 CLOVA sentiment 모델에 일기 내용을 input으로 전달한다. 이때, 스프링 서버와 CLOVA API 통신에는 Rest API를 이용한다. CLOVA Sentiment 모델이 일기 내용에 대한 감정 분류를 마치면, Rest API를 이용한 통신을 통해 negative, positive, neutral에 대한 수치를 스프링 서버로 받아와 DB에 그 내용을 저장한다. 후에, 사용자가 일기를 조회할 때 Get Diary 모듈을 통해 감정 분류 수치를 DB에서 불러와 그 정보를 프론트 화면에 출력하여 사용자가 확인할 수 있도록 한다. |
| (8-5) 과제: 구현 방법 | 1. 일기 작성 및 저장<br>구현 방법: 사용자가 프론트 화면을 통해 일기를 작성하고 저장하기 버튼을 누르면 HTML 코드를 통해 날짜, 기분, 제목, 내용 정보가 스프링 서버로 전달됩니다. Diary Save 모듈을 통해 일기에 대한 정보가 MySQL DB에 전달되고 post_table에 저장됩니다.<br>2. 공감 및 조언 제공<br>구현 방법: 일기 ID를 input으로 하여 Get Diary Content 모듈을 통해 DB에서 일기 내용을 불러오고, Get GPT Response 모듈을 통해 GPT 모델에 일기 내용을 input으로 전달합니다. GPT가 생성한 공감 및 조언 내용을 스프링 서버로 받아와 DB에 저장하고, 사용자가 일기를 조회할 때 프론트 화면에 출력합니다.<br>3. 감정 분류 차트 제공<br>구현 방법: 일기 ID를 input으로 하여 Get Diary Content 모듈을 통해 DB에서 일기 내용을 불러오고, Analyze Sentiment 모듈을 통해 Clova Sentiment 모델에 일기 내용을 input으로 전달합니다. Clova Sentiment 모델이 감정 분류를 마치면, 그 결과를 스프링 서버로 받아와 DB에 저장하고, 사용자가 일기를 조회할 때 프론트 화면에 출력하여 확인할 수 있도록 합니다. |
| (8-6) 과제: 세부 기술 | 1. 프론트엔드<br>  - HTML/CSS : 사용자 인터페이스 구성 및 스타일링.<br>  - JavaScript : 캘린더 날짜 구현과 버튼 처리같은 동적인 사용자 경험을 처리하기 위해 사용<br>2. 백엔드 기술<br>  - 백엔드 프레임워크 : Spring Boot를 이용하여 RESTful API를 작성. 이때, JWT 인증/인가 방식을 도입하여 보안성을 강화하고, API 버전 관리를 통한 유지보수 용이성을 고려.<br>  - 데이터베이스 관리 : JPA를 선택한 이유는 객체 지향 프로그래밍과 데이터베이스 사이의 패러다임 불일치를 해결하고, 데이터베이스 코드의 간결성 및 유지보수성 향상에 기여하기 때문.<br>  - OpenAI API : GPT-3.5를 약 20개의 message들로 이루어진 dataset.jsonl을 이용하여 fine tuning함. OpenAI API를 발급받아 이를 이용하여 일기 분석 및 공감/조언 생성. 이를 통해 사용자에게 맞춤형 콘텐츠를 제공.<br>  - Clova Sentiment API : 사용자의 일기를 3가지의 감정으로 분석.<br>3. 서버 배포 기술<br>  - AWS EC2 : EC2 인스턴스를 생성하고, SSH 통신을 이용하여 프로젝트 github repository를 clone하여 설치한 후 서버를 구축하고 관리<br>  - AWS RDS: RDS DB 인스턴스를 생성하여 백 코드에 엔드포인트 url 및 사용자 암호 정보를 입력하여 통신 |
| (8-7) 과제: 기대 효과 및 의의 |  ▶ 스트레스 감소 및 정신 건강 개선 : PSYLog를 통해 사용자들은 누구에게도 편안히 말할 수 없었던 자신의 속마음을 솔직하게 털어놓을 수 있습니다. 이에 그치지 않고 PSYLog는 사용자의 일기를 깊이 분석하여 진짜 친한 친구처럼 개인 맞춤형 공감과 조언을 제공합니다. 이를 통해 사용자들은 감정을 억누르지 않고 표현할 수 있으며, 서비스가 제공하는 조언을 통해 정신 건강을 개선하고 스트레스를 감소시킬 수 있습니다.<br>▶ 감정 상태 시각화를 통한 감정 이해 강화: Clova Sentiment를 활용하여 제공되는 감정 분석 그래프는 사용자의 하루 동안의 감정 분포를 한눈에 파악할 수 있도록 합니다. 이를 통해 사용자는 자신의 현 감정 상태에 대한 이해를 높일 수 있고, 필요한 조치를 취할 수 있는 인사이트를 얻을 수 있습니다.  |
| (9) 데모 내용 | 김이화 학생은 진로 고민, 학업 활동 등으로 불안한 심리 상태에 있던 중 친구의 추천으로 일기장 웹 서비스 PSYLog를 사용해보게 되었다. 이화는 회원가입을 통해 생성한 아이디로 로그인하여 PSYLog 홈 화면의 '일기 작성' 버튼을 눌러 일기를 작성한다. 일기에는 일기 제목, 기분, 일기 내용이 포함된다. 이화는 중간고사에 대한 일기 내용을 작성하였고, 일기 저장 버튼을 통해 일기를 등록한 뒤, 바로 이어지는 홈 화면에서 본인이 등록한 일기를 확인할 수 있었다. 이화는 방금 자신이 작성한 일기를 클릭하여 자신의 중간고사 걱정 내용에 대한 감정 분류 차트와 공감 및 조언 내용을 확인하고 위로를 받을 수 있었다. 한 달 후, 이화는 PSYLog에 로그인하여 홈 화면의 달력을 통해 지난 한 달 동안 자신이 일기를 작성한 날들에 대한 감정 분포를 한 눈에 확인하고 정리하는 시간을 가졌다. 또한, 일기장 탭을 통해 그동안 작성한 일기들을 조회해보며 지난 한 달을 회고할 수 있었다. |
| (10) 기타 | . |

 
[Return TOP](#list-of-teamsprojects)
 
# Team-22
| (1) 과제명 | Fairy Tairy : 동화같은 그림을 자동으로 생성해주는 AI 일기 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 22-쓰리박 |
| (3) 팀원 역할 분담 | 박은주(2028014) : 리더, AI, 프론트엔드<br>박민경(2117016): 프론트엔, 백엔드, 데이터베이스 관리, 서버 배포<br>박윤서(2171086): 프론트엔드, 백엔드 |
| (4) 팀 지도교수 | 민동보 |
| (5) 팀 멘토 | 강수남 / 모두의주차장 / 대표 |
| (6) 과제 키워드(keywords) | 자기 표현 글쓰기, 감정과 상황의 공감각화, 사회적 연결감 형성 |
| (7) 과제 내용 요약 | 바쁘게 살아가는 현대사회 속에서 자신의 하루를 되짚어 볼 여유가 없는 현대인들은 스트레스 관리에 취약합니다. <br>따라서 그들은 일기를 통해 자신의 하루를 기록함으로써 자신의 감정이나 생각을 정리하며 스트레스를 해소하곤 합니다.<br>저희는 그들이 보다 흥미롭게 일상 기록을 할 수 있도록  일기를 쓰면 코멘트와 함께 동화 같은 그림 일기를 자동으로 그려주는 서비스를 제공하고자 합니다.  |
| (8-1) 과제: 문제의 정의 | 적당한 스트레스는 일상생활에 도움이 되기도 하지만, 과도한 스트레스는 일상생활에 지장을 주며, 정신 건강을 해치는 요인이 된다.통계청에 따르면 2022년 11월 기준 우리나라 국민의 약 45퍼센트가 일상생활 전반에 걸쳐 스트레스를 느낀다 인지한다 답했다. 한편 코로나 이후 MZ세대의 새로운 건강 관리 트렌드로 헬시 플레저 트렌드가 자리잡고 있다. 이는 규칙적인 일상생활 속 루틴을 통해 신체 건강과, 그의 연장선 상으로 멘탈관리까지 하고자 하는 건강 관리 방법이다. 이런 이유로 20대의 경우 멘탈 관리를 위해 전문가의 도움을 받고 싶다 응답한 비율은 전체의 70퍼센트에 해당될 정도로 스트레스 관리와 멘탈 건강을 챙기는 것에 적극적이지만, 실제 관련 서비스를 받은 인원은 약 6퍼센트에 불과하다. 그 이유로 여전한 사회적 편견이 큰 역할을 하고 있으며, 추가적으로 일반 진료보다 초진 비용과 상담 비용이 높아 경제력이 약한 20대에게 부담이 된다는 점 역시 크게 작용하고 있다. 이런 점에서 질환이 되기 전 스트레스를 관리할 수 있도록 하는 예방적 관점의 중요성이 크다 |
| (8-2) 과제: 기존연구와의 비교 | [관련 서비스 조사]<br>1. 오늘 하루를 그려줘<br>pros: 사용자가 하루의 기분에 대한 키워드를 선택해 하루의 감정을 한눈에 볼 수 있게 한다.<br>cons: 생성 그림은 내용과 관계 없이 키워드만으로 결정되며 단순 일기 작성과 그림 생성 이외의 다른 기능이 없다.<br>2. Reflectly<br>pros: 질문을 통해 사용자의 하루 기분 파악. 사진 업로드 가능. 하루 activity, feeling에 대한 키워드를 수집. 하루의 기분에 대한 up/down 추이를 그래프로 보여줌.<br>cons: 직관적이지 않은 UI, 개인화 서비스 및 커뮤니티 기능이 존재하지 않아 서비스 사용 동기 상실<br>3. 무드 메모<br>pros: 사진 업로드 가능. 한 눈에 사용자의 mood를 주 단위로 확인할 수 있음<br>cons: 짧은 메모를 통해 일기를 생성하므로 내용이 한정적. 사용자가 기록하지 않은 부분에 대해서 임의로 채워 넣는 할루시네이션 발생함.<br>4. Headspace<br>pros: monthly/weekly checin 시스템을 통해 사용자의 스트레스와 분노 정도를 분석, tracking한다. 아침, 점심, 저녁, 수면 시간에 맞는 간단한 명상, 음악 컨텐츠를 추천하여 스트레스 관리를 돕는데 중점을 두고 있음. 명상 테마를 다양하게 구성하여 course를 따라갈 수 있도록 함.<br>cons: daily 서비스 없음. 개인화 서비스 없음.<br><br>[키파인딩과 인사이트]<br>글쓰기: 사용자가 직접 쓰는 일기를 통한 자기 표현적 글쓰기 유도. 스트레스 완화를 위한 일차적인 방법으로 자기 표현적 글쓰기를 유도하는 방식이 실제로 많이 사용되며, 효과적인 방식임을 알 수 있음.<br>개인화: 사용자에 따라 알맞는 서비스를 제공할 필요가 있음. course제공 보다는 개인의 경험(일기)에 집중하여 스트레스 완화 수단을 제공하는 방식이 필요해보임<br>시각화: 한달 혹은 한 주의 mood를 시각적으로 바로 확인할 수 있어야 함. 일기의 경우 비정형화된 형식이므로, 글 보다는 그림이나 다른 방식으로 한 눈에 간편하게 기록을 확인할 수 있도록 해야함.<br>커뮤니티: 소셜 서비스를 통하여 개인의 경험을 자유롭게 공유할 수 있도록 하는 서비스가 없음 |
| (8-3) 과제: 제안 내용 | 위와 같은 문제를 해결하기 위해 일기 작성을 통한 사용자의 자기 표현적 글쓰기를 유도하여 스트레스를 스스로 완화 할 수 있도록 유도하는 서비스를 제공한다. 일기 내용을 통해 감정 키워드를 얻고 응원 문구를 생성한다. 얻은 키워드를 바탕으로 사용자의 감정에 맞는 음악 추천 재생. 또한 사회적 연결감 형성을 위해 커뮤니티 기능을 통해 일상 공유를 가능케 한다. |
| (8-4) 과제: 과제의 주요 기능 | 동화같은 그림 생성 : Diffusion Model을 활용하여 사용자가 작성한 일기를 기반으로 그림 일기를 생성해줍니다.<br><br>코멘트 생성 : KoGPT2모델을 활용하여 사용자가 작성한 일기 내용에 대한 코멘트를 달아줍니다. <br><br>감정 기반 음악 추천 : KoBERT모델을 통하여 다중 감정 분류를 진행한 결과를 <br>기반으로 사용자 감정과 유사한 음악을 추천해줍니다. <br><br>일기 공유 : 우리는 종종 우리의 경험을 다른 사람들과 공유하고 싶어한다. 이에 사용자로 하여금 선택적으로 일기를 공유하게 함으로써 서로의 감정과 경험을 공유하며 더 깊은 이해와 연결을 형성하고자 한다. |
| (8-5) 과제: 구현 방법 | [**사용자 감정 기반 음악 추천**]<br>1. 가사에 대한 감정 분석을 진행.<br>2. KoBERT모델에서 추출된 노래 별 감정을 이용하여 사용자의 감정과 가장 유사한 노래를 추천<br>3. 일기 작성 후 사용자 감정 값이 추출이 되면, 노래 영상 별 감정 값과 결합한 뒤 새로운 코사인 유사도를 계산<br>4. 사용자 감정 값과 유사도가 가장 큰 값으로 정렬<br>5. 가장 큰 값의 인덱스와 가장 유사한 노래 4개로 다시 추출하고, 해당 인덱스의 노래 리스트를 결과로 반환 <br>6. 총 5개의 음악 추천 ⇒ 사용자 감정과 가장 유사한 음악 1곡 + 그 음악과 유사한 음악4곡을 추천<br><br>[**프롬프트 엔지니어링**]<br>0. 이미지 생성을 잘 수행해주는 커스텀 프롬프트를 제작하여 해당 프롬프트를 ChatGPT에게 넘겨줌 <br>1. 사용자 일기를 (0번에서 학습된)ChatGPT에게 넘겨줌 →  ChatGPT가 사용자 일기를 기반으로 하는 프롬프트 3개를 생성해줌 (아래와 같이)<br>2. 1번에서 생성된 프롬프트 뒤에, 별개의 프롬프트(트리거 워드)를 붙여서 최종 프롬프트 완성(필요시 , negative prompt 설정) <br>[예시 프롬프트]<br>: (Oil Painting), (Impressionism), oil painting with brushstrokes, bichu,Park stroll:1.4, joyful atmosphere:1.3, laughter-filled time, playful dogs:1.3, vibrant park scene, cheerful interactions, happy pet owners, heartwarming moments, vibrant community vibes <br>3. (파인튜닝한) Diffusion에 프롬프트를 넘겨 이미지 생성<br><br>[**이미지 화풍 변환**]<br>1. CustomDataset 생성 : oil pastel, oil canvas느낌의 데이터셋<br>- BLIP 모델을 활용하여 img2txt 진행 >> (img,txt)쌍의 데이터셋으로 커스텀<br>2. 커스텀 데이터셋을 가지고 FineTuning을 진행한다.<br>3. 이때, LoRA기법을 활용하여 Diffusion 모델에 대해서 화풍 학습시킨다.|
| (8-6) 과제: 세부 기술 | [**사용자 일기 다중 감정 분석**]<br>사용 모델 : KoBERT<br>Dataset : https://aihub.or.kr/aihubdata/data/view.do?currMenu=&topMenu=&aihubDataSe=data&dataSetSn=86<br>많은 BERT 모델 중에서도 KoBERT를 사용한 이유는 "한국어"에 대해 많은 사전 학습이 이루어져 있고, 감정을 분석할 때, 긍정과 부정만으로 분류하는 것이 아닌 다중 분류가 가능한 것이 강점 존재한다. 따라서, 이러한 이유로 KoBERT 모델을 최종 모델로 선택을 하였고, 모델 구조 Customizing 및 FineTuning을 진행하였다.<br>![image](https://github.com/Three-Park/Crayola-Dreams/assets/79118751/20fa1c9b-106c-4ef6-bde7-15164dcdd014) <br><br>[**일기 기반 자동 코멘트 생성**]<br>사용 모델 : KoGPT2<br>Dataset : https://github.com/songys/Chatbot_data <br>KoGPT2 모델은 문장을 "생성"해내는 모델이다. 따라서 일기 내용에 대한 코멘트를 달도록 구현하기 위해 입력 받은 내용에 대해 위로하거나 공감하거나 부드러운 표현으로 반응하고 문장을 생성해내도록 FineTuning을 진행하였다.<br>![image](https://github.com/Three-Park/Crayola-Dreams/assets/79118751/c98495e2-2f9b-4f54-8d83-af7d3f07b0e8)<br><br> [**이미지 화풍 학습**]<br> 사용 모델 : StableDiffusion-v1-5<br>Dataset : https://www.kaggle.com/datasets/herbulaneum/oil-painting-images <br> -해당 데이터셋을 가지고 Img2Text을 수행하여 직접 Custom을 진행하였다. <br> 스테이블 디퓨전 모델은 기본적인 모델을 가지고 있음. (기본 모델은 인터넷에 퍼져 있는 이미지로 학습) 그래서 어떤 스타일인지 알 수가 없다. 타일의 그림을 그릴 것인지는 그 스타일에 맞는 학습모델이 있어야 한다. 이런 학습모델을 CHECKPOINT라고 하고 SAFETENSORS와 CKPT 파일로 제공한다. 해당 서비스에서는 유화와 같은 그림체에 좀 더 편향되게끔 하기 위해서 LoRA를 통해 학습시켰다. <br>- LoRA: 특정 피사체를 좀 더 편향되게 생성할 수 있게 해줌<br>- checkpoint: 이미지 장르, 그림체 같이 넓은 범위에 대한 설정을 위해 사용<br>```prompt : (masterpiece, best quality, ultra detailed), Oil Painting, Impressionism, oil painting with brush strokes, bichu,Park stroll, joyful atmosphere, laughter-filled time, playful dogs, vibrant park scene, cheerful interactions, happy pet owners, heartwarming moments, vibrant community vibes```<br>![image](https://github.com/Three-Park/Fairy-Taiary/assets/79118751/9a774225-5bbc-4622-8a74-6daa7a4e7e0c) |
| (8-7) 과제: 기대 효과 및 의의 |사용자는 일기 작성을 통해 자기 표현적 글쓰기가 가능해진다. 이를 통해 자신의 경험과 생각을 정리하여 자기 인식을 높이고, 인지 재구조화를 가능하게 하여 스트레스를 해소할 수 있게 한다. 또한 일기를 기반으로 생성된 그림은 일상 생활에서 추상적으로 느끼는 감정을 시각적으로 파악할 수 있도록 하여 사용자가 스스로의 감정을 이해할 수 있도록 돕고, 자신의 상황과 감정에 대한 패턴을 발견할 수 있도록 돕는다. 이는 사용자의 스트레스 해소를 통해 예방적 관점에서 정신건강 관리 및 개선에 도움을 줄 수 있을 것이다. |
| (9) 데모 내용 | 1. 일기 내용 작성 시 글의 내용에 적절한 감정과 추천 음악이 결과로 출력된다.<br>2. 그림의 경우 프롬포트를 이용하여 그림 생성 결과까지는 확인하였으나 프론트엔드와 연결은 진행중에 있다.<br>3. 달력 페이지 구현에 성공하였으며, 달력의 해당 날짜에 등록된 일기들이 표시되는 모습까지 구현하였다. |
| (10) 기타 |![image](https://github.com/Three-Park/Fairy-Taiary/assets/79118751/7cda6b7c-841c-476b-9f0e-e2bdca658099)<br>프론트로는 리액트네이티브, 백엔드로는 장고와 넥스트js를 사용하였고, DB로는 mysql과 s3를 사용하였다.<br>**ReactNative** : 컴포넌트 기반의 UI 라이브러리로써, vuejs보다는 높은 자율성을 가지며, 풍성한 생태계를 가지고 있다는 점에서 선택<br>**Django** : MTV 아키텍처를 기반으로 하여 코드의 재사용성이 높고, 손쉽게 인증을 구현할 수 있어 선택<br>**nextjs** : 서버사이드 렌더링을 지원하기 위해서, 빌드 시간을 단축시키고, 빌드된 파일을 캐싱하여 빠른 로딩을 지원하기 위해서 사용<br>**s3** : 이미지 생성 서버와 연결하여 이미지 데이터 저장을 위해 사용<br>**DB** : DB로는 Mysql을 사용하였는데, Mysql은 관계형 데이터베이스로, 데이터를 구조화하여 효율적으로 저장하고 검색하기 위해 선택 <br>**AI** : GPU가 필요한 AI모델의 경우 GCP VM 을 사용하였다. 백엔드에서 일기 내용을 전달하며, 이미지 생성 모델은 이미지를 생성하고 url을 응답하도록 하였다. 또한, 음악 추천모델과 감정분석 모델은 추천과 분류 결과를 응답으로 반환하게끔 구현하였다.|
 
[Return TOP](#list-of-teamsprojects)
 
# Team-23
| (1) 과제명 | Stroke-based Collaborative Drawing between AI and Human
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 23-새우타코 |
| (3) 팀원 역할 분담 | 윤지원(2071032): 팀원, Image completion, UI 개발 및 통합(Human and AI interaction)<br>정세윤(2076371): 팀원, Image completion, Stroke Ordering<br>남지민(2176123): 리더, Image classification |
| (4) 팀 지도교수 | 김영준 교수님 |
| (5) 팀 멘토 | 조민애 / Microsoft / CSA |
| (6) 과제 키워드(keywords) | 협업, drawing, human-like |
| (7) 과제 내용 요약 | Stroke-based Collaborative Drawing between AI and Human은 사람이 그림을 그리면 image completion을 학습한 AI가 다음 획을 예측한 다음 뒤를 이어 미완성된 그림의 일부를 완성합니다. <br>실제 사람이 그리는 것과 비슷한 방식으로 그림을 그리도록 학습된 AI와 사람이 번갈아가며 그림을 그리며 사람과 AI가 협업하여 그림을 완성하게 하는 것을 목표로 합니다. |
| (8-1) 과제: 문제의 정의 | 미완성된 그림을 입력받은 다음 이를 완성하는 Image Completion 연구가 활발히 진행되고 있습니다. 하지만 기존의 연구들은 다음과 같은 부분에서 미흡합니다. <br>첫째, 기존 연구의 완성된 결과물이 사람의 의도를 잘 반영하지 못합니다. 그 이유는 사람에 의한 획의 입력이 처음에 일회성으로만 존재하고, 이후에는 획이 입력되지 않는다는 점 때문입니다. 즉, 단 한 번의 입력으로 결과를 도출하기 때문에 Image Completion 모델이 그림을 제대로 이해하지 못하는 상황을 개선하기 어렵다는 것입니다. <br>둘째, 입력된 그림의 완성도가 낮을수록 Image Completion 결과물의 수준이 낮아집니다. 예를 들어 가려진 부분이 50% 이상인 그림을 기존의 Image Completion 연구 중 하나인 Lmser-pix2seq에 입력하는 경우, 그 결과물은 Image Classification 모델이 분류하기 힘들 뿐만 아니라 사람도 인식하기 힘들게 됩니다.<br>마지막으로, 기존 연구는 그림을 완성하는데 초점이 맞춰져 있어 Human-like drawing을 실현하지 못합니다. Image Completion 모델 내부에서 사람이 그려서 넣은 기존의 그림이나 획이 보존되지 않고 변형될 뿐 아니라, 획의 순서나 그림의 완성된 모습에서 사람이 그리는 경향과는 전혀 다른 모습을 보입니다.<br>따라서 이러한 문제점들을 해결하기 위해 AI와 사람의 협업을 Image Completion에 도입할 것을 제안하는 바이며, 이를 통해 사람의 의도와 창의성이 반영된, 보다 나은 그림을 완성할 수 있도록 할 것입니다. |
| (8-2) 과제: 기존연구와의 비교 | Image Completion 모델을 개선하기 위해 기존에 존재하지 않았던 방향으로 AI와 인간과 협업이 가능하다는 것을 보이고자 합니다. 이를 구현하기 위해서 두가지 연구를 참고했습니다.<br> 1. Image Completion : Lmser-pix2seq: Learning stable sketch representations for sketch healing. <br> 해당 연구는 주어진 그림의 일부분을 가려서 masking 된 부분의 그림을 채워서 그리는 모델을 학습시켰습니다. 하지만 그림을 가리는 비율이 높아질 수록 output으로 나오는 그림의 완성도가 떨어지는 문제점이 있습니다. 특히 이 비율이 50% 이상이 되면 evaluation의 의미가 없어질 정도로 그림을 알아보기 어려워집니다. 또한 인간이 그리던 그림을 완성시키는 것이 아닌 랜덤한 masking을 통해 학습했기 때문에 사람이 그림을 그리는 방식과는 동떨어진 채로, 그림을 완성시키는 것에만 기능이 집중되어 있습니다.<br> 저희의 연구는 Lmser의 단점들을 보완할 것 입니다. 50% 이상 masking(그림을 가린다는 의미)을 할 경우에도 높은 성능으로 그림을 완성할 것이며, 사람이 그림을 그리는 방식으로 인공지능과 인간이 협업하게 할 것입니다. 이 때, 사람이 그림을 그리는 방식이란, 사람처럼 그림을 그린다는 의미로, 무작위로 그리는 것이 아닌, 일정한 규칙에 따라 그림을 그리는 것을 의미합니다. 저희는 사람이 마지막으로 펜을 뗀 곳과 가장 가까운 곳으로 부터 그림을 그리며, human-like drawing을 구현하고자 합니다. <br> 2.  Image to Stroke converter : Content Masked Loss: Human-Like Brush Stroke Planning in a Reinforcement Learning Painting Agent <br> Content Masked Loss는 사진이나 그림을 획 기반 그림으로 재구성하는 AI 모델으로, 강화학습을 통해 사람이 그림을 그리는 방식처럼 획의 순서를 정하도록 학습되었습니다. 하지만 직접 그림을 그리거나, 그려진 그림의 일부분을 완성하는 것이 아니라 기존에 완성된 이미지를 획 기반으로 재구성하는 모델입니다. 저희는 Content Masked Loss의 단점인 그림을 완성하지 못한다는 점을 개선할 것입니다. 구체적으로, 인간과 인공지능이 함께 사람처럼 그림을 그림으로써, Content Masked Loss의 장점은 보존하고 단점은 개선할 것입니다. |
| (8-3) 과제: 제안 내용 | 기존의 ai-drawing과 관련된 모든 연구들은 사람과의 상호작용을 염두에 두지 않고 있습니다. 나아가, 이미지를 완성시킬 수 있는 연구들은, 사람처럼 그리지 못한다는 단점이 존재합니다. 획을 기반으로 그림을 완성하는 연구들은, 그림을 재구성할 뿐, 그림을 완성시키지는 못합니다. 또한, 이미지가 50%이상 가려질 경우, 이미지가 성공적으로 완성되지 못하는 문제점이 있었습니다. (여기서 성공적이지 못하다는 의미는 이미지 분류 모델을 통해 제대로 분류가 되지 않는 것을 의미합니다.) <br> 위 문제를 해결하기 위해  Stroke-based Collaborative Drawing between AI and Human이라는 연구 주제를 제안하는 바입니다. <br> 저희는, Image completion 모델을 이용하여 해당 모델이 중간 중간 사람의 입력(사람이 그림의 일부를 그려주는 것)을 받는 협업 과정을 통해 보다 높은 수준의 그림을 완성할 수 있도록 개선하고자 합니다. 높은 수준의 그림이란, 초반 masking의 정도와 상관없이(처음에 사람이 전체 그림의 몇 %를 그렸는지와 상관없이) 이미지를 완성할 수 있는 것을 의미합니다. 또한 생성된 획 중 일부분을 선택하는 과정에서 Stroke Ordering 알고리즘(사람이 마지막으로 그린 점과 가장 가까운 획을 선택하는 알고리즘)을 이용하여, 인공지능 모델이 그리는 그림이 human-like할 수 있도록 하고자 합니다.<br> 성공적인 연구를 판단하기 위하여 두가지 evaluation point(평가 방법)을 제안합니다.<br>첫째, masking의 정도(사람이 입력으로 전체 그림의 몇%를 그렸는지)와 관계없이 높은 수준의 그림이 완성되는지 확인할 것입니다. masking의 정도를 10%, 20% 부터 90%까지 분포시키며, 그림의 완성도를 판단할 것입니다. 이 때 그림의 완성도는 이미지 분류 모델에 넣어 제대로 판단하는지 정확도를 확인할 것 입니다. <br>둘째, 최종적으로 완성된 그림이 원래 사람의 의도와 얼마나 일치하는지 확인할 것입니다. 이 과정에서 이미지 분류 모델을 활용하여 인공지능이 그림이 제대로 인식하는지 확인할 것입니다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 사람이 그린 획을 인식하고 전처리 과정과 모델과의 연결을 위한 UI<br>2. 그림의 일부분을 사람처럼 그리며 이미지를 완성하는 모델(Image Completion Model)<br>3. 완성된 이미지의 획 중 획 중요도를 예측하여 선택하는 기능(Stroke Ordering Algorithm) |
| (8-5) 과제: 구현 방법 | 전체적인 시스템 흐름은 다음과 같습니다. <br> 우선, 사람이 임의의 한 획 및 몇 개의 획을 UI에 그립니다. (이 때, 획의 길이나 획이 그림에서 차지하는 비중은 프로젝트의 완성과 무관하여 아무렇게나 그리면 됩니다.) 사람의 획을 인식한 UI가 모델에게 데이터를 넘겨줍니다. 이 때, 모델이 넘겨받은 데이터를 통해 어떤 그림인지 사용자의 의도를 파악하고, 파악한 의도를 바탕으로 그림이 덜 그려진 부분 중 일부를 완성합니다. 이 과정에서 이미지 완성 기술이 적용됩니다. 그 결과를 다시 UI에게 전해주고, 화면에 나타난 일부 완성본을 사람이 전달받아, 또 일부분의 그림을 사람이 완성합니다. 이런 과정의 반복을 통해 사람과 인공지능이 협업합니다.<br>기존의 연구와 달리 Image Completion의 완성도를 높이고자 사람과의 interaction을 위한 1) 자체 UI를 이용하습니다. UI를 통해 사람과 그림의 일부를 완성해주는 모델이 상호작용 할 수 있습니다. UI를 통해 상호작용하는 모델은 크게 2) Image Completion과 3) Stroke Ordering으로 나누어 구현하였습니다. <br> 사람이 그린 일부의 그림을 1) UI가 모델에 전달하면, 2) Image Completion 모델이 미완성된 이미지 전체를 완성합니다. 이후, 해당 결과를 3) Stroke-Ordering을 통해 받아 전체 획 중 어떤 획을 그릴 지 선택하고 이를 1) UI에 다시 그립니다. 이런 일련의 과정을 여러번 반복하여 최종적으로 인간의 개입을 반영한 이미지를 완성하게 됩니다. <br> ![User Interface](https://github.com/JiWon0502/StrokeCollaborativeDrawing/assets/10348029/6b661450-55a9-4ba4-93eb-9df808eca990) |
| (8-6) 과제: 세부 기술 | <br> 1. UI에 필요한 기술 <br> - UI에 필요한 요구사항은 UI를 구성할 화면 구성요소가 필요합니다. 나아가, 요구사항에서 설명한 것과 같이, RDP 알고리즘을 사용해 획을 전처리 해야하며, 전처리 된 획을 .npz파일로 저장할 수 있어야합니다. 이런 요구사항을 만족시키기 위해 아래의 기술들이 필요합니다.<br> - 전반적인 GUI(Graphic User Interface)를 정의하기 위해 python 기본 모듈인 Tkinter를 사용했습니다. <br> - 사람이 입력한 데이터를 인공지능 모델에 전달해야하는데, 이 때 모델은 입출력 데이터가 NPY(NumPy array), NPZ(NumPy array 압축 파일)형태로 저장되어있습니다. 따라서, 사람의 입력과 모델의 입출력 형식을 맞추고자 NumPy를 사용하였습니다. 구체적으로 GUI를 통해 입력된 데이터를 파일 형태로 저장하고 불러와서 읽는 과정에서 사용했습니다. <br> - RDP algorithm, 또는 Ramer–Douglas–Peucker algorithm으로 불리는 선형 단순화 알고리즘을 사용하였습니다. 이 알고리즘은 곡선의 특징점만 남겨두고 형상을 단순화 시키는 알고리즘으로, 사용자 입력을 기존 모델에 입력되던 데이터 형식과 동일하게 전처리하기 위해 새롭게 구현했습니다. 기존 모델에서 데이터 전처리를 위해 epsilon 값을 2.0으로 두고 전처리를 진행하므로, 새롭게 입력되는 데이터에 대해서도 동일하게 전처리를 진행 할 수 있도록 구현하였습니다.<br> <br> 2. Image Completion 모델로 사용한 기술 <br> - Image Completion을 수행하기 위해 Lmser pix2seq를 사용했습니다. Lmser pix2seq는 AutoEncoder 구조의 모델로 Quick, Draw! 데이터셋을 자체적으로 마스킹 한 다음 마스킹 된 부분을 예측함으로써 Image Completion을 수행합니다. Lmser pix2seq에 입력된 데이터는 Lmser Block Encoder와 RNN Decoder를 거치는데 Lmser Block Encoder는 입력 데이터의 중요한 특징을 추출한 다음 이를 latent vector인 z로 압축합니다. 이후, z는 RNN Decoder를 통해 입력 데이터와 동일한 형태로 복원되며 그 결과 하나의 그림이 완성됩니다. 이때, Lmser pix2seq의 결과는 .jpg 파일로 저장되는데 이는 획 기반으로 그림을 완성하고자 하는 본 연구의 목적과 상충됩니다. 따라서 Lmser pix2seq의 inference.py를 수정하여 결과를 (dx, dy, pen_state) 형태의 .npz 파일로 저장하였습니다. 또한, Lmser pix2seq가 자체적으로 마스킹한 Quick, Draw! 데이터셋을 입력받는 대신 사람이 UI를 통해 그린 그림을 입력받을 수 있도록 inference.py와 hyper_params.py를 수정하였습니다.<br> <br> 3. Stroke Ordering을 위해 사용한 기술 <br> - 정렬되지 않은 상태의 배열에서 가장 작은 값을 찾기 위해 배열을 순차적으로 탐색해 나아가는 선형 탐색 알고리즘을 통해 획이 끝나는 지점과 가장 가까운 획을 선택합니다. |
| (8-7) 과제: 기대 효과 및 의의 | 사람과 인공지능의 상호작용을 염두해 둔 최초의 ai-drawing 연구로, 사람의 개입을 통해 Image Completion의 완성도를 높이기 위한 연구입니다. 나아가, 일정 수준 이상 이미지가 가려질 경우 성공적으로 그림을 완성하지 못한다는 기존 연구의 한계를 인간의 개입을 통해 해결하고, 결과로 나오는 그림의 완성도를 증진시키는 것이 주 목적입니다. 추가로 인공지능이 그림을 그림에 있어, 좀 더 인간과 유사한 방식으로 그림을 그릴 수 있다는 장점이 있습니다. <br> 기존의 연구들은 완성된 결과물이 사람의 의도를 잘 반영하지 못하며, 입력된 그림의 완성도가 낮을수록 Image Completion 결과물의 수준이 낮아진다는 문제가 있습니다. 이 연구를 통해 해당 문제점을 모두 해결할 수 있으며, Human-AI interaction 또한 효과적으로 실현할 수 있습니다. |
| (9) 데모 내용 | 1) 연구자가 n개의 획으로 그림을 그리고 버튼을 누릅니다.<br> 2) RDP알고리즘(선형단순화알고리즘)으로 전처리된 그림이 출력됩니다.<br> 3) 버튼을 누르면 Image Completion 모델이 n개의 획을 추가합니다. <br> 4) 1~3을 반복해서 그림을 완성하는 과정을 데모하고, 완성 시 종료 버튼을 누릅니다.<br> 5) 완성된 그림과 완성까지 이르는 과정을 보여주고 완전히 종료합니다.  |
| (10) 기타 | 데모 영상 : (https://drive.google.com/file/d/1lPhBj8d5Sasj5tOheVEhXQDT0RgIRJZ1/view?usp=share_link) <br>  github link : (https://github.com/JiWon0502/StrokeCollaborativeDrawing.git) |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-24
| (1) 과제명 | Grounding Dino를 활용한 객체 탐지 기반 CCTV 속 흉기 난동 상황 모니터링 SDK
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 24-망고젤리 |
| (3) 팀원 역할 분담 | 류성경(2076122): 리더, 데모용 어플리케이션 프론트엔드 개발, 클라우드 컴퓨팅 환경 구성<br>박나희(1994046): 팀원, Grounding DINO 파인튜닝, Fast API 맵핑, SDK 위치추적 기능 구현 <br>김리나(2176046): 팀원, 데모용 어플리케이션 백엔드 개발, SDK 알림 기능 구현 |
| (4) 팀 지도교수 | 심재형 |
| (5) 팀 멘토 | 이다은 / 카카오브레인 / Software Engineer |
| (6) 과제 키워드(keywords) | 흉기 감지, 보편성, 실시간 |
| (7) 과제 내용 요약 | CCTV 관리자가 볼 수 있는 Web 환경에서 값비싼 고성능 카메라 영상이 아닌, 보편적으로 사용하고 있는 CCTV의 저화질 영상에 대해 Grounding Dino를 이용한 실시간 객체 탐지 기술을 기반으로 환경을 모니터링하고 흉기 난동 발생 여부를 판단한다. 그 결과 사용자 위치 주변에서 흉기 난동이 발생했다면 사용자 기기의 APP에 알림을 보내주는 위치 탐색 기능과 알림 전송 기능을 포함한 SDK를 개발한다.<br><br>(해당 과제에서 흉기는 경찰청 범죄 통계를 기반으로 총기, 돌, 칼, 몽둥이, 도끼, 낫, 공구, 유리병 총 8종으로 정의했다.)  |
| (8-1) 과제: 문제의 정의 | 1. 사람이 발견 후 신고<br>일상 생활에서 흉기 난동 사건 발생 시, 사람이 직접 발견하고 신고하지 않는 이상 빠르게 대처하기 힘들며, 사람이 발견하고 신고하였을 때에는 이미 상황이 크게 진척되어 피해자가 여럿 발생한 경우가 많다. <br><br> 2. 경찰 인력 배치<br>경찰 인력 배치를 통해 현장을 경비하는 방법은 시민에게 위화감을 조성하고, 많은 시간과 비용이 발생한다.<br><br> 3. 고가의 PTZ 카메라<br> 고성능 카메라(e.g.PTZ 카메라) 설치를 통해 흉기를 감지하거나 AI 모델을 올리기 위해 기타 고성능 카메라로 CCTV 기기를 교체하기도 하는데, 카메라 자체도 고가일 뿐 아니라 별도의 하드웨어 장치도 필요하여 보편적으로 쓰이기는 어려운 실정이다. |
| (8-2) 과제: 기존연구와의 비교 | 1. PTZ CCTV 카메라와 같은 고화질 카메라에 한해서만 제공되는 솔루션<br>기존 시장에는 피사체를 자동 추적하는 PTZ 카메라(Pan Tilt Zoom 카메라, 원격으로 회전, 줌 조정이 가능한 카메라)를 활용해 흉기 소지를 확인해 위험 상황을 알려 주는 솔루션이 존재한다.<br><br>강점 : PTZ 카메라는 배회하는 사람의 신원을 확인할 수 있을 정도로 줌을 확대해 추적하기 때문에 정확히 손에 들고 있는 소지품이 흉기인지 여부를 확인할 수 있을 정도로 고화질의 데이터를 제공한다.<br>단점 :일반적으로 실내에서 보편적으로 사용하는 CCTV인 돔카메라에 비해 약 15배의 가격으로 매우 고가이며, 성능 좋은 추가적인 하드웨어 장치가 추가적으로 필요하기 때문에 PTZ 카메라에 대해 제공되는 솔루션은 보편적으로 적용할 할 수 없다고 판단했다.<br>(참고 기사 : https://www.boannews.com/media/view.asp?idx=122013)<br><br>2. AI 솔루션을 사용하기 위해 CCTV를 교체하고 있는 상황<br>하단 영상은 수원시에서 폐쇄 회로 CCTV를 지능형으로 전환해 인공지능(AI) 기반으로 흉기 난동을 판단하고 있다는 내용이다. 이 경우를 포함해 많은 객체 탐지 기반 솔루션들이 CCTV를 더 나은 기기로 교체하고, 그 위에 개발한 모델을 올리는 것을 문제 해결 방법으로 채택하고 있다.<br><br>강점 : 이 경우 CCTV 자체를 더 좋은 모델로 바꾸는 것이기에 고화질의 데이터로 조금 더 정확한 탐지가 가능하다는 장점이 있다.<br>단점 : 하지만 기존에 존재하는 CCTV를 고가의 CCTV 장비로 바꾸는 것은 상당한 비용이 추가되기에 보편적으로 적용될 수 있는 솔루션이라고 보기 어렵다고 판단했다.<br>(참고 기사 :https://www.youtube.com/watch?v=ZxMkZJGaRFE) |
| (8-3) 과제: 제안 내용 | PTZ 카메라 같은 특수한 장치가 있지 않더라도 저화질 일반 CCTV 영상에서 Object Detection 기술을 통해 흉기 난동 사건 의심 정황을 탐지할 수 있는 솔루션을 제안한다. 이 과정에서 아직 프로덕션 레벨에서는 쓰인 적이 없는 최신의 Object Detection 모델인 Grounding Dino를 도입해 볼 예정이며, 저화질 영상 데이터에서 이상 상황을 빠르고 정확하게 탐지하는 것을 우선적인 목표로 개발을 진행할 예정이다. <br><br>1. SDK 사용<br>SDK(Software Development Kit - 개발자를 위한 플랫폼별 구축 도구 세트) 형태로 개발을 할 예정이므로, 이를 사용하여 기존 CCTV 시스템에 간편하게 적용 가능하며, 불필요한 하드웨어 투자 없이 흉기 난동 및 안전 상황을 모니터링할 수 있다.<br>2. 사용자 위치 정보 기반 푸시 알림<br>사용자의 위치 정보를 활용하여 가까운 곳에서 흉기 난동 상황 발생시 사용자에게 푸시 알림을 보내고 신속하게 대응할 수 있다.<br><br>SDK 타겟층 <br>: 실시간 CCTV 데이터를 갖고 있고, 흉기난동 예방에 관심을 갖는 기관 (ex. 경찰, 지하철공사 등)<br><br>a. CCTV 관리자 및 기관 입장<br>흉기 난동 사건 발생을 더 빨리 지각할 수 있으며, 빠른 대처가 가능하다.<br>b. 일반 시민 입장<br>푸시 알림을 통해 실시간으로 빠르게 주변 흉기난동 발생 여부를 알고 이에 대처하여 안전 확보가 가능하다 |
| (8-4) 과제: 과제의 주요 기능 | 일반 저화질 CCTV 영상에 대해 실시간 흉기 난동 상황 탐지 및 알림 제공 <br><br>1. 흉기 난동 상황 탐지를 위한 Grounding Dino 모델 파인튜닝 및 REST API 개발 <br>2. 사용자의 위치 정보를 받아, 해당 위치 주변에서 흉기 난동 상황이 탐지 되었을 때 푸시알림을 보내는 API 개발<br>3. 해당 API를 이용하기 위한 SDK 인터페이스 개발<br>4. 우리의 SDK를 이용한 웹/앱 데모 서비스 개발 |
| (8-5) 과제: 구현 방법 | 1. 모델 서버 - 흉기난동 탐지 : Grounding Dino<br>- 기존에 자주 쓰이는 Yolo 모델이 아닌 Grounding Dino를 활용하여 객체 탐지를 진행한다.<br>- Zero-shot Detection을 통해 기존에 학습된 데이터셋 없이도 객체 탐지를 할 수 있고, 맥락을 통한 판단이 가능하다는 특징이 있는 Grounding Dino를 파인튜닝 및 파라미터 조정하여 실시간 CCTV 영상에 대해 객체 탐지를 진행한다.<br>- 흉기 모음 데이터셋과 흉기난동과 유사한 영상을 Grounding Dino에 학습시키고, 이를 Fast API로 래핑하고 Spring API와 연결하여 프로덕션 레벨에서 사용하려 한다.<br>- 이렇게 만들어진 FAST API는 API 서버에 흉기난동이 발생했는지 안했는지 여부를 전송하여 흉기난동 발생을 알리는 시발점의 역할을 한다.<br><br>2. API 서버 : Spring Boot<br>- Spring Boot를 사용하여 Back-end 서버를 구축한다.<br>- 구축된 Back-end 서버가 모델 서버로부터 흉기난동 발생 여부에 대한 response를 받으면 이를 Web client(3번)에게 보내고, web client에서 푸시 알림 요청을 받으면 모바일 client로 푸시 알림 트리거를 보내 해당 푸시 알림을 본 사용자가 빠르게 상황에 대피할 수 있도록 한다.<br><br>3. (Peace Watcher SDK를 적용한) Web 어플리케이션 (CCTV 관리자용) : Next.js, Typescript<br>- Next.js를 이용하여 CCTV 관리자용 Web 프로그램을 개발한다.<br>- REST API를 이용하여 API 서버와 통신하여 흉기난동 여부 정보를 받고, 실시간 CCTV 영상 객체 탐지 Output를 받아 영상을 스트리밍하기 위해 모델 서버와 통신한다.<br>- 소켓 프로그래밍을 통해 Web client는 소켓을 계속 열어두고 실시간으로 모델 API에서 들어오는 영상 Output을 화면에 스트리밍한다.<br><br>4. (Peace Watcher SDK를 적용한) 모바일 어플리케이션 (사용자용) : React.js를 이용한 Progressive Web App, Typescript<br>- 해당 서비스는 공익적인 B2B 서비스로 고안했기에, 모바일 어플리케이션은 해당 솔루션을 구매한 기관의 모바일 어플리케이션이라고 할 수 있다. (ex. 경찰에서 운영하는 안정 Dream 어플리케이션 등)<br>- 빠른 구현을 위해 웹앱(Progressive Web App)으로 어플리케이션을 개발한다.<br><br>5. 기타 인프라<br>- AWS EC2 : Spring API 서버를 AWS EC2를 통해 배포한다.<br>- Heroku CLI : Grounding Dino 모델의 FAST API 어플리케이션을 배포한다.<br>- Google Colab : Grounding Dino 파라미터 조정 및 튜닝에 이용한다.<br>- FCM (Firebase Cloud Messaging) : 모바일 어플리케이션의 푸시 알림을 구현한다.<br>- Vercel : Web 어플리케이션 및 모바일 어플리케이션을 배포한다.<br><br>![전체 프레임 (2)](https://github.com/ri-naa/Data-Structure/assets/121746871/1c11ef72-0490-4184-8103-6d0af96bbc19)|
| (8-6) 과제: 세부 기술 | 1. 흉기 감지 (object detection)<br><br>사용 기술 : <br>- Grounding Dino, Python<br><br>기술 적용 가능성 검증 :<br>Grounding Dino는 Zero-Shot Object Detection을 수행하기 위한 기술이며, 학습 데이터에 해당 클래스에 대한 레이블이 없는 상태에서 새로운 클래스에 대해 모델이 작동하는 능력을 의미한다. 일반적으로 Object Detection은 학습된 모델을 사용하여 annotated된 데이터에 대한 탐지를 수행하지만, Grounding Dino와 같은 Zero-Shot Object Detection 모델은 새로운 클래스에 대한 annotated 데이터가 없어도 객체 탐지가 가능하다. 이 모델을 흉기를 감지하는 데에 사용하고 있으며, 파인튜닝을 통해 모델의 정확도를 높일 수 있다. 또한 파라미터 조정을 통해 흉기를 보다 효과적으로 탐지할 수 있다.<br><br>2. 데모 웹 / 앱<br><br>사용 기술 :<br>- 프론트엔드 : Typescript, React.js, Next.js<br>- 백엔드 : Java, Spring boot<br>- 인프라 : AWS EC2, Heroku CLI, Google Colab, FCM, Vercel<br><br>기술 적용 가능성 검증 :<br>- 웹 프론트엔드 : Typescript와 React.js를 사용하여 CCTV 관리자가 사용할 데모 웹 페이지를 개발한다. 이를 통해 흉기가 감지되었을 경우 팝업 창을 띄우며, 앱 사용자들에게 푸시 알림을 보낼지 수동으로 선택한다.<br>- 앱 프론트엔드 : Typescript와 Next.js를 사용하여 일반 사용자가 사용할 Progressive Web App을 개발한다. 이를 통해 현재 위치를 기반으로 CCTV 장소의 2km 이내에 있을 경우 푸시 알림을 전송한다.<br>- 백엔드 : Java와 Spring Boot를 사용하여 백엔드 서버를 개발한다. 이를 통해 흉기가 감지되어 웹 프론트엔드로부터 알림을 받을 경우, 앱 프론트엔드와 통신하여 어플리케이션 사용자에게 알림을 주는 기능을 개발한다.<br>- AWS EC2 : Spring API 서버를 AWS EC2를 통해 배포한다.<br>- Heroku CLI : Grounding Dino 모델의 FAST API 어플리케이션을 배포한다.<br>- Google Colab : Grounding Dino 파라미터 조정 및 튜닝에 이용한다.<br>- FCM (Firebase Cloud Messaging) : 모바일 어플리케이션의 푸시 알림을 구현한다.<br>- Vercel : Web 어플리케이션 및 모바일 어플리케이션을 배포한다.|
| (8-7) 과제: 기대 효과 및 의의 | 흉기 난동 상황에 대한 빠른 대응을 통해 사고 및 피해를 최소화 할 수 있으며 범죄 및 재난 상황 모니터링에 드는 비용을 절감할 수 있다.<br><br>- 유연성: SDK 형태로 제공되기 때문에 고객은 기존 CCTV 시스템에 손쉽게 통합할 수 있으며, 불필요한 하드웨어 투자 없이 흉기 난동 및 안전 상황을 모니터링할 수 있으므로 적은 비용으로 흉기 난동 모니터링의 높은 효율을 기대할 수 있다.<br>- 실시간성: 사용자의 위치 정보를 활용하여 가까운 곳에서 흉기가 감지되었을 때 사용자에게 실시간으로 알림을 제공하여 신속하게 대응할 수 있도록 함으로써 흉기 난동으로 인한 2차 피해를 감소하는 효과를 기대할 수 있다.|
| (9) 데모 내용 |  *경찰청에서 시민 안전을 위해 운영하는 안전 Dream 앱에서 Peace Watcher SDK를 적용했다고 가정하여 데모를 진행한다. <br><br>Peace Watcher SDK를 적용한 APP 어플리케이션 데모(안전 Dream 앱)<br><br>1. 처음 어플에 접속한 사용자는 위치 정보 제공에 동의하고 푸시 알림을 허용한다.<br>2. CCTV 관리자가 CCTV 관리자 웹에서 흉기 난동 발생 푸시 알림을 보낸 경우 사용자 어플리케이션으로 흉기 난동 발생을 알리는 푸시 알림이 도착하고, 이를 본 사용자는 빠르게 대피할 수 있다.<br>Peace Watcher SDK를 적용한 CCTV 관리자 웹 데모<br><br>1. CCTV 관리자는 처음에 CCTV들을 우리의 서비스와 통합하는 과정을 거친다. CCTV 영상들을 어드민 사이트에 등록하여 CCTV의 위치, id, 실시간 영상을 연결한다. 이때, 정보처리 방침을 통해 해당 영상데이터는 전부 암호화되지만 위험 알림이 떴을 때에는 Peace Watcher SDK가 적용된 어플로 연동된다는 내용을 담는다. <br>2. CCTV 영상이 송출되고, 흉기 난동을 지속적으로 탐지하다가 흉기 난동이 발생한 것으로 감지되었을 때 "(Peace Watcher를 적용한) 어플로 알림을 전송하시겠습니까?" Alert이 뜬다.<br>- 이때 아무것도 선택하지 않으면 5초 뒤에 자동으로 창이 닫히고, 해당 CCTV 반경 2km 내의 앱 사용자들에게 알람이 간다.<br>- 이때 알람 보내기를 클릭하면 해당 CCTV 반경 2km 내의 앱 사용자들에게 알람이 간다.<br>- 모델의 오류로 알람이 갈 만한 상황이 아닌데 Alert이 떴다면,CCTV 관리자가 직접 취소 버튼을 클릭하면 알람이 가지 않는다. <br><br>![Group 38052](https://github.com/ri-naa/Data-Structure/assets/121746871/04b3481c-5c7b-4d65-a468-7ba511b6e0c2)|
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-25
| (1) 과제명 | DotheReco: 스케줄 추천 및 일정 관리 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 25-S |
| (3) 팀원 역할 분담 | 이예은(2076316): 리더, 백엔드 서버 프로그래밍, 알고리즘<br>김지후(2176104):팀원, 백엔드 서버 프로그래밍, DB, AWS 인터페이스<br>전재은(2076362):팀원, UI/UX 디자인 및 프로그래밍 |
| (4) 팀 지도교수 | 윤명국 |
| (5) 팀 멘토 | 도성주 / Google Germany / Software engineer |
| (6) 과제 키워드(keywords) | 일정 처리 순서 추천, 시간대 추천, 일정 관리 |
| (7) 과제 내용 요약 | 현대 사회의 대학생들은 과제, 아르바이트 등 다양한 유형의 스케줄을 동시에 소화하고 있다. 바쁜 일정을 소화함과 동시에 스스로 일정을 관리하고 조율하기엔 큰 어려움이 있다. 따라서 본 프로젝트는 일정 관리가 어려운 대학생들을 위해 일정을 관리해 주고 최적의 스케줄을 추천해주는 것을 목표로 하고 있다. 스케줄의 마감기한, 중요도, 소요시간, 동선을 고려하여 짜여진 최적의 스케줄을 바탕으로 사용자들은 체계적으로 배치된 일정 속에서 효율적인 하루를 보낼 수 있다. |
| (8-1) 과제: 문제의 정의 | 현대 사회의 대학생들은 다양한 유형의 스케줄을 소화하고 있다. 이에 스스로 일정을 관리하고 조율해야 한다는 어려움이 있다. 본 프로젝트를 통해 해결하고자 하는 세부적인 문제점들은 다음과 같다. <br>첫째, 남는 시간들 중에 언제, 어떤 일정을 처리할지 할 일들의 처리 순서를 정하는 것이 어렵다. 둘째, 해야 할 일들 사이에 장소의 이동이 필요한 경우 동선을 짜는 것이 어렵다. 셋째, 새로운 일정을 추가할 때, 내 스케줄 중 비는 시간대가 언제인지 찾는 것이 어렵다.<br>이러한 문제를 해결하기 위해 시중에는 여러 일정관리 서비스가 존재한다. 그러나, 기존의 일정관리 서비스를 사용하는 대학생들을 대상으로 설문조사를 시행했을 때, 위의 세 가지 문제점들을 기존의 일정관리 서비스가 해결해주지 못하는 것으로 드러났다. <br>그렇기 때문에 위의 세 가지 문제점을 해결할 수 있는 일정관리 서비스를 기획했다. |
| (8-2) 과제: 기존연구와의 비교 | 기존 서비스는 (8-1)에서 제시한 첫번째 문제를 해결하기 위한 기능을 만들지 않았다. 이에 시간이 정해지지 않은 일정의 경우 사용자가 언제 처리할지 직접 정해서 입력하고 확인하는 것만 가능하다.<br>또한 기존 서비스는 (8-1)에서 제시한 두번째 문제를 해결하기 위한 기능을 만들지 않았다. 기존 일정 관리 서비스에는 동선을 추천해주는 기능은 없고 단지 장소 입력만 가능하다. <br>기존 서비스는 (8-1)에서 제시한 세번째 문제를 해결하기 위한 기능을 만들지 않았다. 일정이 없는 시간대를 따로 정리해서 알려주는 기능이 없기 때문에 사용자가 직접 일정을 확인해서 남는 시간대를 찾아내야하는 번거로움이 있다. |
| (8-3) 과제: 제안 내용 | (8-1)에서 제시한 첫 번째와 두 번째 문제를 해결하기 위해 일정 추천 기능을 해결책으로 고안했다. 사용자가 시간이 정해진 스케줄(반복스케줄 및 일반스케줄)을 입력하면 그 스케줄은 시간과 장소가 정해지지 않은 스케줄들(유동스케줄)의 처리 순서를 정하는 데에 기준이 된다. 반복스케줄 및 일반스케줄의 장소와 유동스케줄의 마감기한에 따라 남는 시간에 유동스케줄의 처리 순서가 정해진다.<br>한편, (8-1)에서 제시한 세 번째 문제를 해결하기 위해 시간대 추천 기능을 해결책으로 고안했다. 사용자가 새로운 일정을 소화하고 싶은 날짜를 선택하면 해당 날짜들에 스케줄이 없는 시간대를 리스트로 보여주어 마음에 드는 시간대를 선택할 수 있게 한다. |
| (8-4) 과제: 과제의 주요 기능 | 첫 번째 주요 기능으로는 일정 추천 기능이 있다. 사용자가 날짜나 장소를 정확하게 정하지 않은 스케줄(유동스케줄)을 입력하면 기존에 입력되어있던 사용자의 스케줄들을 바탕으로 해당 유동스케줄을 남는 시간대에 배치해준다. 이를 통해 장보기 등 마트라는 장소 키워드는 있지만, 정확한 상호명은 정하지 않은 스케줄 또한, 어떤 마트에 가서 장을 볼지도 추천받을 수 있다.<br>두 번째 주요 기능으로는 시간대 추천 기능이 있다. 이 기능은 일정과 일정 사이에 빈 시간대를 파악하여 알려준다. 사용자가 시간을 조율해야 하는 일정(ex: 팀회의 시간, 교수님과의 면담 등)이 있으면 이 기능을 사용하여 자신의 일정 중 빈 시간대를 파악할 수 있고 시간대 목록 중에서 자신이 원하는 시간대를 선택하여 그 시간에 들어갈 일정을 만들 수 있다. <br>본 프로젝트에서 제공하는 세 번째 주요 기능은 일정 관리 기능이다. 사용자는 매주 반복되는 스케줄인 반복스케줄, 시간이 정해진 스케줄인 일반스케줄, 시간과 장소가 정해지지 않은 스케줄인 유동스케줄, 그리고 기억하고 싶은 일정인 리마인더를 통해 일정을 구분하여 관리할 수 있다. 또한, 캘린더와 타임라인을 통해 일정들을 한눈에 알아볼 수 있도록 해준다. |
| (8-5) 과제: 구현 방법 | -시간대 추천 기능<br> 사용자가 일반스케줄 및 유동스케줄 추가 한 것을 db에 저장한다.<br> 사용자가 유동스케줄의 예상소요시간과 날짜를 입력하면 해당 날짜에 해당 예상소요시간만큼 남는 시간대를 기존에 입력된 일정 데이터를 기반으로(24시간-등록된 스케줄의 시간) 계산해서 빈 시간대를 프론트로 전달해 화면에서 리스트 형태로 보여준다.<br> - 추천 알고리즘<br> Rule based System으로 일정 추천 알고리즘을 고안했다.<br> 주요 용어<br> 유동스케줄 : 마감기한은 정해져있지만, 언제 처리할지 정확한 날짜나 시간은 모르는 스케줄<br> 타임블럭 : 오늘의 전체 타임라인 중 스케줄이 없는 시간대<br><br> 사용자는 유동스케줄 입력 시 예상소요시간, 마감기한, 중요도를 필수적으로 입력하고, 스케줄의 장소는 입력하지 않거나, 정확한 장소를 입력하거나, 키워드로 검색한 장소를 입력할 수 있다.<br><br> 기간이 가장 짧은 타임블럭부터 유동스케줄을 배치해준다. 타임블럭의 기간과 유동스케줄에 입력된 예상소요시간을 비교해 타임블럭보다 예상소요시간이 짧은 유동스케줄만이 타임블럭에 배치될 수 있는 유동스케줄 후보군이 된다.<br><br> 타임블럭의 경우 앞 뒤 스케줄에 입력된 장소에 따라 case가 구분된다.<br> 첫 번째 case는 타임블럭의 앞 뒤 스케줄에 입력된 장소가 동일한 경우다.<br> 두 번째 case는 타임블럭의 앞 뒤 스케줄에 입력된 장소가 상이한 경우다.<br><br> 모든 case에서는 마감기한이 오늘로 입력된 유동스케줄이 배치되고 난 후 마감기한이 오늘이 아닌 유동스케줄이 배치된다. 또한, 같은 마감기한을 가진 유동스케줄은 중요도가 높은 순으로 우선 배치된다.<br><br> 첫 번째 case의 경우 장소가 입력되지 않거나, 타임블럭의 앞 뒤 스케줄의 장소와 같은 장소가 입력된 유동스케줄을 우선적으로 배치한다. 두 가지 종류의 유동스케줄을 배치한 후에도 타임블럭이 남아있다면 키워드로 검색해서 장소를 입력한 유동스케줄과 타임블럭의 앞 뒤 스케줄의 장소와 다른 장소가 입력된 유동스케줄을 배치한다. 이때, 예상소요시간 대비 이동시간을 계산해 너무 이동시간이 긴 경우 동선 효율이 좋지 않다고 생각해 해당 타임블럭에 배치하지 않는다.<br><br> 두 번째 case는 우선적으로 배치되는 유동스케줄의 종류만 첫 번째 case와 다를 뿐 다른 처리 방식은 동일하다. 키워드로 검색해서 장소를 입력한 유동스케줄과 타임블럭의 앞 뒤 스케줄의 장소와 다른 장소가 입력된 유동스케줄이 우선적으로 배치된다. 두 가지 종류의 유동스케줄을 배치한 이후에도 타임블럭이 남아있다면 사용자가 장소를 입력하지 않은 유동스케줄이나 타임블럭의 앞 뒤 스케줄의 장소와 같은 장소가 입력된 유동스케줄을 배치한다. <br><br> 사용자가 일정을 추가할 때, 장소를 입력하는데, 이때, 카카오맵 api를 이용해서 입력한 장소를 db에 저장한다. 저장된 데이터를 바탕으로 추천 시 현재 스케줄을 배치하고자 하는 타임블럭의 앞 뒤 스케줄의 장소의 위도와 경도를 구한 후 카카오맵 api에 전달해 입력되어있는 유동스케줄들과 각각 앞 뒤 스케줄까지의 이동시간을 계산한다. 이때, 계산된 이동시간이 가장 짧은 유동스케줄을 선택해 타임블럭에 배치한다. 추가로 '카페', '올리브영' 등 키워드로만 장소를 입력할 시에는 카카오 맵 api에 키워드 자체로 데이터를 넘겨 검색하고, 검색 시 나온 결과의 장소들과 앞 뒤 장소들의 위도,경도를 바탕으로 이동시간을 계산해 구체적인 카페 및 올리브영 지점을 결정하고, 이를 일정 데이터베이스에 업데이트한다.|
| (8-6) 과제: 세부 기술 | [Frontend]<br> 역할: 사용자 인터페이스(UI)를 구현하고 사용자와의 상호작용을 담당한다.<br> 기술 스택 : HTML, CSS, JavaScript, React<br> [Backend]<br> 역할: 클라이언트로부터 요청을 받아 처리하고 데이터베이스와 상호작용한다.<br> 기술 스택 : Spring boot<br> [서버 환경]<br> 역할: 애플리케이션의 배포와 실행을 담당한다.<br> 기술 스택 : AWS EC2<br> [데이터베이스 모듈]<br> 역할: 데이터의 저장, 관리, 검색을 담당하여 애플리케이션의 데이터를 관리한다.<br> 기술스택 : MySQL<br> [보안 및 인증 모듈]<br> 역할 : 사용자 인증 및 보안 기능을 처리한다.<br> 기술 스택  : Spring Security<br> [외부 API (네이버 API, 카카오맵 API, TMAP 지도 API)]<br> 역할 : 외부 지도 서비스를 연동하여 지도 기능을 제공한다.<br> 기술 스택 : 각 지도 서비스에서 제공하는 API 및 연동 라이브러리<br><br> - 로그인 후 DB에서 사용자 정보 조회 후 로그인과 세션 유지<br> - 일반스케줄, 유동스케줄, 리마인더 추가시 DB와 화면에 반영<br> - 사용자의 정보를 바탕으로 기존에 입력된 일정 DB에서 가져와 화면에 반영<br> - 추천받은 스케줄 DB와 화면에 반영 |
| (8-7) 과제: 기대 효과 및 의의 | 최종목표 : 많은 활동을 소화하나 일정 관리가 어려운 대학생들을 위해 소요시간과 동선을 기반으로 일정을 추천하여, 보다 더 효율적으로 하루를 보낼 수 있도록 한다. 기존의 일정관리 앱 서비스 사용자들이 느꼈던 불편한 점의 90% 이상을 해결하도록 한다. |
| (9) 데모 내용 | 1) 로그인 <br>2) 더보기화면 - 취침 시간 설정 <br>3) 메인 캘린더 화면 - 일정 확인 <br>4) 시간대 추천 기능 <br>5) 일반스케줄 추가 <br>6) 유동스케줄 추가 - 장소 입력 <br>7) 메인 캘린더 화면 및 타임라인, 유동스케줄 리스트에서 추가된 일정 확인 <br>8) 일정 추천 기능 <br>9) 타임라인을 통해 추천받은 일정 확인. 메인 캘린더 화면에서 추천받은 스케줄 확인 <br>10) 지도 기능을 통한 동선 확인 <br>11) 타임라인에서 유동스케줄 완료 여부 체크시 리스트에서 확인 |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-26
| (1) 과제명 | DISLODGED :  TTS 기술을 활용한 익명 감성 위로 커뮤니티
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 26-ETT |
| (3) 팀원 역할 분담 | 최유미(2171048) : 리더, 백엔드, AI<br>남승현(2176121) :  팀원, 프론트엔드, AI<br>송민경(2176190) : 팀원, 프론트엔드, AI |
| (4) 팀 지도교수 | 민동보 |
| (5) 팀 멘토 | 이동열/카카오뱅크/AI기술팀 개발자 |
| (6) 과제 키워드(keywords) | TTS, 위로, 가상보이스 |
| (7) 과제 내용 요약 | 다양한 고민과 스트레스를 안고 살아가는 현대인들을 위해, 유저들은 GoogleTTS를 활용해 여러 보이스 요소(기본 보이스, 피치, 스피드 등)들을 직접 조절 및 조합하여 생성한 '나만의 가상보이스'로 위로를 전할 수 있습니다.  이에 따라, 위로가 필요한 유저에게 타 유저들이 남긴 위로 댓글들을 보이스로 변환 후 하나로 모아 음악처럼 들려줌으로써, 많은 사람들로부터 위로를 받고 있다는 느낌을 받게 해주는 감성 웹 서비스입니다. |
| (8-1) 과제: 문제의 정의 | 현대인들은 다양한 고민과 스트레스를 안고 살아가지만, 현실에서 이런 고민과 스트레스를 표출하는 것에 부담을 느끼기 때문에 온라인 커뮤니티에 의존하는 경우가 많습니다. 하지만 온라인 커뮤니티의 경우 텍스트로만 소통하기 때문에, 대면 소통에 비해 감정 전달이 어렵고 고립감을 느끼기 쉽다는 한계점이 존재합니다. 따라서, 현대인들은 새로운 방식의 위로와 응원이 필요합니다. |
| (8-2) 과제: 기존연구와의 비교 | Selvy Speech는 TTS기술을 활용하여 텍스트를 음성으로 변환합니다. 사용자가 피치, 스피드 조절을 하며 다양한 보이스를 생성할 수 있는 장점을 가집니다. 그러나 이 서비스는 주로 음성의 속도와 피치를 조절하는 데에 중점을 두며, 단순히 TTS 기능만을 제공한다는 단점이 존재합니다.<br>Blooming 앱은 익명 고민 상담 게시판을 운영한다는 점에서 자유롭게 본인의 고민을 털어놓을 수 있지만, 음성을 활용하지 않고 텍스트를 통해서만 고민 상담을 할 수 있는 게시판을 운영한다는 한계점이 있습니다. |
| (8-3) 과제: 제안 내용 | 먼저 누구나 자유롭게 고민을 나누고 위로의 댓글을 남길 수 있도록 익명으로 소통할 수 있는 네트워크 서비스 구축하고자 했습니다. 또한, 기존 텍스트 위로의 문제점을 개선하기 위해, TTS기능을 이용하여 타 유저들이 남긴 댓글 텍스트 뿐만 아니라 새로운 보이스 형태의 위로로 들을 수 있게 했습니다. 추가로, 위로를 음악처럼 들을 수 있고, 많은 사람들에게 위로받고 있다는 느낌을 극대화하기 위해 여러 보이스로 변환된 댓글을 모아서 들을 수 있는 솔루션을 제안하고자 합니다. |
| (8-4) 과제: 과제의 주요 기능 | 익명의 게시글 작성/댓글 기능<br>자신만의 가상 보이스 생성 기능(보이스 요소 조절)<br>텍스트 댓글과 댓글 작성자의 보이스를 결합하여 보이스 댓글로 변환하는 기능<br>보이스로 변환된 댓글들을 한번에 모아듣는 기능 |
| (8-5) 과제: 구현 방법 | 사용자가 자신만의 보이스를 직접 들어보며 만들어볼 수 있게 하고, 만들어진 보이스의 정보는 MySQL DB에 저장이 됩니다. 이렇게 저장된 보이스 정보들을 가져와 댓글 작성자마다 다른 보이스의 위로들을 들어볼 수 있습니다.<br>또한 게시글 작성자는 마이페이지에서 변환된 보이스 위로들을 끊김없이 한번에 들을 수 있습니다. 각 댓글들의 보이스를 들어보고, <좋아요> 표시를 한다면 해당 데이터들을 바탕으로 통계, 분석하여 사용자에게 최적의 보이스를 추천할 수도 있습니다. |
| (8-6) 과제: 세부 기술 | 프론트엔드는 React를 사용하며, 배포는 Vercel을 이용합니다.<br>백엔드는 Django를 사용하며, 배포는 AWS와 GitHub Actions를 이용해 CI/CD를 구축하였습니다. 데이터베이스는 AWS의 S3와 MySQL을 사용하였습니다. |
| (8-7) 과제: 기대 효과 및 의의 | 본 서비스는 여러 댓글 작성자들이 작성한 보이스 위로 댓글을 들음으로써 가독성 저하 등 기존 텍스트 위로의 문제점을 개선할 뿐 아니라 ‘다수’의 사람들로부터 위로를 듣고 있다는 감정을 느낄 수 있습니다. <br> 더불어 보이스위로 댓글들을 한 번에 모아 들려주는 기능을 제공함으로써, 위로를 언제 어디서든 편하게 음악처럼 들을 수 있도록 합니다. <br>따라서 이 서비스는 사람들이 더 쉽게 고민을 공유하도록 접근성을 높이며, 위로의 감정을 더 효과적으로 나누는 것에 의의를 두고 있습니다. |
| (9) 데모 내용 | 웹 사이트 내 모든 기능은 로그인 후 사용이 이용 가능합니다. 로그인 후 나만의 보이스 페이지에 들어가 기본 보이스 타입 4가지와 스피드, 피치를 조합하고 생성된 보이스를 들어보며 마음에 든다면 나의 가상보이스로 저장할 수 있습니다. 이후 게시글에 댓글을 작성하게 되면 해당 가상보이스로 변환하여 제공하고 이를 들어볼 수 있습니다. 다른 유저들이 남긴 댓글 또한 댓글 작성자가 저장한 가상보이스로 변환된 음성을 들어볼 수 있습니다. 마지막으로, 마이페이지에 들어가면 내가 쓴 게시글을 앨범처럼 모아 볼 수 있고 해당 게시글의 모든 댓글을 모아 들을 수 있습니다.  |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-27
| (1) 과제명 | MosaicNow
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 27-E모지 |
| (3) 팀원 역할 분담 | 정유라(2176349) : 백엔드 개발, AI<br>유혜진(2071089) : 백엔드 개발, AI<br>이가은(2076283) : 프론트엔드 개발, AI |
| (4) 팀 지도교수 | 윤명국 |
| (5) 팀 멘토 | 김민주/삼성전자/개발자 |
| (6) 과제 키워드(keywords) | 실시간/모자이크/스트리밍 |
| (7) 과제 내용 요약 | MosaicNow는 얼굴인식 기술을 기반으로 사용자가 등록한 얼굴 이외의 타인의 얼굴을 모두 모자이크하는 서비스를 제공해 실시간 라이브 방송에 얼굴이 노출될까 걱정하는 사람들에게 도움을 줄 뿐만 아니라 MosaicNow를 사용하는 스트리머에게도 촬영 장소에 구애받지 않는 자유로운 방송 컨텐츠를 제공할 수 있습니다. 저희는 이를 통해 다양한 환경에서 개인의 프라이버시를 보호하고 초상권 침해 피해를 감소시키고자 합니다. |
| (8-1) 과제: 문제의 정의 | 유튜브, 틱톡 등의 라이브 방송이 대중화 되면서 일상 속에서 라이브 방송으로 인한 초상권 침해 피해는 급격히 늘어나고 있는 추세입니다. 저희는 이처럼 원하지 않는 사람들의 초상권 보호를 위해 MosaicNow를 구상하였습니다. |
| (8-2) 과제: 기존연구와의 비교 | 관련 서비스인 VLLO는 동영상 자동 얼굴 모자이크 기능을 제공하지만 실시간 적용은 안된다는 단점이 있습니다. 이와 달리 MosaicNow는 실시간 적용이 가능하다는 장점이 있습니다. |
| (8-3) 과제: 제안 내용 | 공공장소 라이브 방송에서 타인의 초상권 보호를 위한 실시간 안면인식 커스텀 모자이크 스트리밍 서비스 |
| (8-4) 과제: 과제의 주요 기능 | FaceNet과 YOLO5를 이용하여 사용자의 얼굴 임베딩을 만들고 이를 비교하여 사용자 제외 타인의 얼굴을 모자이크 할 수 있는 커스텀 모자이크 기능과 사용자 외 다른 사람들의 얼굴 임베딩을 추가하여 여러명의 얼굴을 인식 가능하게 하는 얼굴 등록 기능, 등록된 유튜브 스트림 키를 이용해 개인 스트리밍 서버로 실시간 송출할 수 있는 스트리밍 기능을 제공합니다. |
| (8-5) 과제: 구현 방법 | 1. 얼굴 등록 기능<br>1.1 등록 버튼을 누르면 얼굴 등록 화면으로 이동하고 웹캠의 프레임을 AI 서버로 전송한다.<br>1.2 전송된 50개의 프레임의 평균 임베딩을 계산하여 임베딩 파일을 생성한다.<br>1.3 얼굴 등록이 완료되면  메인 화면으로 이동한다.<br><br>2. 실시간 커스텀 모자이크<br>2.1 사용자의 프레임을 받아 얼굴을 탐지한다.<br>2.2 탐지된 얼굴들과 저장된 임베딩의 거리를 계산하여 등록된 사용자인지 판단한다.<br>2.3 등록된 사용자가 아닌 경우 얼굴을 모자이크 처리한다. 모든 얼굴에 같은 처리 방식을 반복한다.<br>2.4 처리된 프레임을 클라이언트에게 전달하여 사용자의 화면에 보여준다.<br><br>3. 유튜브 스트리밍<br>3.1 시작 버튼을 누르면 등록된 처리된 프레임을 사용자의 유튜브 스트리밍 서버로 전송하여 유튜브 라이브 방송을 시작한다. |
| (8-6) 과제: 세부 기술 | 동작환경 : 크롬 웹 브라우저<br>Frontend: React, JavaScript, CSS<br>사용자 인터페이스를 구현하고 사용자와의 상호작용을 담당한다.<br><br>Backend: web server, AI server, Database<br>Web server: Apache, Node.js<br>포트포워딩을 통해 외부 접속이 가능하게 하고 Apache에서 Node.js 서버로의 프록시 설정을 통해 Apache를 통한 요청을 Node.js 서버로 전달한다. 클라이언트의 로그인, 회원가입, 사용자 정보 저장 및 처리 등의 요청과 서버, 데이터베이스의 상호작용을 담당한다.<br>AI server: YOLOv5, FaceNet<br>포트포워딩을 통해 클라이언트에서 AI 서버로 사용자의 웹캠 프레임을 보내고 AI서버에서 프레임을 처리한다. YOLOv5로 사용자의 프레임에서 얼굴을 탐지하고, FaceNet을 이용하여 탐지된 얼굴들과 저장된 임베딩을 비교하여 미리 등록된 사용자인지 판단하고 등록된 사용자가 아닌 경우 얼굴을 모자이크 처리한다. 처리된 프레임을 클라이언트에게 전달하고 클라이언트는 전달받은 프레임을 실시간으로 사용자에게 보여준다. 사용자가 스트리밍을 시작하면 처리된 프레임을 FFmpeg를 사용해 사용자의 유튜브 스트리밍 서버로 전송한다. <br>Database: mySQL<br>시스템의 데이터를 저장하며, 사용자 정보 테이블, 사용자 얼굴 임베딩 테이블 등을 포함한다. |
| (8-7) 과제: 기대 효과 및 의의 | MosaicNow는 등록되지 않은 얼굴에 대해 모자이크 처리를 적용하여 개인의 프라이버시를 보호할 수 있습니다. 또한 실시간 라이브 방송에 얼굴이 노출될까 걱정하는 사람들에게 도움을 줄 뿐만 아니라 MosaicNow를 사용하는 스트리머에게도 촬영 장소에 구애 받지 않는 자유로운 방송 컨텐츠를 제공할 수 있습니다. 이를 통해 본 팀은 다양한 환경에서 개인의 프라이버시를 보호하고 초상권 침해 피해를 감소시키고자 합니다. |
| (9) 데모 내용 | Web 환경에서 emoji27.duckdns.org로 접속해 데모를 진행한다.<br>[데모 내용] 1. 로그인/회원가입 기능을 보여준다. <br>2. 사용자의 정보 변경 기능을 보여준다. <br>3. 사용자의 얼굴을 등록하는 과정을 보여준다. <br>4. 미리보기 기능을 통해 등록 된 얼굴을 제외한 얼굴들이 실시간으로 모자이크 되는 화면을 보여준다.  |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-28
| (1) 과제명 | 속마음을 담은 일기 교환을 통해 현대인의 소외감 해소를 돕는 교환일기 웹 서비스 <비밀친구>
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 28-달리리 |
| (3) 팀원 역할 분담 | 황채린(2176429): 리더, 백엔드 프로그래밍<br>조아령(2076389): 팀원, 프론트엔드 프로그래밍<br>곽민지(2176022): 팀원, 백엔드 프로그래밍 |
| (4) 팀 지도교수 | 박상수 |
| (5) 팀 멘토 | 서오석/SK에너지/CTO |
| (6) 과제 키워드(keywords) | 일기,교환,매칭 |
| (7) 과제 내용 요약 |  <비밀친구>는 지인, 혹은 익명의 친구와 지속적인 교환 일기를 쓸 수 있도록 해주는 웹 서비스이다.<br> 비밀 친구는 크게 두가지 목표를 가진다.<br>  첫 번째는 '교환'과 관련된 목표로, 교환 일기 웹 서비스 ‘비밀친구’를 개발 및 배포하여 사용자들끼리 속마음을 담은 일기를 교환함으로써 서로를 공감하고, 현대 사회에서 느끼는 소외감을 해소하도록 유도하는 것이다.<br>  두 번째는 '일기'와 관련된 목표로, 사용자가 작성한 일기에 대한 감정분석 레포트를 제공함으로써 사용자가 '오늘의 기분'이 어땠는지 스스로의 감정을 되돌아보고 살필 수 있는 기회를 제공하는 것이다.|
| (8-1) 과제: 문제의 정의 |  경쟁 사회에서 한 사람은 고유한 인격이나 개성보다 사회의 필요성 혹은 외적 모습에 의해 물질적으로 평가된다. 특히 경쟁이 심한 한국 사회에서 그러한 현상이 더 두드러지며 개인은 다른 인간으로부터 소외되는 감정을 느끼고 단절감을 경험하게 된다. 이러한 과정에서 개인과 사회는 더 병들어 가고 있다. 개인에게 매겨지는 상품적 가치를 배제하고 다른 이들과 감정과 생각을 솔직하게 나눌 수 있는 편한 공간을 제공하여 보다 더 따뜻한 사회를 만들고 싶다는 생각에서 이 프로젝트를 시작하게 되었다. 때로는 모르는 사람에게 고민을 털어놓거나 나만의 비밀친구를 만들어서 서로의 삶을 공유하고, 친구들과는 온라인에서도 긴밀한 얘기를 나눌 수 있도록 하여 누군가가 나를 공감해 주고 나는 다른 이를 공감해 주는 선순환의 문화를 만드는 데에 기여하고자 한다.|
| (8-2) 과제: 기존연구와의 비교 |  비밀친구와 유사한 서비스로는 기존 일기장 서비스와 인스타그램, 총 두 가지를 선정해 비교했다. <br>먼저 기존 일기장 서비스와 비교했을 때 <비밀친구>는 친구와 일기를 교환할 수 있다는 차별점이 존재한다. 친구와 함께 일기를 작성한다는 재미 요소는 글쓰기에 서투른 사람들도 쉽게 일기를 작성할 수 있게 도와줄 것으로 예상한다. 또한 기존 일기장 서비스에서는 사용자들이 매일 일기를 작성해야한다는 부담감을 받기 쉬운 반면, 비밀친구는 함께 일기를 작성하는 파트너로부터 답장(일기)을 받아야만 일기를 작성하는 차례가 돌아오므로, 사용자가 매일 일기를 작성해야 한다는 부담이 한층 줄어든다. 반면, 'Doolda', '아모르'와 같이 타인과 함께 일기를 작성할 수 있다는 강한 유사점을 가진 서비스들이 존재했는데, 이러한 서비스의 경우 친구 혹은 연인 관계를 타겟으로 하고 있는 것을 발견할 수 있었다. 그러나 비밀친구는 사용자의 관심사를 고려한 랜덤매칭 기능을 제공하여 사용자가 지인이 아닌 익명의 대상과도 교환 일기를 작성할 수 있도록 구현한다.추가로, 사용자가 작성한 일기에 대한 감정 분석 레포트를 제공하여 사용자가 본인의 감정을 객관화하고 추적할 수 있는 기회를 제공한다. <br>두번째로, 대표적인 SNS 인스타그램과 비교했을 때 비밀친구는 타인과 소통할 수 있다는 공통점을 갖는다. 하지만 인스타그램은 텍스트보다는 이미지 위주의 소통이 이루어지며 여러 사람에게 사용자의 일상이 보여지는 반면, 비밀친구는 한 명의 파트너와만 일기를 교환한다는 점에서 개개인 간의 긴밀한 소통에 중점을 두고 있다는 차이점이 존재한다.  |
| (8-3) 과제: 제안 내용 | 어릴 적 친구들과 주고받았던 교환일기 경험을 바탕으로 한 교환일기 웹 어플리케이션을 해결책으로 제안한다. 초대코드를 통해 친구들과 교환일기를 작성할 수 있으며, 기존에 존재하는 교환일기 어플리케이션과는 다르게 익명의 상대와도 교환일기를 작성할 수 있는 랜덤 매칭 서비스를 제공한다. 이때 랜덤 매칭 알고리즘을 통해 사용자의 관심사를 고려하여 비슷한 관심사를 가진 사용자끼리 매칭한다. 익명의 상대에 대한 신뢰성 문제를 사전에 해결하기 위해 혐오발언과 성적발언 필터링 기능을 추가하고 일정 회수 이상 신고가 누적되면 계정을 자동으로 정지시키는 기능을 제공한다. 교환일기의 아날로그 감성을 어플리케이션을 통해서도 느낄 수 있게 상대방의 일기는 일정 시간 이후에 공개하여 실제로 일기를 주고받는 듯한 기분을 추가한다. 마지막으로, 사용자끼리 주고받은 일기의 내용은 감정분석 한 후 매우 긍정/긍정/보통/부정/매우 부정 5개 감정 중 하나로 라벨링하며, 라벨링된 감정을 기반으로 어울리는 색상의 hex code를 사용자에게 제공한다. 추가로, 일기에 대한 한줄 요약을 제공하여 사용자가 그날의 감정과 사건을 돌아볼 수 있는 기회를 갖도록 돕는다. |
| (8-4) 과제: 과제의 주요 기능 | [1] 일기장 생성<br>방법 1 지인 매칭: 일기장 생성시 만들어지는 고유 코드를 통해 지인과 교환일기를 쓸 수 있도록 매칭<br>방법 2 랜덤 매칭: 관심사와 매칭 요청일을 기반으로 교환일기를 함께 작성할 익명의 유저를 매칭<br>사용자가 새로운 랜덤 매칭을 요청하면, 기존 매칭 요청들과의 궁합을 계산하고, 최적의 매칭을 찾아내어 사용자들에게 매칭된 결과를 제공하는 것을 목표로 한다.<br>매칭에 실패하면 해당 랜덤 매칭 요청을 매칭 대기열에 추가하여, 다음 기회를 기다리게 한다.<br>[2] 일기장 비활성화/삭제: 더 이상 일기장을 교환하지 않도록 비활성화해 보관하거나, 완전히 삭제하는 기능<br>[3] 일기 조회/작성/전달: 일기를 조회 및 작성하고 교환 일기 상대방에게 전달하는 기능<br>[4] 감정 분석: 사용자가 일기 전달 완료 시, 작성한 일기에 대한 감정분석을 수행해 매우 긍정/긍정/보통/부정/매우 부정 중 하나로 분류한 결과를 제공한다.<br>사용자가 작성한 일기에 대한 감정분석을 수행 후 사용자의 일기 내용 및 분위기에 어울리는 색상 코드를 추천하여 그날 하루를 색상으로서 표시한다.<br>사용자가 작성한 일기에 대하여 ‘<상황이나 사건>에 대한 <감정>’ 형식으로 한 줄 요약한 결과를 사용자에게 제공한다.<br>[5] 실시간 알림: [일기장 생성], [일기장 비활성화], [상대방으로부터 일기 답장] 이벤트 발생 시 해당 내용에 대한 실시간 푸시 알림을 받는 기능<br> |
| (8-5) 과제: 구현 방법 |스프링 부트와 리액트를 이용해 교환일기 서비스 “비밀친구”를 웹 애플리케이션 형태로 개발한 후, aws 와 docker를 통해 실제 배포 및 운영할 계획이다. 교환 일기 웹 서비스 계정 로그인, 지인 매칭과 랜덤 매칭을 통한 일기장 생성, 일기 작성/수정, 상대방과 일기장 주고 받기, 일기장 읽기, 일기장 비활성화, 유저 신고, 혐오 발언 필터링 등의 메인 기능이 포함된다. 또한, 작성된 일기를 기반으로 한 감정 분석 및 요약 결과를 보여주는 기능을 구현하기 위해서 스프링 부트와 OPENAI api를 연동한 후 gpt-3.5-turbo 모델을 사용해 결과를 얻어냈다. <br><br><b>- 감정분석 레포트 기능 세부 구현 방법 요약</b><br>![image](https://github.com/ekhyoo/CapstoneDesign-24-1H/assets/87927105/82417f37-2190-4fb3-bac9-5b96e7d848ce)<br>1. 사용자가 일기를 작성 후 전달합니다.<br>2. 비밀친구 웹 애플리케이션에서 Spring Boot 서버로 API 호출을 합니다.<br>3. ReportController.java가 요청을 받은 후 ReportService.java로 전달합니다.<br>4. ReportService.java가 OpenAI GPT-3.5-turbo API를 호출하여 감정 분석을 수행합니다.<br>5. 감정 분석 결과를 받아 ReportService.java에서 가공합니다.<br>6. 가공된 데이터를 MySQL 데이터베이스에 저장합니다.<br>7. 저장된 데이터를 ReportController.java로 전달합니다.<br>8. ReportController.java에서 클라이언트로 응답 데이터를 전송합니다.<br>9. 클라이언트 애플리케이션에서 감정 분석 결과를 화면에 표시합니다.<br><br><b>- 랜덤매칭 기능 세부 구현 방법 요약</b><br>![image](https://github.com/ekhyoo/CapstoneDesign-24-1H/assets/87927105/082a74e7-e5b9-43d0-9c57-c50bd12a6904)<br>1. 사용자가 랜덤 매칭을 요청할 시, 이미 매칭된 적 있는 상대와 다시 매칭 되지 않도록 매칭 이력 테이블을 검사합니다. <br>2. 매칭 요청 테이블을 조회하는데, 만약 랜덤 매칭을 요청한 사람이 아무도 없을 경우에는 사용자는 매칭 대기 상태가 됩니다. <br>3. 요청한 유저가 한 명 이상 존재할 경우 해당 유저와 관심사 및 매칭 요청 시간을 기반으로 궁합 점수를 계산합니다. <br>4. 해당 궁합 점수가 기준점을 초과할 시 매칭이 성사됩니다.<br><br><b>- 실시간 알림 기능 구현 방법 요약</b><br>![image](https://github.com/ekhyoo/CapstoneDesign-24-1H/assets/87927105/531fbe8c-99e6-462c-a54d-4ef9fe3ea4f4)<br>1. 로그인: 유저가 웹 애플리케이션에 로그인하면, 로그인 상태가 AWS S3의 loginState에 저장됩니다.<br>2. Emitter 생성 요청: 유저의 이벤트 소스를 생성하기 위해 EventSource 객체가 생성되고 현재 로그인 유저의 정보를 파라미터로 담아 emitter 생성 API를 호출합니다. EmitterController.java에서 SseEmitter 생성을 요청합니다.<br>3. SseEmitter 생성 및 반환: EmitterService.java에서 SseEmitter 객체를 생성하고 반환합니다. Emitter 생성이 완료되면 웹 서버로 완료 메시지가 전달됩니다.<br>4. 일기장 생성/비활성화/답장 API 호출: 유저가 일기장을 생성하거나 비활성화 또는 답장할 때 API가 호출됩니다. API 호출을 통해 실시간 알림 생성 요청이 EmitterService.java로 전달됩니다.<br>5. 실시간 알림 정보 전달: 실시간 알림 정보가 React + Recoil 프론트엔드로 전달되고, 실시간 알림 내용이 notifyState에 저장됩니다.<br>6. 푸시 알림 제공: 실시간 알림 내용을 기반으로 사용자에게 푸시 알림을 제공합니다. |
| (8-6) 과제: 세부 기술 |<br> - 시스템 아키텍처 <br>![image](https://github.com/ekhyoo/CapstoneDesign-24-1H/assets/87927105/045a702d-caac-4e73-9a0c-5e4c0eaa3ff7)<br><br>1. 구축 환경<br>- 버전 관리: Github<br>- frontend: React, Axios, recoil, scss<br>- backend:Spring Boot, Gradle, jpa, mariadb<br>- CI/CD: Github Actions<br>- container: Docker<br>2. 감정 분석 레포트 제공을 위한 chatGPT API 사용<br>- openai 의 gpt-3.5-turbo 모델 사용<br>- 응답 포맷 통일 및 토큰 수 절약을 위한 few-shot prompting 이용<br>3. 스프링 부트와 AWS EC2를 이용한 API 서버와 CloudFront+S3를 이용한 리액트 웹 서버 구축 <br>4. MariaDB RDBMS 와 AWS RDS 를 이용한 데이터베이스 구축<br> |
| (8-7) 과제: 기대 효과 및 의의 | 일기 쓰기의 장점에는 자신을 돌아보며 자기객관화와 자기이해를 할 수 있다는 점이 있다. 감정 일기 작성의 경우 우울증상에 개선효과를 보였다는 연구 결과가 있다. 자신의 감정을 알아가고 일기 작성을 통해 감정을 표현하는 것 자체만으로도 치료 효과를 낸다. 작성된 일기를 기반으로 감정 분석 및 요약 결과를 보여줌으로써 사용자의 감정 파악에 도움이 되길 기대한다. 또한, 5일간의 감정 변화 그래프를 보여줌으로써 사용자의 감정 트래킹을 돕고자 한다. 단순 일기 어플리케이션이 아닌 교환 일기 어플리케이션이기에 얻을 수 있는 효과도 존재한다. 다른 사람과 소통하는 과정에서 상대방이 자신의 생각이나 감정을 인정해주고 수용해주는 경험은 감정조절 능력 향상에 도움을 준다. 교환일기를 작성하는 과정에서 서로가 서로의 생각이나 감정을 수용하고 나누는 과정에서 사용자들의 감정조절 능력 향상에 도움이 되길 기대한다. 또한, 사회에서 현대인들이 느끼는 소외감 해소에도 일조하고자 한다. 어플리케이션의 타겟층은 2~30대로, 위의 기대효과와 더불어 어릴 때 교환일기를 작성한 적 있는 사람들에게는 그 시절의 추억을 재현시켜 주고 어릴 적 교환일기를 작성해 본 적이 없는 이들에게는 레트로 감성을 충족시켜 주는 어플리케이션이 될 것으로 예상한다. 더불어 잊어버리기 쉽고 누군가에게는 번거롭게 느껴질 수 있는 일기 작성을 누군가와 함께하는 경험을 부여함으로써 기록에 대한 동기를 유발할 수 있을 것이다. |
| (9) 데모 내용 |Scenario.1 지인매칭으로 일기장 생성 <br>1. 비밀친구 로그인<br> 2. 지인매칭을 통한 일기장 생성<br>3. 카카오톡 초대코드를 통한 친구 초대<br><br>Scenario.2 지인매칭 초대 받기<br>1. 카카오톡 초대 메세지를 통해 비밀친구 접속<br>2. 비밀친구 회원가입 (이메일 인증, 정보 입력)<br>3. 지인매칭을 통한 일기장 생성<br>4. 카카오톡 초대코드를 입력하여 초대 받기 완료<br><br>Scenario.3 친구에게 일기 전달하기<br>1. 일기장 생성 실시간 알림 확인<br>2. 메인 캐비닛에서 답장 할 일기장 확인 <br>3. 일기 작성 및 전달<br>4. 전달한 일기에 대한 감정 분석 결과 확인<br>5. 메인 캐비닛과 히스토리 캐비닛 확인<br><br>Scenario.4 랜덤매칭으로 일기장 생성<br>1. 랜덤매칭을 통한 일기장 생성<br>2. 히스토리 캐비닛에서 아직 매칭이 완료되지 않은 준비중 일기장 확인 가능 <br><br>Scenario.5 비속어 필터링 기능<br>1. 기존의 비속어 작성된 일기 확인<br>2. 설정-혐오 발언 필터링 ON <br>3. 다시 일기로 돌아왔을 때 비속어가 **으로 필터<br> |
| (10) 기타 | 데모 영상 링크 : https://www.youtube.com/watch?v=SZk8cbw9vJ0|
 
[Return TOP](#list-of-teamsprojects)
 
# Team-29
| (1) 과제명 | AI를 활용한 영어 스피킹 시험 준비 앱<츄라이>
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 29-츄라이 |
| (3) 팀원 역할 분담 | 지현서(2176368): 리더, AI 프롬프트 엔지니어링<br>조은혜(2176365): 팀원, 백엔드 서버 프로그래밍, DB<br>유민경(2076256): 팀원, UI/UX 프로그래밍 |
| (4) 팀 지도교수 | 이민수 교수님 |
| (5) 팀 멘토 | 서연주 / 프리랜서 / 프리랜서 |
| (6) 과제 키워드(keywords) | AI, 영어스피킹시험, 영문뉴스 |
| (7) 과제 내용 요약 | 짧은 시간에도 틈틈이 학습을 할 수 있는 AI를 활용한 영어 스피킹 시험 대비 애플리케이션 <b><츄라이></b>입니다. 시험 주최 기관에서 제공하는 모의고사로 시험 유형을 익히고, 영문 기사를 활용하여 AI가 만든 시험과 유사한 새로운 문제를 풀어보며 다양한 주제로 출제되는 시험에 익숙해지도록 돕습니다. <br>이 과정에서 제출된 사용자의 답변에 대한 채점과 자세한 피드백을 AI 프롬프트 엔지니어링을 통해 제공해 적은 비용을 투자해 개인 과외와 비슷한 효율적인 학습이 가능하도록 합니다. |
| (8-1) 과제: 문제의 정의 | <b><츄라이></b>는 영어 스피킹 시험 준비에 있어 기존 학습 방식의 높은 시간적, 경제적 부담과 기출 문제 중심의 학습, 비효율적인 피드백으로 인한 한계를 극복하고자 합니다. <br><br>이를 위해, 학습자가 접근하기 쉽운 형태의 <b>앱</b>으로 서비스를 제공하고, 효율적으로 영어 스피킹 실력을 향상할 수 있는 <b>맞춤형 학습 플랫폼</b>을 제공함으로써, 영어 스피킹 시험 준비의 어려움을 해소하려고 합니다. |
| (8-2) 과제: 기존연구와의 비교 | <b><츄라이></b>와 비슷한 서비스로는 테스트글라이더(TestGlider)와 *toefltestReady가 있다. <br><br> <b>테스트글라이더(TestGlider)</b><br>장점 : 토플, 아이엘츠 등 영어 시험을 대비할 수 있는 풍부한 학습자료와 강의를 제공하며, 100만 건 이상의 답안 데이터를 학습한 AI 기반의 사용자 답안 채점 서비스가 있다.<br>단점 : AI 첨삭 서비스에 일반적인 모범답안은 포함되어있지만, 세부적인 오류에 대한 구체적인 피드백을 제공하지 않는다. <br><br> <b> *toefltestReady</b><br> 장점 : 실제 평가와 유사한 채점 서비스를 제공한다. <br> 단점 : 웹 형태만이 제공되며, 피드백은 따로 제공되지 않는다.  |
| (8-3) 과제: 제안 내용 | 사용자가 자주 모의고사 문제를 풀고 꾸준한 학습을 유도하기 위해서는, 다양한 주제와 수준의 문제를 제공하는 것이 중요하다. <b><츄라이></b>는 사용자가 자주, 가볍게 풀 수 있도록 문제를 구성하고 제공한다. 또한, 사용자의 답변에 대한 피드백은 단순히 모범 답안을 제공하는 것보다 <b>문장 구조 개선, 문법 오류 수정, 그리고 모범 답안에 대한 아이디어를 제공</b>하여 사용자가 자신의 답안을 정리하는 방법을 학습할 수 있도록 돕는다. <br><br>또한, <b>최신 뉴스 기사를 활용</b>하여 사용자가 영어 시험(토플)을 공부할 수 있도록 함으로써 현실적이고 실용적인 학습 경험을 제공한다. <br><br> 이를 통해 교육 비용을 절감하고, 더 많은 학생들이 효과적으로 학습할 수 있는 환경을 조성할 수 있다.  |
| (8-4) 과제: 과제의 주요 기능 | <b>1. 모의고사 풀이</b>: 시험 주최 기관에서 제공하는 모의고사 문제와 모범답안을 한 문제씩 <b>미니 시험 형식</b>으로 가공해 제공한다. 사용자들이 부족함을 느끼는 부분을 집중적으로 학습할 수 있도록 돕는다. <br><br><br><b>2. 뉴스 활용 학습</b> : 사용자가 선택한 영어 뉴스를 바탕으로 다양한 주제와 유사한 형태의 질문을 생성하여 제공할 수 있습니다. <br>토플이나 다른 영어 스피킹 시험에서는 돌발 주제와 익숙하지 않은 주제의 질문이 많이 나옵니다. 이러한 돌발 주제에 적응하고 대응할 수 있는 자질을 기르기 위해 <b><츄라이></b>를 활용할 수 있습니다. 이를 통해 사용자는 다양한 주제와 형식의 질문에 대해 대비할 수 있으며, 새로운 주제에 대한 이해력과 대화 능력을 향상시킬 수 있습니다. 이는 효율적인 학습을 위해 중요한 요소 중 하나입니다.<br><br><br><b>3. AI 튜터의 자동 피드백</b>: OpenAI GPT API를 이용해 모의고사 풀이, 뉴스 기반 대화에서 받은 사용자의 답변에 대한 피드백을 제공한다. <b><츄라이></b>를 통해 사용자는 <b>실전과 유사한 점수를</b> 받을 수 있으며, 피드백은 공식 채점 기준을 따라 제공된다. 피드백에는 사용자의 답변에 대한 근거가 제공된다.  추가적으로 더 높은 점수를 받기 위한 <b>사용자 맞춤 팁</b>도 함께 제공된다. 또한, 사용자의 답변에 있는 문법, 어휘(Konglish 등), 표현 이외의 부분들에 대해서도 첨삭이 제공된다. 이를 통해 사용자는 자신의 답변을 개선하고 발전시킬 수 있다. <br><br><br>이러한 서비스를 통해 학습자들은 효과적으로 학습을 진행할 수 있으며, 개인 맞춤형 피드백을 통해 더 나은 결과를 이끌어낼 수 있다. |
| (8-5) 과제: 구현 방법 |AI 프롬프트 엔지니어링.<br>OpenAI GPT API(gpt-4o, gpt-3.5-turbo)<br>백엔드 서버 프로그래밍, DB.<br>Spring boot, Azure MySQL, Azure Server UI/UX 프로그래밍.<br>Google Flutter (Cross-platform app development)|
| (8-6) 과제: 세부 기술 |<b>기능 1. 음성 인식 검증</b><br>필요 기술 : STT<br>설명 : 사용자가 제출한 음성 답안을 텍스트로 정확하게 변환하는 능력 확인<br>기술 검증 : 다양한 억양, 발음, 말의 속도를 포함한 음성 샘플을 사용하여 음성 인식 API의 정확성을 평가한다. Word Error Rate(WER)를 계산하여 음성 인식의 정확도를 측정한다.<br>.<br>.<b>기능 2. 뉴스기사 질문 생성</b><br>필요 기술 : OpenAI GPT API <br>설명 : 선별된 영문 뉴스 기사와 질문 생성 프롬프트를 OPENAI GPT API로 전달하고, 시험과 유사한 형태의 질문을 생성한다. <br>기술 검증 : 다양한 형태의 뉴스 기사에 대해 적합한 질문이 생성되는지 확인한다. 또한, 뉴스에서 제공되는 내용으로 답변이 가능한 질문인지 확인한다.<br>.<br><b>기능 3. 사용자 답변 피드백</b><br>필요 기술 : OpenAI GPT API  <br>설명 : 사용자의 답변에 대한 공식 채점 기준으로 진행한 채점과 사용자의 답변에 대한 맞춤 조언, 팁을 제공한다. 또한, 사용자의 답변에 있어서 공식 채점 기준에서 점수가 깎일 수 있는 어휘, 문법, 표현들에 대한 첨삭을 제공해준다.  <br>사용자의 답변을 공식 채점표를 통한 OpenAI GPT API를 통해모의 채점을 진행하여 예상 점수, 점수에 대한 근거와 더 높은 점수를 받기 위한 tip을 사용자에게 제공한다.<br>기술 검증 : 전문가가 제공한 피드백과 AI 피드백을 비교 분석한다.<br>.<br><b>기능 4 . 시험 기출, 모의고사 제공</b><br>필요 기술 : Azure MySQL<br>설명 : 시험 기출, 모의고사를 MySQL에 저장하고, 사용자의 요청에 따라 하나씩 불러온다.<br>기술 검증 : 직접 테스팅한다.<br>|
| (8-7) 과제: 기대 효과 및 의의 |짧은 시간에도 틈틈이 학습을 할 수 있는 AI를 활용한 영어 스피킹 시험 대비 애플리케이션을 만듭니다. 시험 주최 기관에서 제공하는 모의고사로 시험 유형을 익히고, 영문 기사를 활용하여 만든 새로운 문제를 풀어보며 다양한 주제로 출제되는 시험에 익숙해지도록 돕습니다. AI가 사용자의 답변에 대한 자세한 피드백을 제공해 적은 비용을 투자해 효율적인 학습이 가능하도록 합니다. 마지막으로, 추후 다른 스피킹 시험(토익 스피킹, 아이엘츠 등) 으로 확장 가능하며, 영어뿐만이 아닌 다른 언어의 다양한 시험까지도 확장 가능하다. <br> |
| (9) 데모 내용 | 1. 회원가입/로그인<br> 2. 메인 <br>3. Task1(유형1) 문제 풀이 및 피드백 <br> 4. 뉴스 기반 학습 및 피드백 <br> 5. 마이페이지에서 학습이력 조회 <br>|
| (10) 기타 |  |


 
[Return TOP](#list-of-teamsprojects)
 
# Team-30
| (1) 과제명 | [CATCHUP]<br>퓨터공학과 학생에게 맞춤형 선수 학습사항 자료를 제공해주는 LLM 챗봇 웹서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 30-일구어냄 |
| (3) 팀원 역할 분담 | 유영민(1976244): 리더, 데브옵스, 시스템디자인, 백엔드<br>강민아(1976002): 팀원, 프론트엔드, api 개발<br>임은지(1985086): 팀원, 데이터구조, 프롬프트 엔지니어링, vector DB, 백엔드 |
| (4) 팀 지도교수 | 이형준 교수님 |
| (5) 팀 멘토 | 이경은 / 클라우드네트웍스 / 과장 |
| (6) 과제 키워드(keywords) | LLM 챗봇, 맞춤형 학습자료, RAG |
| (7) 과제 내용 요약 | CATCHUP은 선수과목을 제때 듣지 못해서 전공 과목 진도를 따라잡는 데에 어려움을 겪는 컴공생들을 대상으로, 개인에게 꼭 필요한 개념만 선별하여 학습자료를 제공하는 LLM 챗봇 웹서비스이다. 기존 방식과 비교했을때, <br>첫째, 학습의 형식에 차별을 두었다. 선수학습사항을 과목 단위의 통강의가 아닌 개념 단위의 학습자료 형식으로 개편했다.  <br>둘째, 학습할 내용을 추렸다. 프롬프트 엔지니어링을 통해 사용자에게 필수적인 개념들만 선별했다.<br>마지막으로, 학습 방향성을 개선했다. 일방적 강의에서 벗어나, langchain 등을 통해 맥락을 인지한 맞춤형 상호작용을 보장했다.  |
| (8-1) 과제: 문제의 정의 | 선수 학습 사항을 충족하지 못한 컴퓨터공학과 학생들은 전공 강의를 수강하는 데에 많은 어려움을 겪는다. 설문조사 진행 결과, 수강신청 실패 및 휴학 등의 이유로 전공 기초 과목을 권장학기에 듣지 못한 학생들의 83%가 부족한 부분을 혼자 공부하다가 포기한 경험이 있다고 응답했다. 교내 교육혁신 센터 전문가 또한 "특히 문과 출신 학생들이 해당 어려움을 겪는 경우가 자주 목격되나, 이를 완화할 별도의 시스템이 전무하다"고 지적했다. 또한, 통계에 의하면 학생들이 채택하는 대표적인 임시방편책은 선수과목을 전공서적 및 외부 인터넷 강의(KMOOC)로 학습하는 방식이다. 이때, <b>형식, 내용, 방향성</b> 총 3가지 측면에서 세부문제가 발생한다. <br><br><b>1. 과목 단위, 통강의 형식</b><br>전공과목에서 요구하는 선수학습사항은 강의계획서에 과목 단위로 기재된다. 이를 충족하기 위해서는 일반적으로 1시간 내외 분량의 강의를 30강의 가량 수강해야 하는 부담이 있다. <br><br><b>2. 불필요한 내용</b><br>선수과목은 희망전공과목에서 다루지 않는 다양한 개념까지도 모두 포괄한다. 그러나 학생들은 어떤 개념이 자신이 들을 전공과목과 관련이 있는지 분별할 능력이 없기에, 당장 필수적이지 않은 개념들까지 공부하는 수밖에 없다. <br><br><b>3. 일방향성</b><br>공부하다가 모르는 것이 생겨도 질문할 창구가 존재하지 않는다. 학습 도중 난관에 봉착하면 학습 흐름이 쉽게 끊긴다. |
| (8-2) 과제: 기존연구와의 비교 | 교육 분야에서의 상용화된 AI 활용 서비스 각각 다음과 같은 이점을 가졌으나, 이들 모두 타겟층이 대학생이 아니거나, 컴퓨터 공학 도메인을 벗어났다는 치명적인 한계를 공통적으로 지녔다. <br><br><b> case 1. 학습 단위를 개념으로 파편화하다 - 교원 아이캔두 수학 (AiCANDO) </b><br>AI를 활용하여 사용자가 취약한 부분을 개념 단위로 세분화하여 파악한다. 다만, 다루는 범위가 초등수학에 국한되어 있다. <br><br><b> case 2. 사용자에게 필요한 내용만 제시하다 - EBSi 인공지능 DANCHOO</b><br>고등학생 수험생 이용자의 EBSi 이용기록을 기반으로 맞춤형 문제를 추천한다. 즉, 이미 잘 알아서 풀 필요가 없는 문제를 제외하고, 자주 틀리는 문제만 선별하여 제시한다. 그러나 문제를 풀면서 생기는 의문을 서비스 내에서 해결해주지 못한다는 점이 한계로 꼽힌다. <br><br><b> case 3. 질의응답을 보장하다 - 키위AI (KEEwit)</b> <br>GPT 기반 글쓰기 교육 챗봇으로, 사용자가 작성한 글에 대해 챗봇과 대화할 수 있다. |
| (8-3) 과제: 제안 내용 | CATCH UP 프로젝트의 목표는, 컴퓨터공학과 학생들이 방학 동안 선수학습사항을 충족하여 학기 중 전공 과목을 성공적으로 이수하도록 하는 것이다. 이를 위해 크게 형식, 내용, 방향성 3가지 측면에서의 세부문제를 모두 해결한 웹서비스를 제안한다.<br><b>1.  필수 선수학습사항별 채팅방 생성</b><br>사용자가 강의실을 생성한 후 수강 희망 과목을 입력하면, 사용자의 희망수강과목과 연계되어 반드시 필요한 개념만 선별하여 각 개념별로 Chat창을 할당함으로써 학습 환경을 구축한다. 이때 사용자가 자신의 취약점을 고지하면, 이를 반영한 맞춤형 개념들을 제공한다. <br><b>2. 개념채팅방 내 학습자료 제공</b><br>개념채팅방에 입장하면, 해당 채팅방에 할당된 개념을 500자 내외의 텍스트로 설명하는 학습자료를 제공한다. 기존의 통강의 방식을 짧은 줄글로 대체함으로써, 형식을 대폭 간소화한 것이 차별점이다. MIT Opencourseware 제공 자료들을 참고하여 공신력 있는 내용을 보장한다. <br><b>3. 실시간 Q&A</b> <br>CATCHUP이 제공한 자료로 공부하던 학생이 헷갈리는 부분을 질문하면 대답해준다. |
| (8-4) 과제: 과제의 주요 기능 | <b>1. 개념별 학습자료 제공 모듈</b> <br>: 첫째, 학습자료 제공 시 Hallucination을 제어하기 위해 RAG(Retrieval Augmented Generation)를 활용했다. 컴퓨터공학 전공 강의 자료를 chunk embedding시켜서 vector DB를 형성한 후 사용자가 질문을 하면, 우선 그 질문을 벡터화 시킨 뒤 vector space에게 전달해서 유사도 검사를 통해 질문과 가장 관련 있는 문맥을 추출하고, 언어모델이 그것 참조하여 사용자의 질문에 적절히 답변하도록 설계했다. <br><b>2. 필수 선수학습사항 선별 모듈</b> <br>: 둘째, LLM이 해당 과목과 관련된 필수적인 개념들만 선별하도록 프롬프트 엔지니어링을 활용했다. zero-shot prompt 등의 기술을 적용했다. <br><b>3. QnA 모듈</b> <br>: 셋째, langchain 을 활용하여 챗봇이 기존의 대화의 내용을 기억하여 사용자의 수준과 약점사항들을 참고하여 맞춤형 학습자료를 생성하게끔 했다. 챗봇이 기존 대화를 vectorDB에 저장하면, 각 개념별 학습자료를 생성할때 미리 해당 DB를 참조하여 혹 사용자가 어려워하는 부분이라면 조금 더 상세히 설명하도록 설계했다.  |
| (8-5) 과제: 구현 방법 | <b>[시스템 구조도]</b>![구조도](https://github.com/ekhyoo/CapstoneDesign-24-1H/assets/124029562/c85877cd-589d-45bc-b300-49ecb9bffd08)Server의 BackEnd는 FastAPI를 바탕으로 구현되었으며, 3개의 메인 모듈이 존재한다. 모두 Langchain과 OpenAI의 ChatGPT4에 의존한다. <br><b>1. Concept Filter</b>  : user가 입력한 수강희망과목이 frontend를 거쳐 concept filter로 전달된다. 해당 과목과 관련된 개념들만 선별 후, 회원정보를 관리하는 MongoDB에 저장함으로써 해당 user에게 개념 채팅방을 할당한다. <br><b>2. Retriever</b> : user가 접속한 채팅방에 할당된 개념이 frontend를 거쳐 Retriever로 전달된다. 컴퓨터공학 자료를 구축해놓은 Vector DB에 해당 개념과 연관 있는 자료를 쿼리하여 관련 있는 문맥을 추출하고, 이를 바탕으로 LLM을 통해 학습자료를 생성한다. <br><b>3. Chat Service</b> : user가 입력한 질문 채팅이 frontend를 거쳐 Chat Service로 전달된다. 이때 Langchain을 통해 한영번역 등을 거친 후 산출된 최종답변을 리턴한다.|
| (8-6) 과제: 세부 기술 | <b>1. 개념별 학습 자료 제공</b><br>사용자가 시작하기 버튼을 클릭하면 프론트에서 백엔드의 post_new_concept_supplement() 를 호출한다. 백엔드는 사용자를 확인하고(DB), langchain_learningmaterial()을 호출한다. langchain_learningmaterial()는 vectorDB에서 학습자료의 신뢰성을 높이기 위한 관련 주제의 외부자료(RAG), 프롬프트, GPT 를 이용해 학습자료를 생성해 반환한다. 학습자료는 프론트를 거쳐 사용자에게 제공된다.<br><br><b>2. 필수 선수학습사항 개념 선별</b><br>사용자가 학습 희망 과목을 입력하면, 프론트에서 백엔드의 post_new_chat() 를 호출하며 시작된다. 이때 입력받은 학습 희망 과목을 인자로 전달하며, 사용자 구분은 메시지 헤더에 토큰을 담아 전달한다. 호출받은 백엔드에서는 사용자 확인 후(DB) 학습 희망 과목 classroom 객체를 만들고(DB) langchain_conceptlist()를 호출한다. 이때 인자로는 학습 희망 과목을 전달하고, 프롬프트를 추가해서 gpt를 거쳐 개념의 목록을 반환한다. 프론트에서는 사용자가 학습할 개념의 목록을 개념 챗방 생성을 통해 사용자에게 보여준다.<br><br><b>3. Q&A</b><br>사용자가 질문을 하면 프론트에서 벡엔드의 post_new_concept_qna()를 호출한다. 이때 질문내용을 인자로 전달하며, 사용자 구분은 메시지 헤더에 토큰을 담아 전달한다. 호출받은 백엔드에서는 DB에서 사용자가 존재하는지 확인하고, 사용자 정보를 받아온다. 질문의 정확한 맥락 파악을 위해 사용자의 해당 챗방에서의 기존의 대화를 DB에서 받아와 lanchain_qna()를 호출한다. 질문은 기존대화와 프롬프트와 함께(chained request) gpt 에 전달되고, 답변 또한 형식과 언어를 정리한 뒤 백엔드에 반환한다. 질문과 답변을 DB에 저장하고, 답변은 프론트단을 거쳐 사용자에게 제공된다. |
| (8-7) 과제: 기대 효과 및 의의 | <b>1. 형식 간소화로 인한 학습부담 완화</b><br>기존 과목 전체가 아니라 개념 단위로 학습 틀을 간소화하여, 공부 시작 전 학생들의 심리적 허들을 완화함으로써 진입장벽을 해소하는 효과를 기대할 수 있다. <br><br><b>2. 불필요한 개념 소거를 통한 학습량 축소</b><br>전공과목과 무관한 선수과목 개념들은 학습범위에서 생략함으로써, 절대적인 학습량을 대폭 줄이는 이점을 누릴 수 있다. 이로써 이용자들은 시간과 자원을 크게 절약할 수 있다. <br><br><b>3. 실시간 답변을 통한 학습의 연속성 유지</b><br>난관에 봉착해도 실시간으로 도와주는 챗봇을 통해 학습의 흐름을 원활히 지속해내갈 수 있다. <br><br>종합적으로, 학생들은 CATCHUP을 통해 전공과목 이수를 위한 사전 준비를 부담없이 효율적으로 해낼 수 있을 것이다. CATCHUP은 강의실에서 누구 하나 뒤처지지 않도록, 모두가 배움의 즐거움을 누리는 데 기여할 것이다. 이후, 실제 학생들이 느끼기에 CATCHUP이 희망하고자 하는 과목 학습에 필수적인 개념을 선별하는지 확인하고자, 데모 버젼을 이용해 학생들을 대상으로 설문조사를 진행하였고, 83% 이상 그렇다는 답변을 얻을 수 있었다.|
| (9) 데모 내용 | <b>1. 학습사항 선별 기능</b><br>사용자가 희망 수강 전공과목에 대해 챗을 입력하면, 챗봇이 그와 관련된 필수 선수학습사항을 제시하여 각 개념 챗방을 생성한다.<br><b>2. 학습 자료 생성 기능</b><br>개념 챗방 입장 시 학습 자료를 제공한다.<br><b>3. Q&A 기능</b><br>학습자료에 대한 질문을 하면 해당 학습 자료를 바탕으로 챗봇이 답변해준다.   |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-31
| (1) 과제명 | DreamGuard: 더 좋은 잠을 위한 수면장애 위험도 진단 및 수면 트래킹 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 31-BCS |
| (3) 팀원 역할 분담 | 박연주(2076153): 팀장, AI모델 architecture 및 개발 및 총 책임<br>김원정(2176083): 팀원, 데이터 저처리, DB 백엔드 개발 총 책임<br>류진(2071023): 팀원, 모델 training, 앱 프론트엔드 개발 총 책임 |
| (4) 팀 지도교수 | 심재형 교수님 |
| (5) 팀 멘토 | 견종서/일마그나/이사 |
| (6) 과제 키워드(keywords) | 수면 무호흡증, 심전도, 수면호흡음 |
| (7) 과제 내용 요약 | <br> DreamGuard는 수면다원검사를 받기 어려운 사람들과, 수면장애 판정을 받은 후 지속적인 관리를 원하는 사람들을 대상으로 하는 심전도 및 수면 호흡음 파일을 활용한 수면장애 위험도 진단 및 수면 습관 트래킹 서비스임. |
| (8-1) 과제: 문제의 정의 | 수면장애 인구가 급속도로 증가하고 있는데 수면장애 치료에 중요한 3가지 요소인 인지, 진단, 지속적 관리 면에서 각각 문제점이 관찰됨. 제한적 의료 급여 정책으로 인한 접근성 문제, 낮은 판독 일관성으로 인한 위음성 문제, 수면 주기 트래킹 미비로 인한 지속성 문제가 있음 |
| (8-2) 과제: 기존연구와의 비교 | 현재 알라미, Sleep Cycle, Pillow 등 수면 주기 위주의 트래킹을 제하는 어플리케이션이 시장에 나와있음. 그러나 이러한 수면 트래킹을 수면장애 위험도 및 개선 상황과 연계하는 서비스는 미비함 |
| (8-3) 과제: 제안 내용 | 접근성 및 판독 일관성 문제 해소를 위해 수면 호흡음 및 ekg 데이터에 대한 판독 자동화와 OSA(수면 무호흡증) risk를 산출하는 AI 모델을 기반으로 한 수면 습관 트래킹 서비스를 제안함 |
| (8-4) 과제: 과제의 주요 기능 | - 수면장애 위험도 산출 AI/판독 자동화 모델(사용자가 자신의 심전도와 수면호흡음을 전송하여 수면 장애 진단)<br>- 사용자 맞춤 수면 패턴 분석 및 수면장애 위험도 기반 트래킹 서비스 (현재 수면 패턴, 수면 패턴 개선 현황 조회 / 알람, 잘 시간 알림 서비스) |
| (8-5) 과제: 구현 방법 | 1. 수면장애 위험도 산출 AI 모델: 본 어플리케이션은 하루치의 수면호흡음(EDF 형식)과 심전도 데이터(EKG 형식)를 활용하여 사용자의 수면장애 위험도 수준을 백분위로 나타냄. 이를 위해 과기부 산하 AI hub에서 제공하는 자가수면검사 데이터셋을 활용함. 해당 데이터는 총 4개의 병원에서 이루어진 1142건의 수면 호흡음 및 심전도 데이터 및 그에 대한 환자별 라벨링 데이터를 포함하고 있음. OSA risk 유무 및 수면 데이터를 활용하여 개발 및 학습된 수면장애 위험도 산출 AI 모델은 새로운 데이터가 들어왔을 때 기존 학습결과와의 유사성 등을 판독하여 위험도 수준을 산출할 수 있음.<br>2. 판독 자동화 모델: 현재 수면다원검사의 급여 기준은 OSA 등의 수면장애 진단을 기준으로 하고 있으므로 수면다원검사의 높은 일치율과 정확도가 중요함. 그러나 수면호흡음이나 EKG 데이터 등의 판독을 모두 수작업으로 진행하기 때문에 숙련도 차이에 따른 일관성 부족이 발생함. 이는 위음성 등의 문제점을 야기할 수 있으며, 소비자 입장에서의 부담을 가중함. 그러므로 기계학습을 통해 수면호흡음과 EKG 데이터에 대한 높은 판독 일관성을 도출할 수 있도록 함.<br>3. 사용자의 수면 데이터 및 서버 관리: 안정적인 백엔드 서버 구축 및 JWT 토큰 방식의 데이터 보안 강화책을 통해 사용자의 수면 호흡음 및 심전도 파일을 안전하게 관리함. 1과 2의 AI 모델을 API로 구현하여 서버 관리의 전반적인 안정성 또한 증대함.<br>4. 수면 습관 Weekly report: 수면장애의 지속적인 관리 및 수면의 질 증대를 위해, 일자별 데이터를 Google Sleep API를 활용하여 일주일 단위의 수면 레포트를 제공함. 유저 친화적 UI/UX를 통해 사용자가 그날의 수면이 평균치에 부합하는지, 개선되었거나 악화되었는지를 확인할 수 있도록 하여 추가적인 조치가 필요한지 유무를 판단할 수 있도록 도움. |
| (8-6) 과제: 세부 기술 | 1. 데이터 처리: 연구에 사용될 수면 데이터셋은 IRB 승인 후 AI-hub를 통해 확보되어야 하며, edf 파일 형식의 데이터를 처리할 수 있는 라이브러리가 필요함. Biosppy, MNE를 통해 생물학적 정보를 처리함. Scipy, Sckit-learn을 통해 EDF 파일 형식의 데이터를 처리함. Google Sleep API (Open API)를 통해 사용자의 수면 시간과 수면 질을 수집함.<br>2. 서버 관리: 사용자의 데이터를 안전하게 저장할 수 있어야 하며, 사용자 경험을 향상시킬 수 있는 서버가 필요함. Django와 MariaDB를 통해 백엔드 서버를 개발함. AWS S3를 통해 대용량 데이터를 안전하게 저장함.<br>3. AI 모델의 정확도: 자가수면검사 AI 모델은 수면무호흡증 위험도를 계측함. 연합학습 방식을 사용하여 프라이버시를 유지하면서 모델의 정확도를 높임. PyTorch를 이용한 기계학습. 90% 이상의 정확도를 목표로 함.<br>4. 연합학습 구현: Non-IID 데이터 문제를 해결하면서 연합학습을 적용해야 하며, 이를 위한 알고리즘은 분산된 데이터로부터 효율적으로 학습할 수 있어야 함. 중앙 집중형 모델과 비교하여 90% 이상의 정확도를 달성해야 함.<br>5. 어플리케이션 개발: 어플리케이션은 사용자의 수면 상태 데이터를 수집하고, 수면무호흡증 위험도를 사용자에게 피드백할 수 있는 인터페이스를 제공함. 프론트엔드는 React Native로, 백엔드는 django를 사용하여 개발함. Nginx와 Gunicorn을 이용한 서버 호스팅. AI 모델을 서빙하는 API는 Flask로 개발함. 보안은 사용자의 민감정보를 보호할 수 있어야 하며, Django JWT를 이용해 회원 보안을 향상함 |
| (8-7) 과제: 기대 효과 및 의의 | 1. 수면장애 고위험군 치료 확률 증대: 본 어플리케이션은 사용자의 수면호흡음 및 심전도 데이터를 분석하여 수면장애 위험 수준을 이해하기 쉽게 구현하여 제시함. 이러한 판독 결과를 기반으로 수면장애 고위험군이 증상을 인지하고 병원에 내방하여 치료를 받기까지 소요되는 시간을 줄일 수 있음. 백분위 숫자가 적으면 적을수록 의료 급여 정책에서 소외될 확률 또한 적으므로 현재 치료가 필요한 인구가 적기에 의학적 도움을 받기를 기대할 수 있음.<br>2. 지속적인 관리를 통한 수면 습관 개선 용이: 수면장애 진단을 받는다고 하더라도 매일 병원에서 수면 습관을 확인하기는 불가능에 가까움. 본 어플리케이션은 축적된 사용자의 데이터를 한눈에 보기 쉬운 그래프 형태로 제공함. 이러한 기능을 통해 사용자는 지난주, 혹은 지난달에 비해 본인의 수면 습관이 개선되었거나 악화되었는지에 대해 쉽게 인지할 수 있어 지속적인 관리가 가능함. |
| (9) 데모 내용 | 1. 회원가입 및 로그인 화면<br>2. 수면호흡음 및 심전도 측정 화면<br>3. 수면호흡음 및 심전도 검사결과 화면<br>4. 프로필화면<br>5. 수면트래킹 화면 |
| (10) 기타 |  |



 
[Return TOP](#list-of-teamsprojects)
 
# Team-32
| (1) 과제명 | HobHub: 일상 속 활력 충전을 위한 AI 기반 취미 추천 및 취미 기록 아카이빙 웹 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 32-머니캐처 |
| (3) 팀원 역할 분담 | 박유진(2176149): 리더, 백엔드 개발, aws 서버 배포, 추천 알고리즘 개발<br>최예빈(2176382): 팀원, 프론트엔드 React 개발, UX/UI 디자인, 데이터 크롤링, 챗봇 개발<br>박혜진(2176161): 팀원, 플라스크 서버 구현, 추천 알고리즘 개발, 챗봇 개발 |
| (4) 팀 지도교수 | 이형준 교수님 |
| (5) 팀 멘토 | 하광림 / 씨에스리 / 이사 |
| (6) 과제 키워드(keywords) | 맞춤형 추천, 취미, 아카이빙 |
| (7) 과제 내용 요약 | 맞춤형 추천 알고리즘을 기반으로 사용자에게 최적인 취미를 제공하여 간편하고 빠르게 취미활동을 시작할 수 있도록 돕는 서비스이다. 사용자가 챗봇을 통해 자신의 정보를 입력하면 취미를 추천받을 수 있을 뿐만 아니라 추천받은 취미를 공유하고 저장하는 아카이빙 서비스 또한 제공한다. |
| (8-1) 과제: 문제의 정의 | 개인마다 각자의 취향도 다르고 취미를 즐기는 목적도 다를텐데, 자신에게 맞는 취미를 찾기까지 소요되는 시간적 비용과 경제적 비용이 크다는점은 취미를 시작하는 사람들에게 어려움을 줄 수 있다. 또한 취미에 대한 정보가 너무 많고 여기저기 흩어져있기 때문에 취미를 시작하려고 해도 어디서 어떻게 시작해야할 지 모르는 경우가 있다. 그리고 취미를 새로 시작한다 해도 동기부여가 없어 지속적인 취미생활을 하기 힘들다는 문제점이 있다. |
| (8-2) 과제: 기존연구와의 비교 | 클래스101 : 온라인 강의를 제공하여 시간과 장소에 구애받지 않고 취미생활을 즐길 수 있도록 돕는 서비스이다. 온라인 강의와 준비물키트까지 함께 제공하여 사용자들이 언제 어디서든 취미생활을 즐길 수 있다는 강점이 있다. 이용자 사전 수요조사를 통해 수강자가 충분할 것이라고 확인되는 클래스만 개설하는 방식으로 서비스를 운영하여 수요가 적은 취미 활동들은 즐길 수가 없다는 약점이 있다.<br>솜씨당 : 지역기반 공방정보와 가격을 고객에게 제공하여 가까운 곳에서 취미생활을 즐길 수 있게 하는 서비스이다. 온라인과 오프라인을 연결해주는 o2o 서비스를 운영하여 실제 운영되고 있는 공방의 원데이클래스를 예약할 수 있는 플랫폼을 제공하고, 비대면을 원할경우 공방과 고객사이의 라이브강의가 가능한 플랫폼을 제공한다는 강점이 있다. 수공예 관련한 클래스들에만 집중되어 있어 다른 카테고리는 부실하다는 약점이 있다. |
| (8-3) 과제: 제안 내용 | 첫번째, 취미를 시작하는데 들이는 시간적, 경제적인 비용을 최소화하기 위해 사용자의 상황을 반영한 맞춤형 취미를 추천한다. 사용자의 나이대, 성별, 사는곳, 소득, 시간적여유, 그리고 취미를 하는 목적을 반영해서 사용자와 가장 유사한 조건에 있는 유저의 취미를 추천해준다.<br>두번째, 취미를 쉽고 빠르게 시작할 수 있도록 원데이클래스 사이트에서 크롤링한 원데이클래스 목록을 제공한다.<br>마지막으로 사용자에게 지속적인 취미생활의 동기부여를 제공하기 위해 취미 아카이브에 자신의 취미생활을 기록하고 공유할 수 있도록 한다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 추천 알고리즘: 사용자의 정보를 입력받아 사용자와 조건이 유사한 다른 사용자의 취미를 추천해주는 유사도 기반 추천 시스템, 사용자가 정보를 제공하고싶지 않은 경우는 자신의 기존 취미를 입력하여 추천받는 사용자기반 협업 필터링 알고리즘을 사용한다.<br><br>2. 원데이클래스 목록: 취미를 추천 받은 뒤, 그 취미를 빠르게 시작할 수 있도록  그에대한 원데이 클래스를 크롤링해 보여준다. 이때 사용자들이 중요하게 생각할만한 원데이 클래스의 위치, 가격, 난이도, 소요시간에 대한 정보들을 중점적으로 보여주도록 구현했다.<br><br>3. 취미 아카이빙: 사용자는 취미 아카이브를 통해 취미생활을 기록할 수 있고, 사용자와 유사한 특징을 가진 다른 사용자들이 남긴 취미 기록을 확인하고 공유할 수 있다. |
| (8-5) 과제: 구현 방법 |1. Dialogflow를 이용한 챗봇 서비스<br>사용자는 Dialogflow를 사용해 구현한 챗봇을 통해 자신의 정보를 입력한다. 사용자는 자신의 성별, 사는지역, 취미를 하는 목표, 주중 취미를 즐길수 있는 시간 등을 입력하거나, 이미 기존 취미가 있는 경우에는 자신이 원래 가지고 있던 취미를 입력한다. 이렇게 입력한 정보는 Flask로 전달되어 추천 알고리즘의 입력값으로 들어간다.<br>2. 2가지 추천 알고리즘으로 취미 추천<br>Flask에서 유사도 기반 알고리즘을 통해 사용자의 기존 정보가 없는 경우, 챗봇으로 사용자의 정보를 입력받아 사용자와 조건이 가장 유사한 다른 유저의 취미를 추천해준다. 또한 기존의 취미가 있는 경우 협업 필터링을 사용해서 취미를 추천한다. 추천한 결과는 react를 통해 웹사이트에 보여지고, 취미 추가하기를 누르면 유저정보와 취미가 백엔드 스프링에 저장된다.<br>3. 추천받은 취미에 대한 원데이클래스 목록 제공<br>사용자가 취미를 추천받으면 Flask에서 실시간으로 사용자의 취미에 대한 원데이클래스를 불러온다. 이는 BeautifulSoup을 이용한 실시간 크롤링 기법을 사용하였으며, 사용자의 편의를 위해 원데이클래스의 가격대, 소요시간, 난이도 순으로 보여준다.<br>4. 취미 아카이빙 서비스<br>추천받은 취미에 대한 기록을 남길 수 있다. aws에서 제공하는 rds 서버를 통해 사용자의 정보를 관리하고 사용자가 남긴 취미기록 또한 저장하고 관리합니다.<br>5. 피드백 기능<br>추천받은 취미에 대한 피드백을 반영할 수 있다. 사용자는 챗봇을 통해 추춴받은 취미에 대한 평점을 남길 수 있고, 이는 다음 추천때 반영되어 더욱 정교한 추천을 해줄 수 있다.|
| (8-6) 과제: 세부 기술 | **1. 유사도 기반 알고리즘**<br>추천 알고리즘에서 흔히 발생하는 콜드스타트 문제를 해결하기 위해 도입한 알고리즘이다. 사용자가 서비스를 처음 사용하는 경우, 정보가 없어 추천해주지 못하기 때문에 먼저 챗봇을 이용해 사용자의 정보를 입력받는다. 유클리디언 유사도 기법을 써서 사용자가 입력한 정보와 가장 유사한 사용자를 찾고, 그 사용자가 가진 취미를 추천해주고 그에 대한 유사도가 몇퍼센트 나오는지 출력되도록 구현했다.<br>**2. 사용자기반 협업 필터링 알고리즘**<br>원데이클래스 사이트인 솜씨당에서 크롤링한 데이터를 바탕으로 구현했다. 사용자들이 경험한 취미와 경험하지 않은 취미들에 대한 데이터인데, 사용자들이 경험했던 취미를 5, 경험하지 않았던 취미는 3으로 두었다. 새로운 사용자가 자신이 기존에 했던 취미를 고르면, 다른 사용자들의 데이터와 비교해 가장 유사도가 높은 취미를 추천하도록 구현했다. 추천받은 취미의 벡터값은 5가 되지만 이 벡터값은 추후 피드백을 통해 조정될 수 있어서 만약 추천받은 취미가 잘 맞지 않았다면 피드백을 통해 값을 더 낮은 값으로 조정할 수 있다.|
| (8-7) 과제: 기대 효과 및 의의 |**1. 더 개인화된 취미 추천**<br>기존의 다른 서비스과 비교했을 때, 사용자의 상황을 최대한 반영해 더욱 개인화된 맞춤형 취미를 추천해주고자 한다. 사용자의 기존 취미를 반영하기도, 소득이나 위치 등과 같은 개인적인 정보들을 반영하기도 해, 이러한 데이터를 추천 알고리즘에 활용하고 있다. 또한, 취미 추천을 해준 이후에도, 챗봇을 통해 취미에 대한 피드백을 남길 수 있는 기능을 추가했고, 추후 최종발표에는 이러한 피드백이 취미 추천에 반영되어 추천 기능을 한층 더 개선하고자 하고 있다.<br>**2. 보다 다양한 취미에 대한 기회 제공**<br>취미에 대한 데이터 중 사용자에게 필요한 것들을 중점으로 모아서 보여줄 수 있다는 점에서 사용자에게 보다 많은 기회를 제공한다는 의미가 있다. 우리 서비스는 추천 받은 취미에 대한 실시간 원데이 클래스 정보를 제공해 원하는 취미를 쉽게 선택하고 즐길 수 있게끔 하고 있다. 또, 아카이브 기능을 통해 사용자들이 자신의 취미 기록을 공유할 수 있기 때문에 자신과 비슷한 조건을 가진 유저가 어떤 취미를 가지고있는지 알 수가 있어서 사용자들은 자신이 추천받은 취미 뿐만 아니라 더 다양한 취미를 접할 수 있다.|
| (9) 데모 내용 |1. 먼저 챗봇으로 사용자가 취미 추천을 받는 것으로 시작된다. 챗봇에게 인사를 건네고 취미 추천 받기 버튼을 선택한다.<br>기존 취미가 없는 사용자라는 가정 하에 그에 따라 성별, 나이, 위치, 소득, 목적, 주중/주간 시간에 대한 정보를 입력한다.정보 입력이 완료되면 취미 추천 페이지로 이동해 유사도 기반 알고리즘을 통해 산출된 추천 취미들을 볼 수 있다.<br>2. 그 다음 기존 취미가 있는 사용자라고 가정을 하고 (1)과 마찬가지로 챗봇을 통해 추천을 받아본다.<br>기존 취미를 개수 제한 없이 선택한 뒤 선택 완료 버튼을 누르면 협업 필터링 알고리즘을 통해 산출된 추천 취미들을 확인 할 수 있다.<br>3. 다음은 취미를 기록하는 아카이브 기능이다.<br>추천받은 취미 리스트에서 서랍장에 추가하기 버튼을 누르면 해당 취미 폴더가 추가된 것을 확인 할 수 있다. 그리고 폴더 안에 들어가면 사진을 첨부하는 등 그 취미와 관련된 기록을 남길 수 있다.|
| (10) 기타 | 시스템 아키택처![제목 없음](https://github.com/beenvyn/CapstoneDesign-24-1H/assets/109021332/dd0b7580-15f4-4fa5-a297-53e5e6be8d4c)|
 
[Return TOP](#list-of-teamsprojects)
 
# Team-33
| (1) 과제명 | 공유니폼 : 야구 팬을 위한 사용자 기반 추천 유니폼 대여 앱 및 대여 자판기
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 33-Donuts |
| (3) 팀원 역할 분담 | 권가현(2071059) : 리더, 백엔드, UI 기획, 경기 기록 기반 선수 추천 알고리즘<br>김선우(2076052) : 팀원, 백엔드, UI 기획, 사용자 간 유사도 기반 유니폼 추천 알고리즘<br>유지우(2076269) : 팀원, 프런트엔드, UI 디자인, 사용자 응답 기반 선수 추천 알고리즘 |
| (4) 팀 지도교수 | 박상수 교수님 |
| (5) 팀 멘토 | 이강현 / 돌핀씨엔씨 / 사업본부장 |
| (6) 과제 키워드(keywords) | 야구유니폼, 대여, 자판기 |
| (7) 과제 내용 요약 | 공유니폼은 비싼 야구 유니폼을 합리적인 가격으로 대여해주어 야구 직관을 더욱 즐기도록 도와주는 서비스입니다. 어플을 통해 유니폼의 디자인과 선수 이름, 등번호를 선택하고 결제합니다. 이후 발급된 QR 코드로 IOT 자판기에서 유니폼을 수령합니다. 저희는 이용자의 선택을 돕기 위해 야구 선수 및 유니폼을 추천해주는 알고리즘을 도입했습니다. 선수 기록 분석 및 다른 이용자들과의 유사도를 통해 이용자에게 적합한 선수와 디자인을 추천합니다. |
| (8-1) 과제: 문제의 정의 | 야구장에 가면 대부분의 팬들이 유니폼을 입고 응원합니다. 야구를 가끔 즐기는 사람들에겐 13만원이 넘는 유니폼 가격이 부담스러울 수 밖에 없습니다. 저희는 모든 사람이 야구 문화를 온전히 즐기도록 합리적인 가격에 유니폼을 대여해주는 서비스입니다. 또한 저희는 자판기와 어플을 통해 대여하는데 필요한 시간을 줄이고 어디서든 대여가 가능하게 도와줍니다. 또 야구 유니폼을 구매할 때 유니폼 선택지의 폭이 너무 넓다는 문제가 있습니다. 팬들은 좋아하는 선수와 디자인 역시 선택해야 하기 때문에 비싼 유니폼 구매를 앞두고 어떤 유니폼을 고를 것인가에 대해 많은 고민을 하게 됩니다. 따라서 비싼 가격과 넓은 선택지는 야구 팬들로 하여금 유니폼 구매를 망설이게 만들고 다양한 유니폼을 경험하는 것을 어렵게 만들고 있습니다. |
| (8-2) 과제: 기존연구와의 비교 | 1. 기존의 유사한 야구 유니폼 대여 서비스는 블로그 댓글로 유니폼 대여를 신청 한 후 다음날 야구장에서 수령하는 서비스가 있습니다. 하지만 이 서비스의 경우 인건비가 많이 필요합니다. 특히 블로그 댓글은 판매자가 일일이 종류 및 사이즈를 기록해야 한다는 불편함이 있습니다. 수동 기록이라 실수가 생기기도 합니다. <br>2. 다른 경우로, 보증금 1만원을 받고 축구단에서 유니폼을 이벤트성으로 대여해준 적이 있습니다. 이 서비스는 이벤트를 통해 축구장 관중 유입 효과를 노렸으며 기존 팬들도 입어보고 싶던 유니폼을 입는 등 좋은 반응을 이끌어냈습니다. 따라서 저희 서비스에서 역시 비슷한 효과를 기대할 수 있습니다. |
| (8-3) 과제: 제안 내용 | 저희는 안드로이드 앱과 IOT자판기, 세 가지 추천 알고리즘을 통해 저희가 제안한 유니폼의 비싼 가격과 넓은 선택지라는 문제를 해결하려 합니다. 기존 서비스와의 비교를 통해 사람의 손이 많이 가는 부분도 최소화하여 인건비를 줄일 계획입니다. 또한 자동화를 통해 대여 과정이 간단해진다는 효과를 볼 수 있습니다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 공식 유니폼을 야구장에서 대여해주는 서비스<br>2. 야구 선수 및 유니폼을 추천하는 서비스<br>- 경기 기록 기반 선수 추천<br>- 사용자 유사도 기반 유니폼, 선수 추천<br>3. IoT 자판기를 통해 대여 과정을 자동화 하는 기능 |
| (8-5) 과제: 구현 방법 |대여 앱은 Android 앱을 만들어 대여 기능을 제공합니다. 화면 구성은 로그인, 팀 선택, 홈, 지도, QR, 마이페이지, 대여(선수, 디자인, 사이즈)가 있습니다. DB는 Mysql로 설계하였으며 서버로는 SpringBoot와 AWS를 사용해 구현합니다. 세 가지 추천 알고리즘 - 사용자 응답 기반 선수 추천 알고리즘은 컨텐츠 기반 필터링, 사용자 간 유사도 기반 유니폼 추천 알고리즘은 협업 필터링, 경기 기록 기반 선수 추천 알고리즘은 회귀 분석을 통해 선수와 유니폼을 추천하도록 구현합니다. |
| (8-6) 과제: 세부 기술 |대여 앱은 로그인, 팀 선택 화면 뒤에 홈화면부터는 네비게이션 바를 두고 홈, 대여, 지도, QR, 마이페이지 fragment를 두어 사용자가 원하는 화면으로 이동하도록 합니다. 이 때 사용한 외부 모듈로는 GoogleMap API와 QRzxing가 있습니다. DB에는 member, uniform, odlist, ufcode, user, team 등의 테이블을 두어 데이터를 관리하고 있으면 SpringBoot로 CRUD RESTFUL API를 작성하여 사용하였습니다. 세 가지 추천 알고리즘 - 사용자 응답 기반 선수 추천 알고리즘은 컨텐츠 기반 필터링을 사용해서 설문조사의 답변을 토대로 사용자가 좋아할 것 같은 선수를 추천하도록 구현합니다. 설문조사에서 좋아하는 선수가 있으면 응답해달라고 하였기 때문에 사용자 별로 중요하게 여기는 지표들을 feature로 삼아 해당 사용자가 선택한 선수를 응답에 매칭시키고 타겟 유저 기반으로 코사인 유사도를 계산했습니다. 사용자 간 유사도 기반 유니폼 추천 알고리즘은 협업 필터링을 이용해서 사용자와 비슷한 나이의 다른 사용자들에게 인기 많은 유니폼 디자인 추천합니다. 사용자의 나이, 성별 등의 feature를 바탕으로 협업 필터링을 이용하여 유니폼을 추천합니다. 예를 들면, 24살 여성인 A 유저와 비슷한 B 유저에게는 A 유저의 선택을 추천하도록 구현합니다. 경기 기록 기반 선수 추천 알고리즘은 STATIZ 데이터 크롤링과 회귀 분석을 통해 미래 경기에서의 선수 컨디션을 예측하도록 합니다. 저희가 만든알고리즘은 WRC+(우르크+) 를 기반으로 선수의 WRC+ 를 예측해 선수 가치를 판단합니다. 저희가 학습시키는 데이터 지표에는 OPS, wOBA, 그리고 장타, 출루, 안타 등이 있습니다. |
| (8-7) 과제: 기대 효과 및 의의 | 저희는 공유니폼 서비스를 통해 기존 야구팬들에겐 다양한 경험을 제공하는 것을, 그리고 신규 야구팬들을 더욱 유입시키는 것을 기대 효과롤 생각하고 있습니다. 야구 관람의 한 문화인 유니폼 착용에 대한 접근성을 좋게 만들어 구단과 팬들 모두 만족시켜 야구 문화 발전에 이바지 하고자 합니다. |
| (9) 데모 내용 | 안드로이드 앱에서 대여 과정을 데모하고 생성된 QR 코드를 미니 IOT 자판기 QR 리더기에 입력하면 해당 유니폼이 반환되는 과정을 데모할 계획입니다.|
| (10) 기타 | |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-34
| (1) 과제명 | 돈 워리(Be happy) - 예산 사용량 예측 AI 기반 일정 캘린더·가계부 통합 모바일 웹 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 34-고등어 |
| (3) 팀원 역할 분담 | 이규민(2076291): 리더, (백엔드) MySQL, Spring Framework, AWS, 데이터전처리<br>서선아(2003047): 팀원, (프론트엔드) Figma, React.js, AI<br>공채은(2176020): 팀원, (백엔드) OCR, MySQL, Spring Framework, AWS, AI |
| (4) 팀 지도교수 | 이민수 교수님 |
| (5) 팀 멘토 | 이성훈 / 나우썸 / 대표 |
| (6) 과제 키워드(keywords) | 예산, 일정, AI |
| (7) 과제 내용 요약 | "돈 워리(Be Happy)"는 일정과 소비 데이터를 학습시킨 AI 모델로 예산 사용량을 예측하고 사용자의 니즈에 맞게 한 달 예산을 분배하여 소비 습관이 잡히지 않은 사회초년생의 돈 관리를 돕는 서비스입니다. 일정과 가계부를 한 번에 작성함으로써, 각 일정이 소비생활과 직접적으로 연결됨을 보다쉽게 체감하고, 예산 예측량과 예산 사용 가능량을 비교하며 무분별한 소비를 경계합니다. 또한 친구와 예산 사용량(%)을 공유하고 자체 챌린지를 진행함으로써 돈 관리에 재미요소를 부여하고 리워드를 지급함으로써 동기부여 효과를 가져옵니다. |
| (8-1) 과제: 문제의 정의 | 건강한 소비활동에 대한 확실한 기준이 잡히지 않은 사회초년생은 카드 리볼빙이나 과소비 등의 위험에 쉽게 노출되어 있다. 사회초년생은 본격적인 경제활동을 시작함에 앞서 올바른 돈 관리 기준이 필요한 시기이다. 돈 관리에 스트레스와 번거로움을 느끼지 않도록 현명한 소비습관을 형성하면서 자산관리도 동시에 할 수 있는 차별화된 서비스가 필요하다. |
| (8-2) 과제: 기존연구와의 비교 | 기존 가계부 서비스와의 차별성 4가지<br>( banksalad, 편한가계부, 핀크, Uplanner, visual 가계부, 꼬박가계부, DAILY PAY 외 6개의 서비스를 분석해 4가지의 측면에서 차별성을 두었다.)<br><br> 1. 기록<br>기존에는 기록에 있어서 카드 연동과, 결제 내역을 자동으로 불러오는 기능이 있긴 하지만 가계부 관련 내역만을 불러오는데 돈워리는 가계부 내역과 일정 내역을 통합시켜 일정까지 관리할 수 있도록 하였다. 더불어 OCR기술을 도입해 편리하게 소비내역을 기록할 수 있도록 하였다.<br><br>2. 예산 기능<br>기존에는 예산을 손수 지출 카테고리별로 분배해야 했지만, 돈워리를 통해 일정내역을 통해서 머신러닝 알고리즘과 분배함수를 가지고 자동으로 분배해 좀 더 편리하게 만들어주고, 카테고리별 큰 분류뿐만 아니라 일정마다 세세하게 예산을 분배할 수 있도록 하였다. 또한 예산 목표를 설정할 때, 캐릭터로 시각화하여 차별화하였다.<br><br>3. 챌린지 기능<br>기존의 몇몇 챌린지 기능은 목표를 설정한 후, 친구와 함께 챌린지를 할 수 있는 기능이 있으나, 이와 차별화하여 예산 사용량을 공유하고, 리워드와 랭킹 기능을 추가하는 것뿐만 아니라, 모으고자하는 목표금액에 멀어지는 게 감지되면, 그날 하루의 미션 팝업을 제공해 행동으로 이어질 수 있도록 유도하는 기능을 추가했다. |
| (8-3) 과제: 제안 내용 | 1. 사용자가 등록한 일정과 소비내역 데이터를 바탕으로 소비 패턴을 분석하고, 각 일정에 대한 예산 사용량을 예측하고 제공한다. 또한 사용자의 니즈에 맞는 소비 가이드라인을 제시하여 한 달 예산을 적절하게 분배하여 사용하도록 돕는다. <br>2. 건강한 소비 습관을 보다 쉽게 구축하도록 가계부에 일상적으로 사용하는 일정 리스트 기능을 넣고, ocr 기술 적용해 소비 기록의 편의성을 높인다. 또한 사용량 공유, 챌린지로  친구와 서비스 사용을 함께함으로써 돈 관리에 적당한 동기부여와 재미를 제공한다. |
| (8-4) 과제: 과제의 주요 기능 | 1) 일정 데이터 CRUD<br>2) 가계부 기능 <br>: 수입/지출 데이터 CRUD<br>3) 예산 사용량 예측 기능<br>: 사용자의 일정-가계부 데이터로 학습시킨 다중선형회귀모델을 이용하여 새로운 일정에 대한 예산 사용량을 예측하는 기능. 일정 카테고리를 메인으로 사용한다.<br>4) 예산 분배 기능<br>: 사용자가 카테고리별 소비 가중치와 절약 정도를 직접 선택하면 각 일정 및 지출 카테고리에 대해 월별 예산을 분배해주는 기능<br>5) OCR 활용 지출 등록 기능<br>: OCR을 활용해 사용자의 결제 문자를 스캔해 가계부 지출에 입력해주는 기능<br>6) 통계 기능<br>: 사용자의 월별 사용량을 분석해 소비패턴을 한눈에 파악할 수 있도록 보여주는 기능<br>7) 챌린지 기능<br>: 사용자가 자신의 소비습관에 맞는 챌린지에 참여하며 돈관리에 재미를 주는 기능<br>7-1) 사용량 공유 기능<br>: 친구와 예산 사용량을 공유함으로써 돈 관리의 동기부여와 재미를 제공한다. |
| (8-5) 과제: 구현 방법 | 1. 모바일 웹 페이지<br>: React로 개발한다.<br> <br>2. 일정 관리 기능<br>: 데이터베이스에 일정을 등록하고, 조회하고, 수정하고, 삭제한다. CRUD 처리 로직은 Spring Boot로 구현한다. 메인화면에서 가계부 데이터와 함께 확인할 수 있다. <br> <br>3. 가계부 관리 기능<br>: 데이터베이스에 수입, 지출 내역을 등록하고, 조회하고, 수정하고, 삭제한다. CRUD 처리 로직은 Spring Boot로 구현한다. 메인화면에서 일정과 함께 확인할 수 있다. 특정 일정에서의 소비와 일반 소비는 분리된다.<br> <br>4. 예산 사용량 예측 기능<br>: 구글 코랩에서 scikit-learn를 이용해 일정 데이터와 가계부 데이터로 다중선형회귀모델을 학습시키고 flask api로 래핑하여 배포한다. API 서버에서 flask api로 해당 모델을 사용한다. 사용자가 새로 입력한 일정에 대한 예산 사용량을 예측하여 제공한다.<br> <br>5. 예산 분배 기능<br>: 백엔드 서버에서 구현한 비즈니스 로직이 일정, 소비내역, 예산 예측 데이터를 바탕으로 전체 예산에 대한 한달 예산 사용 계획을 제안한다. 사용자는 예산 분배 플랜 화면에서 전체 예산 절약 정도, 매일 절약 금액, 카테고리별 절약 정도 중 원하는 것을 선택할 수 있다. <br> <br>6. OCR 소비 스캔 기능<br>: 소비 등록 화면에서 결제 문자 캡쳐 사진을 업로드하여 자동으로 지출을 등록한다. OCR이 사진에서 인식한 텍스트를 전달하면 백엔드 서버에서 가계부 등록과 같은 방식으로 데이터를 처리하고 데이터베이스에 저장한다. <br> <br>7. 챌린지 기능<br>: 데이터베이스에서 사용자가 진행 중인 챌린지를 조회해 데이터를 가져온다. 사용자는 챌린지 화면에서 자신의 챌린지를 확인하고 새로운 챌린지를 진행할 수도 있다. <br>1) 예산 사용량 챌린지: 이메일로 친구를 초대해 서로의 예산 사용량을 공유한다. 친구와 나의 예산 사용량을 막대그래프로 한눈에 비교하고 확인할 수 있다. 데이터베이스에서 사용자의 친구 목록과 해당 친구의 예산 대비 사용량을 불러온다. <br>2) 친구와 함께 진행하는 챌린지: 친구로 저장되어 있는 사용자와 최종 목표, 기한 등의 데이터를 포함한 공통 챌린지를 등록하고 진행한다. <br>3) 목표 금액 달성률: 목표 금액을 얼만큼 달성했는지 막대그래프로 보여준다. <br>4) 한달 목표 금액 달성 여부: 매달 목표금액을 달성했는지 월별로 여부를 보여준다. <br>5) 하루 n원 챌린지 m번: 이번 달에 하루 n원 챌린지(예: 하루 만 원 챌린지)를 몇 번 진행할 것인지 목표를 설정하고, 현재까지의 달성 횟수를 보여준다. <br>6) 목표 대상 한 달 소비 제한: 사용자 지정 항목에 대해 지정한 소비 제한 횟수를 지켰는지 월별로 보여준다. <br>7) 뱃지: 챌린지 목표를 달성할 때마다 뱃지를 수여한다. <br> <br>8. 통계 기능<br>: 데이터베이스에서 사용자의 월별 가계부 데이터를 조회하고 수입-지출을 카테고리별로 구분지어 금액 총합을 보여준다. 막대 그래프로 카테고리별 사용량을, 꺾은선 그래프로는 예산 사용 추이를 확인할 수 있다.<br> <br>9. 로그인 기능<br>: OAuth2.0 으로 구글 로그인을 구현한다. 사용자는 자신의 구글 계정으로 서비스에 로그인할 수 있다. 첫 로그인 시 데이터베이스에 이메일 주소와 계정 이름을 저장한다. 저장된 데이터는 사용자 인증이 필요한 서비스 이용이나 친구 초대 시 사용된다.<br> <br>10. 웹 애플리케이션 배포<br>: 프론트 웹 애플리케이션은 NginX로, 백엔드 웹 애플리케이션은 AWS EC2 인스턴스로 배포한다. 클라우드 데이터베이스로는 AWS RDS MySQL 데이터베이스를 사용한다. |
| (8-6) 과제: 세부 기술 | 1. 프론트엔드: React <br>React로 사용자에게 제공되는 웹 애플리케이션 인터페이스를 구현한다. UI를 표시하여 사용자와의 상호작용을 담당한다. Figma를 이용해 UI 컴포넌트를 디자인한다. <br>사용자가 일정과 가계부를 작성하고 저장된 내역을 조회할 수 있다. 예산 절약 플랜을 선택하고 진행 중인 챌린지 목록을 확인할 수 있다. 예산 사용에 대한 통계와 예산 사용 예측 값을 제공한다.  <br>비동기 이벤트 기반 구조를 가지는 웹서버 Nginx로 React를 배포해 외부 클라이언트 요청을 컨트롤한다. Nginx는 클라이언트인 웹 브라우저로부터 HTTP 요청을 받아들이고 React로 작성한 문서인 웹페이지를 반환하는 식으로 작동한다. <br> <br>2. 백엔드: Spring Boot <br>Spring Boot 프레임워크로 시스템의 핵심 비즈니스 로직을 구현한다. 사용자 요청을 받아 처리하고 데이터베이스와의 상호 작용을 담당한다. 예산 예측 모델을 사용해야 하는 경우 Flask API에 대한 요청을 보내고 응답을 처리한다.  <br> Spring Boot 애플리케이션은 AWS EC2 인스턴스 Ubuntu SERVER 22.04 LTS에서 배포되고 내장 tomcat을 웹 서버로 사용하여 서비스를 제공한다. Spring Data JPA를 사용하여 데이터베이스에서 데이터를 읽고 쓰는 작업을 수행한다.  <br> <br>3. 데이터베이스: AWS RDS MySQL <br>AWS RDS에 MySQL 데이터베이스 서버를 호스팅한다. 사용자가 프론트엔드에서 입력한 데이터는 사용자 권한 확인을 거쳐 데이터베이스에 저장된다. 데이터베이스는 사용자 정보, 일정 정보, 가계부 내역, 예산 정보 등을 저장한다.  <br> <br>4. 보안 및 인증: Spring Security, OAuth 2.0 <br>Spring Security는 사용자 인증 및 권한 부여를 담당하며, OAuth 2.0 프로토콜을 사용하여 사용자 로그인을 처리한다. 사용자가 OAuth 2.0을 사용하여 로그인하고 인증 서버로부터 액세스 토큰을 발급받는다. API 서버는 해당 토큰이 유효한지 검증함으로써 요청을 보낸 사용자를 인증하고 요청을 처리한다. 필요시 데이터베이스와 통신한다. OAuth 2.0 액세스 토큰 검증 로직은 Spring Security를 통해 API 서버에 구현된다. <br> <br>5. 외부 서비스 연동: Flask, scikit-learn, OCR <br> scikit-learn을 사용하여 머신러닝 모델을 학습시키고, 학습된 모델은 Flask API로 배포한다. 또한 OCR을 사용하여, 캡쳐된 결제 문자 이미지에서 텍스트를 추출하고 그 내용을 가계부 내역으로 등록한다.  <br>구글 코랩에서 scikit-learn 머신러닝 라이브러리를 사용해 예산 사용량 예측을 위한 다중선형회귀모델을 학습한다. 학습에는 사용자가 입력한 일정 데이터, 가계부 데이터가 사용된다. 학습된 모델을 Flask API로 래핑하여 서버에 배포하여 Spring Boot 애플리케이션에서 접근할 수 있도록 한다. Flask API로 Spring Boot 애플리케이션에서는 학습된 모델을 사용하여 예측을 수행하고 결과를 처리한다.  <br>사용자가 웹 브라우저를 통해 업로드한 결제 문자 캡쳐는 OCR 서비스에 전달되고, OCR 서비스는 이미지에서 텍스트를 추출하고 인식한다. 추출된 결과 텍스트를 클라이언트로 반환하고 필요한 부분만 필터링하여 데이터베이스 가계부 테이블에 저장한다.|
| (8-7) 과제: 기대 효과 및 의의 |1.기대효과 <br><br>1) 예산에 맞춘 소비·생활 관리: 소비량 예측값 제공 관점 <br>:사용자는 자신의 자산으로 얼마 정도의 소비가 적절한지 알 수 있으며 일상생활을 하며 자신이 어떠한 지출을 추가적으로 하는지 쉽게 파악할 수 있다. 일정과 소비·지출 내역은 구분하여 작성한다. 일정이 리스트 형태로 나타나고 각 일정에서의 예산 사용 가능량과 예상 소비량을 동시에 표시하여 지출을 쉽게 비교할 있도록 한다.  <br><br>사용자는 월별 수입으로부터 기반한 예산 사용 가능량과 예상 소비량, 그리고 실제 지출 금액을 비교하게 되면 현재 자신이 과소비를 하고 있는지 여부를 확인할 수 있다. 평소 예산 대비 과소비를 하는 사용자는 예측값을 보며 자신의 소비량을 줄이려는 노력을 할 수 있고, 지나치게 저축을 지향하는 사용자는 최소 사용 가능량을 확인하며 좀 더 융통성 있는 소비를 할 수 있다. 또한 자신의 수입 대비 적절한 지출 수준을 확인할 수 있어 과소비의 지표가 되어줄 것이다.<br><br>2) 재미 요소로 지속적 참여 및 관리 유도: 챌린지 및 리워드 관점 <br>:사용량 예측뿐만 아니라 소비 챌린지로 돈 관리에 대한 재미를 심어줄 수 있다. 소비자가 스스로 하루의 소비 상한선을 정해 소비 줄이기에 도전하는 나만의 챌린지와 비슷한 나이대의 사람들과 소비량을 퍼센트로 비교하며 자신의 소비 수준을 알아볼 수 있고, 성공 시 리워드를 지급받아 돈관리에 재미를 붙이도록 유도한다. <br><br>3) 재미 요소로 지속적 참여 및 관리 유도: 소비량 공유 관점 <br>:친한 친구와 예산 사용량 퍼센트를 공유하면서 서로의 소비를 주의할 수 있고 함께 챌린지를 만들고 성공할 경우 리워드를 지급하는 방식으로 돈 관리에 흥미를 제공한다. <br> <br>2. 의의 <br><br>우리 서비스는 돈 관리의 양극에 있는 사람들이 현명한 소비를 할 수 있도록 가이드를 제공하고 돈 관리가 어렵고 낯선 사회초년생에게는 돈 관리에 챌린지와 같은 재미요소를 더해준다. 가계부가 익숙하지 않은 점을 보완하기 위해 일정과 가계부를 통합하여 돈 관리를 일정 관리의 일부분처럼 일상에 녹아들게 함으로써 돈 관리를 자연스럽게 습관화 시킨다. 또한 예산 사용량 예측값을 제공해 사용자의 수입에 맞는 적절한 소비량을 알려주어 사용자가 과소비를 멀리할 수 있도록 한다. "돈워리(Be Happy)"는 일정과 가계부를 통합하여 사용자가 일정별 예측 사용량과 사용 가능 예산을 한눈에 비교하며 과소비를 피할 수 있도록 하며, 챌린지 등 재미 요소까지 포함한, 이제 막 돈 관리를 시작하는 사회초년생에게 필요한 차별화된 서비스로 그 의미가 있다. <br> |
| (9) 데모 내용 | 중간데모(4월)<br><br>1) 가계부-일정 통합 기능<br>가계부와 일정을 통합하여 리스트 형식으로 보여주는 화면으로, 데모 날짜에 해당하는 일정과 가계부 데이터를 데이터베이스에서 불러와 화면으로 보여주었다.<br>2) 새 일정 추가 기능<br>가계부-일정 통합 화면에서 아래쪽의 버튼을 눌러 새 일정을 입력할 수 있는 모달이 뜨는 것을 보여주었다. 모달에 일정 이름을 입력하고, 날짜와 카테고리를 선택해서 추가하는 기능을 보여주었다.<br>3) 예산 예측 기능<br>가계부-일정 리스트 화면에서, 새 일정을 등록하면, 프론트와 연결된 flask 서버의 budget.py의 budgetpredict 함수가 실행되면서, 다중선형회귀 모델이 일정에 대한 예산 사용량을 예측한 후, 등록된 새 일정과 함께 예측 예산 사용량을 보여주었다.<br>4) 예산 사용량 기능<br>이번달의 현재까지의 예산 사용량을 막대그래프로 보여주었다.<br>5) OCR 기능<br>새 지출 내역을 등록할 때, 사진 파일에서 불러온 문자 내역을 화면에 보여주었다. 그리고 flask 서버에 연결된 app.py의 easyocr가 실행되면서 문자 내역 속에서 날짜, 가게 이름, 지출 금액을 인식한 것을 팝업을 띄워 보여주었다. 인식한 내용이 올바른지 확인한 후 등록하게 되면 마찬가지로 가계부-일정 리스트 화면에 새로 추가되는 것을 보여주었다.<br><br>최종데모(6/7)<br> <br>3가지 기능을 중심으로 데모함<br>1) 예산 예측 기능<br>예산예측 머신러닝 모델(다중선형회귀모델)이 예상 지출을 예측해주는 기능이다. 메인 화면인 일정+가계부 화면에서, 일정을 등록하면 예상 지출이 등록되는 것으로 보여준다. 각 일정별 예상 지출뿐만 아니라, 각 날짜에 해당하는 일정리스트 위에, 그날의 소비유형과(예:약속 일정에 대한 소비가 있을 예정), 소비유형에 따라 예상 되는 총 지출을 보여준다. 그리고 평소보다 소비가 많을 것으로 예측될 경우 주의 알림이 뜨는 것을 데모한다. <br><br>2) 예산 분배 기능<br>예산, 목표금액, 달성 기간, 고정지출 카테고리를 입력하는 화면을 데모한다. 입력한 정보를 바탕으로 예산을 변동지출/고정지출/절약금액으로 분배되는 것을 버블차트로 보여준다. 그중 변동지출을 클릭했을 때, 일정 카테고리에 대해 예산을 분배한 결과를 버블차트로 보여준다. 예산분배 로직은, 저번달 카테고리별 지출(%)을 기준으로 이번달 총 예산에 맞게 분배하는 것이라는 것을 설명한다. 사용자가 각 카테고리를 클릭해 카테고리별로 할당된 예산을 수정할 수 있음을 데모한다. 실제 이번달 지출이 발생한 경우, 각 카테고리별로 파이차트로 실제지출(%)이 표시된다. 저번달에서 특정 카테고리의 초과지출이 발생한 경우, 빨간색으로 표시되는 것을 데모한다.<br><br>3) 챌린지, 친구공유 기능<br>설정한 목표금액 챌린지의 달성률을 막대그래프를 보여준다. 그 외 하루 N원 챌린지, 목표 대상 한달 소비제한 챌린지가 있음을 보여준다.<br>친구와 함께 설정한 목표 챌린지를 진행하여 챌린지를 공유할 수 있고, 개인, 친구와 함께하는 챌린지 달성 시 받을 수 있는 뱃지(리워드) 기능이 있음을 보여준다.<br>그 외에도 사용자의 소비성향에 따른 주의 메시지나 목표금액 달성을 돕는 ‘하루 미션’ 메시지를 제공하는 것을 보여준다.<br>그리고 사회초년생을 위한 금융상품 정보와 그 순위(예: 청년적금상품 인기 순위)를 보여준다.사용자가 금융상품을 통해 더 빠른 기간 내에, 혹은 더 적은 금액을 절약해서, 목표금액을 모을 수 있다는 메시지와, 총 세후 이자를 계산한 결과까지 보여주며 금융상품에 대한 정보를 구체적으로 제공하는 것을 데모한다. <br><br> +) OCR 기능<br>추가로 OCR로 영수증 사진을 등록하여 편리하게 지출을 기록하는 기능을 데모한다.<br>|
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-35
| (1) 과제명 | 영상 일기 플랫폼 log: NLP를 활용한 간편하고 생생한 일기 기록
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 35-log |
| (3) 팀원 역할 분담 | 배주연(1971023): 리더, UI/UX 디자인, 프론트/백엔드 서버 프로그래밍,  MySQL 구축<br>김희진(2029011): 팀원, NLP 모델링, 프론트/백엔드 서버 프로그래밍, 서버 구축,  MySQL 구축<br>정지혜(2029037): 팀원, NLP 모델링, 프론트/백엔드 서버 프로그래밍, MySQL 구축 |
| (4) 팀 지도교수 | 심재형 |
| (5) 팀 멘토 | 문효진 / 네이버 / 개발자 |
| (6) 과제 키워드(keywords) | 영상일기, 자연어처리, 소셜 네트워크 |
| (7) 과제 내용 요약 | 일기를 쓰는 것은 일상을 기록하는 것 이상의 효과가 있습니다. 하루를 돌아보며 오늘의 의미를 찾을 수 있고, 자아 성찰을 하며 ‘나’에 대해 깊게 이해하도록 도와주기도 합니다. 이로써, 저희 팀은 AI로 간단하게 기록하는 하루의 영상일기 플랫폼 log를 기획하였습니다. 영상 녹화 방식을 이용하여 글보다도 더 쉽고 생생하게 전달할 수 있습니다. log는 일기 요약본, 해시태그, 배경음악도 만들어줍니다. |
| (8-1) 과제: 문제의 정의 | 기존의 아날로그 일기 서비스는 모바일앱으로 디지털화 되었지만, 10~20대에 맞춰진 다양한 서비스를 제공하지 못합니다. 단지 종이 일기가 모바일에 저장된다는 점 이외의 추가 서비스를 제공하지 않기 때문에, 유저들은 일기와 sns를 개별적으로 관리해야 한다는 불편함이 있습니다. 틱톡, 인스타, 스냅챗 같이 개인적인 소셜 네트워크에 영상을 올리며 일상을 기록하는 동시에, 일기 앱에 개별적으로 텍스트 형태의 일기를 작성해야 합니다. 가장 대표적인 영상일기 앱, "RYDE: 매일 쓰는 영상 일기"는 영상 내용에 대한 분석보다는 영상 길이 및 영상을 찍은 장소, 날씨 관련된 통계만을 제공합니다. log는 이러한 문제점을 해결하기 위해 친구 공유가 가능한 일기 서비스에 직접 구현한 자연어처리 모델을 구축하여 일기에 대한 요약과 해시태그를 자동으로 생성하도록 함으로써 사용자의 일기가 텍스트로도 저장될 수 있게 돕습니다. |
| (8-2) 과제: 기존연구와의 비교 | <br><a href='https://ifh.cc/v-JjaFq7' target='_blank'><img src='https://ifh.cc/g/JjaFq7.png' border='0' width='300px'></a><br>단지 종이 일기를 온라인 형태로 변환하는 것에 그치지 않고, log는 타서비스에서는 볼 수 없었던 다양한 편의 서비스를 제공합니다. 먼저, 사용자는 단순히 개인 일기를 기록하는 것뿐만 아니라, 일기를 공유할 수 있도록 하여 친한 친구들과의 소통(댓글 및 좋아요)을 할 수 있습니다. 기존의 일기 플랫폼들이 갖추고 있던 기능에 소셜 네트워크 기능까지 추가하였습니다. 두번째로, 일기를 직접 텍스트로 작성할 필요 없이 영상을 녹화하는 것만으로도 사용자의 하루를 더욱 생생하게 기록할 수 있습니다. 세번째로, 영상의 내용을 검색할 수 있습니다. 영상의 제목과 해시태그 등을 통해서만 검색이 가능한 타서비스들과 달리 영상 속 음성을 추출하여 STT 기능을 통해 변환한 텍스트를 데이터베이스에 저장하여 영상의 내용을 검색할 수 있습니다. 또한, 일기 영상에 사용자의 감정에 맞는 배경음악을 삽입할 수 있습니다. 마지막으로, 영상일기를 녹화하면 직접 구현한 자연어처리 모델(요약 모델, 해시태그 모델)을 통해 일기 내용 요약문과 해시태그를 자동으로 생성해줍니다. 사용자는 영상 속 내용을 직접 설명하거나 해시태그를 추가로 달 필요 없이 영상만 녹화하면 AI 모델을 통해 간편하게 일기를 기록할 수 있습니다. |
| (8-3) 과제: 제안 내용 | [트렌디한 디자인, 달력형 UI]<br>- 달력 형식의 디자인으로 월별 일기를 한 눈에 확인할 수 있습니다.<br><br>[영상으로 생생하게 기록하는 일기]<br>- 사용자는 log 웹 어플리케이션에서 일기를 녹화하거나 저장되어 있는 영상을 첨부할 수 있습니다. <br>- 요약본, 해시태그 생성 여부, 배경음악 추가 여부, 공개범위를 설정할 수 있습니다. <br><br>[AI로 간편하게 기록 (요약문, 해시태그 자동 생성)]<br>- 영상 일기를 기반으로 AI가 요약문과 해시태그를 자동으로 생성합니다.<br>- 사용자가 문구를 직접 추가, 수정도 가능합니다.<br><br>[친구 관리/공유]<br>- ID를 검색하여 친구를 신청/수락하고 친구를 맺을 수 있습니다.<br>- 일기별 공개 범위를 설정하여 개인 소장을 하거나 친구와 공유할 수 있습니다.<br>- 친구들의 최근 게시물들을 보고 좋아요와 댓글을 남기며 친구와 소통할 수 있습니다.<br><br>[월별 통계]<br>- 사용자가 월별 가장 많이 사용한 5개의 해시태그 통계를 제공합니다.<br>- 사용자의 월별 감정 기록을 그래프로 제공합니다.<br><br>[배경음악 추가]<br>- 사용자의 감정을 기반으로 선정된 배경 음악을 영상에 삽입해줍니다.<br><br>[검색]<br>- 사용자는 자신의 일기를 날짜, 공개 범위, 키워드 등을 활용하여 필터링할 수 있습니다.<br>- STT 기능으로 영상 내용을 텍스트로 변환하여 저장하기 때문에 영상 속 내용도 검색이 가능합니다.<br>|
| (8-4) 과제: 과제의 주요 기능 | [계정 관리]<br>- 유저 생성 및 로그인 후 세션 유지<br><br>[영상 일기 기록]<br>- 영상 녹화 후 STT API로 내용을 텍스트로 변환한 뒤, 요약본과 해시태그 생성<br>- 일기 감정 기반 item-based 추천 시스템을 사용하여 BGM을 영상에 추가<br><br>[요약본, 해시태그 생성]<br>- KoBART 모델을 파인튜닝<br>- 파인튜닝 후 최종 성능 측정 결과, 해시태그 모델은 rouge-1 score 0.523, BERTScore 0.88의 성능을 냄. 요약 모델은 rouge-1 score 0.492, rouge-l score 0.486, BERTScore 0.853의 성능을 냄.<br><br>[검색]<br>- 영상 일기의 전문, 요약, 해시태그를 데이터베이스에 저장하며 사용자가 키워드 또는 필터링 (날짜, 공개범위 등)을 사용하여 검색할 수 있는 기능 제공 <br><br>[소셜 네트워크]<br>- 친구 추가 후 친구 피드에서 서로의 일기 확인 <br><br>[통계]<br>- 월별 일기에 대한 통계 데이터 제공<br>|
| (8-5) 과제: 구현 방법 | [모바일 친화적인 웹페이지]<br>- React로 반응적이면서 깔끔한, 트렌드가 반영된 웹을 제작했습니다.<br><br>[요약문, 해시태그 생성]<br>- 영상 속 음성을 추출하여 Google Cloud Speech To Text API를 통해 변환한 텍스트 전문을 DB에 저장합니다.<br>- fine-tuning한 KoBART 모델로 요약본과 해시태그를 생성합니다. 요약본은 일기 전문 텍스트를 기반으로 생성하고, 해시태그는 일기 요약본을 기반으로 생성합니다.<br><br>[배경음악 추가]<br>- 사용자가 선택한 감정 기반 item-based 추천 시스템으로 BGM을 추천해줍니다.<br><br>[검색]<br>- MYSQL 데이터베이스에서 사용자가 선택한 날짜, 공개 범위, 해시태그, 키워드의 제약 조건에 맞는 video_info만 추출합니다.<br><br>[통계]<br>- 데이터베이스에서 해당 월에 생성된 해시태그와 감정별 횟수를 집계하여 가장 많이 사용된 해시태그 5개를 보여주고, 감정기록을 그래프로 나타냅니다.<br><br>[친구 피드]<br>- 데이터베이스에서 일주일 내의 사용자와 친구를 맺은 다른 사용자들의 게시물, 게시물별 댓글, 좋아요 정보를 추출하여 표시합니다. <br>- 친구의 게시물에 사용자가 좋아요와 댓글을 남긴다면 각 정보를 데이터베이스 테이블에 저장합니다.<br><br>[계정 관리]<br>- 입력한 유저네임과 비밀번호가 올바른지 DB와 대조를 통해 로그인합니다.<br>- 로그인 후 사용자 세션을 유지합니다.<br>- 사용자의 비밀번호는 암호화하여 DB에 저장합니다. <br>- 비밀번호를 재설정 하는 경우, 이전 비밀번호를 확인한 뒤, 새롭게 데이터베이스에 저장합니다.<br>- 계정을 삭제 시, 데이터베이스에서 사용자 정보가 삭제됩니다.<br>- 로그아웃 시 세션 정보와 세션 저장소를 비운 뒤, 로그인페이지로 redirect 됩니다.<br><br>[친구 관리]<br>- 친구 유저네임을 검색하면 친구 요청을 보내고 데이터베이스에 친구 요청 상태가 저장됩니다. <br>- 친구 요청이 수락되어야만 최종적으로 친구가 맺어집니다.<br>- 친구 요청을 받은 유저는 수락 또는 거절할 수 있고, 수락 시 데이터베이스에서 친구 상태로 업데이트되고 거절 시 친구 요청 상태가 삭제됩니다. |
| (8-6) 과제: 세부 기술 | [계정 관리]<br>- 계정을 새로 만들기 위해서는 유효한 이메일, 아이디, 비밀번호를 입력해야 합니다. 계정 정보가 새롭게 데이터베이스에 추가되며 사용자 로그인이 가능해집니다.<br>- 올바른 유저네임과 비밀번호를 입력하면 로그인이 됩니다. Flask session 라이브러리를 사용하여 로그인 후 사용자 세션을 유지합니다.<br>- 사용자의 비밀번호는 Flask bcrypt 라이브러리를 사용하여 암호화 합니다. 만약 비밀번호를 재설정 하고 싶다면, 이전 비밀번호를 확인한 뒤, 새롭게 데이터베이스에 저장합니다.<br>- 계정을 삭제한다면 경고 메세지로 사용자 의사를 다시 한번 확인합니다. 최종 삭제 시, 데이터베이스에서 사용자 정보가 삭제됩니다.<br>- 로그아웃 시 세션 정보와 세션 저장소를 비운 뒤, 로그인페이지로 redirect 됩니다.<br><br>[영상 일기 기록]<br>- 사용자는 앱 내에서 영상을 찍거나, 앨범에서 영상을 선택하여 업로드 할 수 있습니다.<br>- 일기 녹화 후, 요약문, 해시태그, 배경음악, 공개범위 그리고 오늘의 감정을 선택합니다.<br>① 영상 녹화 <br>log 앱 내에서 일기 영상을 녹화할 수 있도록 npm의 react-webcam 패키지를 사용하였습니다. 웹 어플리케이션을 실행하는 기기(Android, IOS) 및 브라우저(Chrome, Safari)에 맞게 영상이 인코딩되도록 사용자의 실행 환경에 따라 코덱을 다르게 지정하였습니다.<br>② Speech-To-Text<br>파이썬의 FFmpeg 라이브러리를 사용하여 음성 파일을 추출합니다. 그 이후, Google Cloud Speech To Text API를 사용하여 텍스트 전문을 저장합니다.<br>③ KoBART (요약, 해시태그) 모델<br>SKT AI에서 공개한 KoBART 모델을 크롤링을 통해 구축한 일기 데이터로 Fine-tuning을 시킵니다. Fine-tuning시킨 KoBART 모델을 불러오고, 입력받은 문장을 KoBART Tokenizer로 토큰화 후 숫자로 인코딩합니다. 모델로 결과를 생성하고, 생성된 결과(숫자)를 다시 문자로 디코딩합니다. 해시태그 모델의 경우, 중복 생성된 해시태그가 있는지 확인하여 제거합니다.<br>④ BGM 선정<br>감정 기반 item-based 추천 시스템을 사용하여 선정된 BGM을 영상에 추가합니다.<br><br>[검색]<br>지난 일기에 날짜, 공개 범위, 해시태그, 키워드 등의 제약 조건에 맞는 video_info만 MYSQL 데이터베이스에서 추출하여 텍스트 기반으로 영상일기를 검색할 수 있습니다. 검색된 일기를 다시 시청하거나, 요약문과 해시태그를 확인할 수 있습니다. 공개 일기의 경우 친구들의 댓글과 좋아요를 확인할 수도 있습니다.<br><br>[소셜 네트워크]<br>① 친구 추가<br>친구 유저네임을 검색하면 친구 요청을 보낼 수 있습니다. 이때 데이터베이스에 친구 요청이 만들어집니다. 친구 요청이 수락되어야만 최종적으로 친구가 맺어집니다. 친구 요청을 받았다면, 수락 또는 거절할 수 있습니다. 수락 시 친구가 맺어지며 데이터베이스에 친구 상태가 성립됩니다. 친구는 서로 일기 내용을 공유하고, 일기 내용에 소통할 수 있습니다. 친구요청을 거절하면 요청이 삭제됩니다.<br>② 친구 피드 <br>친구 피드에서는 친구가 최근에 올린 일기를 시청할 수 있습니다. 일기 시청 후, 좋아요를 남기거나 댓글을 작성하며 직접적인 소통이 가능합니다.<br><br>[통계]<br>데이터베이스에서 월 별로 사용자의 일기 데이터를 조회합니다. 해당 월에 생성된 해시태그별 횟수를 집계하여 가장 많이 사용된 해시태그 5개와 감정에 대한 통계 자료를 그래프 기반으로 제공합니다.|
| (8-7) 과제: 기대 효과 및 의의 | 사용자를 위해 만들어진 log는 인터페이스가 간편하고, 실용적이며, 사용자의 입력을 최소화합니다. 온라인 플랫폼이기 때문에 일기 작성에 제한이 없으며, 디바이스에 제한받지 않습니다. 사용자가 하루를 기록하는 영상을 업로드하면, log 앱은 영상 내용을 요약하고, 영상 내용 속 키워드를 추출하여 해시태그를 생성해 줍니다. 사용자의 감정을 기반으로 배경음악을 자동으로 선정해서 영상과 함께 재생하며, 월별 사용자의 기록을 통계로 확인할 수도 있습니다. 영상 내용 검색을 지원하여 사용자는 기록을 매우 쉽게 검색할 수 있습니다. 영상의 공개 범위를 설정할 수 있어 개인 기록용으로 저장하거나 서로 팔로우 되어 있는 친구들 간에 공유하며 사용할 수도 있습니다. 해당 기능을 활용하여 일기를 통해 개인적인 커뮤니티를 구축할 수도 있습니다. |
| (9) 데모 내용 |  [log 웹앱 배포 버전 실행 데모 워크플로우]<br>1) 사용자 계정 생성과 로그인<br>2) 오늘의 일기 녹화<br>3) 요약본, 해시태그 생성과 수정<br>4) 일기 저장과 친구 추가<br>5) 친구 피드 확인<br>6) 통계 확인<br>7) 일기 검색<br><br>[동작 환경]<br>도메인 qr 코드를 제공하여 웹으로 접근 가능 (크롬/사파리 에서 원활하게 작동, 사용자가 실제로 계정을 만들고 로그인하여 일기를 녹화할 수 있도록 데모 시연할 예정)|
| (10) 기타 | [SW 구조도]<br><a href='https://ifh.cc/v-mgvZ2B' target='_blank'><img src='https://ifh.cc/g/mgvZ2B.png' border='0'></a><br>1. Cloud 배포<br>배포용 GitHub 레포지토리를 git clone하여 할당받은 Tencent Cloud 파일 스토리지에 업로드하였습니다. 배포에 사용한 포트는 총 4개로, 프론트엔드 React 서버(3000번 포트), 백엔드 Flask 서버(5000번 포트), DB  MySQL 서버(3306번 포트), redis 서버(6379번 포트)를 열어주었습니다.<br><br>2. Nginx 포트 포워딩<br>발급한 도메인과 서버 IP 주소를 연결하면 IP 주소의 기본 port가 HTTP 서버(80번 포트)로 지정됩니다. 사용자가 Web Server의 기본 포트(80번 포트)에 접속하면 Web Application Server(프론트엔드 React 서버, 3000번 포트)에 이동하도록 하기 위하여 Nginx의 포트포워딩 기술을 사용하였습니다. 또한, 영상 녹화 권한을 받기 위해 SSL 인증서를 발급받아 HTTPS 서버(443번 포트) 또한 Web Application Server(프론트엔드 React 서버, 3000번 포트)에 연결하였습니다. (HTTP (80), HTTPS (443) → React (3000))<br><br>3. FrontEnd (React) ↔ BackEnd (Flask) 연결<br>React npm 프로젝트 내의 package.json 파일의 proxy를 백엔드 Flask 서버(5000번 포트)로 설정하였습니다.<br><br>4. BackEnd (Flask) ↔ DB (MySQL, redis) 연결<br>Flask 프로젝트 내의 config.py 파일에서 sqlalchemy 라이브러리를 사용하여 MySQL 서버(3306번 포트)와 연결하였습니다. 또한, 사용자 세션 유지를 위하여 redis 서버(6379번 포트)를 연결해 사용하였습니다.<br> |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-36
| (1) 과제명 | Neverland: 생성형 AI 기반 단체 추억 아카이빙 앱 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 36-레쏘 |
| (3) 팀원 역할 분담 | 지소민(2080035): 리더, 백엔드, 기획<br>김중현(2076088): 팀원, 백엔드, Cloud(AWS EC2, RDS, S3), DB(MySQL, Redis), CI/CD, 기획<br>곽서진(2076016): 팀원, 프론트엔드, 기획, 디자인 |
| (4) 팀 지도교수 | 오세은 교수님 |
| (5) 팀 멘토 | 고지현 / 이스토닉,디자인코딩 / 대표 |
| (6) 과제 키워드(keywords) | 단체, 추억, 아카이빙 |
| (7) 과제 내용 요약 | 개인 위주의 추억을 넘어서, 추억을 함께한 모두가 하나의 공동 기록을 남기는 단체 추억 아카이빙 서비스, Neverland를 만든다. 단체의 모든 멤버가 함께한 추억을 각자 피드로 기록한 후 피드들을 모아 Stable Diffusion을 통해 대표 이미지를 생성한다. 그 결과, 새로운 추억 기록이 피드로 생성된다.<br>또한, 단체별 추억 기록들을 시간과 공간에 따라 아카이빙함으로써 단체의 발자취를 들여다 볼 수 있고, 추억이 깃든 여러 장소를 지도를 통해 시각적으로 볼 수 있다. |
| (8-1) 과제: 문제의 정의 | 기존 서비스에서의 추억 회상은 개인의 단편적인 기억으로 이루어진다. 하나의 추억에 대해 각자가 기억하고 있는 바가 다르기 때문에 개인이 작성한 기록은 단체 모두의 기억을 반영하는 공통된 추억이 될 수 없다.<br>또한 단체의 추억을 아카이빙하기 어렵다. 단체에 속하더라도 개인의 기록들로 흩어져 있을 뿐, 단체의 추억들을 모아 기록하기 어렵다. |
| (8-2) 과제: 기존연구와의 비교 | 페이스북과 같은 기존의 유사 서비스에서는 그룹 기능이 있지만 그룹 안에서만 피드를 공유한다는 점만 다를 뿐, 개인의 기록이라는 점에서 일반 피드와 다른 것이 없다. 하지만 “Neverland”에서는 같은 추억에 대한 멤버들의 서로 다른 기억들을 합쳐 단체의 공동 추억 기록을 생성한다는 점에서 차별점을 가진다. <br>또한, 페이스북의 그룹 기능의 경우 개인이 작성한 피드의 나열에 그칠 뿐, 그룹의 추억을 아카이빙한다고는 할 수 없다. “Neverland”에서는 한 단체의 추억을 아카이빙할 수 있는 것뿐만 아니라, 그 기록들을 시간, 공간을 기준으로 기록할 수 있다는 점에서 단체 추억 기록의 새로운 접근 방식을 제공한다. |
| (8-3) 과제: 제안 내용 | 함께한 추억들을 같이 기록하고 싶은 사람들에게 다음의 해결책을 제공한다. <br>1. 각자 다르게 기억하는 추억을 모아 하나의 공동 추억 기억으로 자동 생성한다.<br>2. 단체의 추억을 아카이빙할 기회를 제공한다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 그룹의 각 유저가 한 추억에 대한 기억을 글과 이미지를 포함한 피드로 기록한다. 해당 추억에 함께한 모든 유저가 작성한 피드를 모아 Stable Diffusion을 통해 하나의 대표 이미지를 생성한다. 하나의 추억을 대표하는 이미지를 포함한 새로운 추억 기록을 피드로 생성해 기록한다.<br><br>2. 솔루션 1)에서 생성한 단체 추억 기록을 시간과 공간을 기준으로 아카이빙할 수 있다.<br>그저 개인이 작성한 기록의 나열이 아닌, 추억에 함께한 모두의 기억을 합쳐 만든 단체의 추억을 시간의 흐름에 따라 나열해 단체의 발자취를 들여다 볼 수 있다.<br>또한, 단체의 추억이 깃든 여러 장소를 지도를 통해 시각적으로 모아볼 수 있다.<br>    - 시간<br>    그룹별로 기록된 추억 기록들을 시간 순으로 보여준다.<br>    Stable Diffusion으로 생성한 공동의 추억 기록만을 따로 모아보는 기능을 통해 그룹의 추억을 시간 순으로 나열한다.<br>    - 공간<br>    그룹별로 기록된 추억 기록들의 장소를 지도에 나타낸다.<br>    공동의 추억 기록 피드에 작성된 장소를 지도에 좌표로 나타낸다. 이 때, 추억 기록 피드의 대표 이미지를 마커로 사용한다. |
| (8-5) 과제: 구현 방법 | 본 과제의 최종 형태는 iOS 앱이며, 구현하고자 하는 시스템의 구조는 아래와 같다. <br>![architecture](https://github.com/lemonssoju/neverland-client/assets/81500249/4080fd81-6831-4669-add1-9ae7ca3af182) <br> 유저는 iOS 앱을 통해 서비스를 이용할 수 있으며, 유저 측으로부터 여러 요청이 들어오면 가장 먼저 앱 서버(AWS EC2)가 받게 된다. 들어오는 요청에 따라 앱 서버 내부에 실행되고 있는 Spring Boot 프레임워크에서 적절한 로직을 수행하게 되는데, 만약 데이터 접근이 필요한 경우에는 DB(MySQL)와 통신해 데이터를 주고 받는다. 또한, 유저 프로필 이미지나 피드에 포함된 이미지와 같은 이미지 데이터를 저장해야 할 경우에는 이미지 저장용 DB(AWS S3)를 활용한다. “Neverland”의 주요 기능인 공동 추억 기록 자동 생성을 구현하기 위해, 거대언어모델인 Chat-GPT와 이미지 생성 AI인 Stable Diffusion을 활용한다. 가장 먼저, 추억을 함께한 유저들이 작성한 텍스트들을 입력값으로 해 Chat-GPT를 호출하면 텍스트들을 합쳐 하나의 정리된 결과값을 반환한다. 그 반환된 결과 텍스트와 추억 피드에 포함된 이미지를 Stable Diffusion에 입력하면 새로운 공동 추억 이미지를 얻을 수 있다. AI가 자동으로 생성한 추억 이미지와 결과 텍스트를 피드 형태로 만들어 유저에게 다시 반환하면, 유저는 자동으로 생성된 공동 추억 기록을 볼 수 있게 된다.|
| (8-6) 과제: 세부 기술 | [Frontend]<br>- Typescript, React Native를 활용해 크로스 플랫폼 앱을 구축한다. <br>- Axios 라이브러리를 활용해 API를 연결한다. <br>- React Native Maps 라이브러리를 활용해 지도 뷰를 생성하고, 이미지를 마커로 띄운다. <br><br>[Backend]<br>- Authorization <br>Json Web Token, OAuth2를 활용해 인증/인가 기능을 구현한다. <br>회원가입, 로그인, 로그아웃, 회원탈퇴 기능을 구현한다. <br>- Cloud<br>AWS EC2를 활용해 앱 서버를 구축한다.<br>AWS S3를 활용해 이미지를 저장한다.<br>AWS Route53, ALB를 활용해 도메인 설정 및 HTTPS 프로토콜을 적용한다. <br>- DB<br>AWS RDS(MySQL)와 Redis로 Database를 구축한다.<br>- CI/CD<br>Docker, Github Actions를 활용해 배포 자동화 시스템을 구축한다.<br>- External API<br>Kakao Map API를 활용해 위치 좌표를 저장 및 제공한다.<br><br>[AI]<br>- LLM<br>Chat-GPT를 API로 활용해 여러 개의 추억 기록 텍스트를 튜닝해 Stable Diffusion input용 프롬프트를 효과적으로 생성한다.<br>- Stable Diffusion<br>유저에게 받은 추억 이미지와 Chat-GPT로 튜닝한 프롬프트를 Stable Diffusion의 입력값으로 하여 공동 추억 이미지를 생성한다.|
| (8-7) 과제: 기대 효과 및 의의 |1. 단체의 유대감 강화<br>개인이 아닌 추억을 함께한 모두의 관점을 반영하여 하나의 공동 추억 기록을 자동 생성함으로써, 각자가 다르게 기억하는 추억들을 효과적으로 통합할 수 있다. 이를 통해 단체 내부의 공감대를 형성하고, 모든 단체 구성원이 함께한 추억이 보다 완전히 기록된다. 이를 함께 공유하는 것은 단체 간 유대감을 높이고, 단체의 지속적인 소통과 상호 이해를 촉진할 것이다.<br><br>2. 추억 회상 과정의 효율성 개선<br>단체의 공동 추억 기록을 시간과 공간의 차원에서 아카이빙함으로써, 단체의 발자취를 확인할 수 있다. 시간 순으로 정리된 공동 추억 기록을 한 눈에 볼 수 있고, 공간의 경우 지도를 통해 단체가 함께한 다양한 활동의 위치를 시각적으로 확인할 수 있다. 이를 통해 단체의 구성원들은 함께했던 추억을 보다 쉽게 찾을 수 있다. 또한 함께했던 추억을 생생하게 회상할 수 있게 되어 추억의 특별함을 다시금 깨달을 수 있다. |
| (9) 데모 내용 | [동작환경]<br> - iOS 17.4 환경에서 전체 화면 구성 및 기능을 보인다.<br><br>[데모 실행 플로우]<br>1. Chat-GPT, Stable Diffusion을 활용한 공동 추억 기록 자동 생성 플로우를 보인다.<br>2. 생성된 공동 추억 기록들을 시간, 공간의 관점에서 아카이빙하는 기능을 보인다.|
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-37
| (1) 과제명 | 사용자와 자유로운 상호작용이 가능한 Gen AI 기반 스마트 스케줄링 웹 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 37-re:coding |
| (3) 팀원 역할 분담 | 전혜승(2076364): 팀장, AWS, Spring Boot, MySQL 등 벡엔드<br>최민주(2076409) :팀원, Next.js 프론트엔드<br>황채원(1976435) :팀원, GPT-4 API, FAST API, AWS, Chroma DB 인공지능 백엔드 |
| (4) 팀 지도교수 | 오세은 교수님 |
| (5) 팀 멘토 | 엄재홍 / 현대오토에버 / 부장 |
| (6) 과제 키워드(keywords) | LLM, 비서, 스케줄링 |
| (7) 과제 내용 요약 | 팀 Re:coding은 단순히 일정을 기록하는 역할만 보조했던 기존 스케줄링 서비스의 ‘자동화 부재’를 극복하고자 합니다. 이에 스케줄러의 개인화 기능, 그리고 프로액티브한 일정 관리 기능을 강화한 생성형 인공지능 비서를 만들고자 합니다. '네스'와 함께라면 업무 스케줄링은 물론 개인의 일상까지 한층 더 간편하고 직관적으로 만들 수 있습니다. |
| (8-1) 과제: 문제의 정의 | 정보통신기술의 발달로 개인의 업무량이 크게 증가한 현대 사회에서 다양한 일정을 효율적으로 관리하는 능력은 핵심 역량이 되었다. 이를 보조하기 위한 다양한 일정 관리 앱이 시장에 나왔지만, 대부분이 아날로그 다이어리를 핸드폰에 옮겨놓은 것에 불과했다. 이로 인해 사용자들은 일정을 등록하고 수정할 때마다 번거로운 형식에 맞춰 직접 입력해야 했다. 기존의 앱들은 능동적 스케줄링 보조를 제공하지 않아 사용자가 자신의 일정에 맞는 적절한 사전 준비를 하기 어렵게 만들었다. 더 나아가, 각기 다른 용도의 여러 일정 앱을 사용함으로써 도구의 분산이라는 문제를 겪고 있다. 이 문제를 해결하기 위해 팀 re:coding은 AI 기술을 활용하여 사용자의 의도에 맞는 능동적 스케줄링을 하나의 도구로 제공하는 제품을 개발하려고 한다.<br><br>1. 기존의 스케줄러 어플들을 이용하기 위해서는, 해당 어플의 사용법을 숙지해야했다. 스케줄러 어플에서 통용되는 일정 입력 및 삭제와 같은 기본적인 기능들은 사용자가 별다른 학습 없이도 이용이 가능했지만, 해당 어플에서 편의성 개선을 위해 추가한 고급 기능들을 사용하기 위해서는 어플 이용법 숙지를 위한 사용자의 학습이 요구되었다. 이에 사용자들은 해당 어플의 고급 기능을 이용하기 위한 사용법 숙지를 위해 시간을 투자하거나, 해당 기능을 사용하지 않고 기본적인 기능만을 사용하는데 그쳤다. 이에 자유로운 스케줄링이 불가했기에 사용자들은 보조적인 수단으로 메모장 어플이나, 공책 등의 물리적 기록 수단을 사용하기도 하였다. re:coding 팀에서 약 200명의 대학생을 대상으로 실행한 설문조사 결과, 메모장 어플을 보조적 수단으로 이용하는 사용자들이 76퍼센트, 공책을 보조적 수단으로 사용하는 사람들이 46퍼센트에 달했다.<br><br>2. 기존의 스케줄링 어플들은 아날로그적 수단인 다이어리를 모바일로 그대로 옮겨놓은 것에 불과할 뿐, 사용자의 일정에 필요한 사전 준비, 사후 피드백을 적극적으로 제공해주지 못한다. 일정 수립 시 사전 준비물, 장소 선정, 일기 예보 확인 등 다양한 요소를 고려할 필요할 필요가 있음에도 스케줄링 어플들에선 이러한 관리방식을 제공하지 않는다. 이는 오롯이 사용자의 업무로 돌아가 할 일을 더 가중시킬 뿐이다. 더 나아가 일정 관리에 대한 달성 성공/실패 여부와 같은 일차원적인 피드백 밖에 제공해주지 못해 사용자의 생활 개선에 도움을 제공해주지 못했다. |
| (8-2) 과제: 기존연구와의 비교 | 리코딩 팀은 현존하는 목표 관리 앱들이 어떠한 강점과 취약점을 가지고 있는지 약 한달여 간의 자료조사를 통해 분석하였다.<br><br>1. 투두메이트<br>투두메이트는 심플하면서도 트렌디한 UI, 그리고 직관적인 사용법으로 인해 많은 고객들을 확보했다. 그러나 인터뷰 등을 통해 상당한 수의 사용자들이 짧은 기간 내에 앱 사용을 포기하는 모습을 볼 수 있었는데, 앞서 제시한 설문조사 결과와 연관지어 생각해볼 때, 사용자가 직접 투두 리스트를 작성하고 그룹화할 뿐 아니라 정렬해야 한다는 점이 약점으로 작용했다는 점을 알 수 있었다.<br><br>2. TimeBlocks<br>TimeBlocks는 월별 일정을 간편하게 한 눈에 볼 수 있다는 점, 그리고 다양한 테마를 스토어에서 구입해 쉽게 커스터마이즈가 가능하다는 점에서 많은 사용자들을 모았다. 그러나 화면 구성 상 월별 일정을 한 눈에 보여줘야 한다는 한계는 적재할 수 있는 계획의 수를 제한 시킨다는 문제를 발생시킨다. 때문에 사용자는 중요한 일정을 주로 적게 되고, 전체적인 일정 관리를 위해서는 추가적인 서비스를 이용해야 한다는 문제점이 존재했다.<br><br>리코딩 팀은 위와 같은 자료 조사 및 설문조사를 통해 지금까지의 서비스들과는 다른 ‘네스’만의 강점을 인풋 자율성의 극대화에 두고자 하였다. 즉, 앱에서 지정한 인풋 형식, 카테고리화에서 벗어나 사용자에게 극강의 자율성을 주고 자체 서비스를 통해 플래닝을 진행시키는 개인 비서로서의 역할을 더욱 공고히 하고자 한 것이다.<br><br>‘네스’ 서비스 기획을 발전시키던 과정에서, 리코딩 팀은 인공지능을 활용해 플래닝을 도와주는 Reclaim.ai 라는 서비스를 발견하였다.<br><br>3. Reclaim.ai<br>Reclaim.ai는 구글 캘린더와 연동시켜 활용하는 개인/팀 플래닝 ai 서비스이다. 각 팀원들이 가능한 시간대와 일정 등을 적으면, 자동적으로 충돌이 나는 시간대를 피해 회의 시간을 선정하고 최적화 시켜준다. 다만, 이 IT 서비스 또한 정형화된 사용자의 인풋 입력과 한정적인 스케쥴링 기능이라는 한계점을 갖고 있는 만큼, 본 네스’ 프로젝트는 한층 더 나아가 입력 형식의 자율성이나 ui/ux 측면에서 더욱 발전된 결과물을 도모하고자 한다.<br><br>4. Google Calendar<br>구글 캘린더는 구글에서 제공하는 온라인 일정 관리 서비스로, 구글 계정을 가지고 있다면 개인 뿐 아니라  회사와 같은 공동의 일정을 효율적으로 관리할 수 있다. 특히, 같은 단체 내의 일정 공유 및 알림 설정, slack과 같은 다른 협업 툴과의 연동 가능성은 대규모의 인력을 관리해야 하는 회사에서 상품의 가치를 높여주었다. 하지만, 캘린더를 조작함에 있어 스스로 일정을 생성하고 상대의 일정을 확인 및 초대해야 하기 때문에, 1차원적인 캘린더의 틀에서 벗어나지 못했다는 한계점이 있다. |
| (8-3) 과제: 제안 내용 | NESS는 스케줄러에 챗봇 기능을 도입하여 “상호작용을 통한 편리한 스케줄링 관리”를 이룰 수 있다. NESS는 일정의 설정, 삭제, 변경을 돕고, 적절한 변경안도 제시해주기 때문이다. 반복적인 일정, 혹은 예외적인 일정도 명령어 한 줄로 설정이 가능하며, 사용자는 하나의 입력창으로 네스의 모든 기능을 제어할 수 있다.<br><br>또한, NESS는 사용자의 입력을 기다리기만 하는 게 아니라 스스로 일정을 분석하고 먼저 추천하는 똑똑한 비서이기도 하다. 사용자의 데이터를 기반으로 미리 일정에 대한 알림을 주기도 하고, 사용자가 스케줄러에 기입한 정보가 부족할 때 먼저 리마인드를 주는 능동적인 비서이다. 이를 통해서 기존의 아날로그 다이어리의 디지털화에 불과했던 일정 관리를 개선할 수 있다. |
| (8-4) 과제: 과제의 주요 기능 | [입력 처리]<br>사용자 입력의 차별화: 사용자는 비서에게 이야기하듯이 자신만의 스타일로 자유롭게 일정을 입력할 수 있다. 이렇게 입력받은 텍스트를 LLM이 처리하여 스케쥴 관리를 자동화한다. 이를 통해 일정관리 어플의 편집, 알람설정, 반복설정, 일정조정 등의 번거로움을 개선한다.<br>요약: 사용자가 자유롭게 일정을 입력하면, LLM이 할 일 목록으로 요약한다. 복잡하게 서술한 내용도 명료하게 요약해 정리한다(예: 오늘은 친구랑 여의도에서 밥 먹어야지. -> 친구와 저녁 약속(at: 여의도))<br><br>[스케줄링]<br>반복 일정 관리: 루틴 설정을 챗봇 형식으로 편리하게 해결 가능하다. (예: 헬스장에 가는 일정을 챗봇에 입력하면 자동으로 스케줄에 정리된다.)<br>추천: 사용자에게서 입력받은 일정에 대해 사전에 준비해야 할 사항들을 알려준다. (예: 토요일에 면접 일정이 있다면, 면접에 일반적으로 필요한 준비물들을 미리 알려준다.)<br><br>[분석]<br>분석 레포트 및 솔루션 제공: 사용자의 일정을 분석하여 레포트를 제공한다. 일정을 간략하게 요약하고 이에 태그를 생성해주는 등의 분석을 진행한다.<br><br>우리는 이 서비스를 통해 사용자의 만족도와 생산성을 높이며, 혁신적인 기술을 통해 스케줄링을 넘어 개인 비서로서의 역할을 수행할 것을 기대한다. |
| (8-5) 과제: 구현 방법 | [ML/AI 기술]<br>- LLM의 프롬프트 엔지니어링 : LLM의 가장 중요한 특징은, fine-tuning 없이 few-shot, one-shot, 혹은 zero-shot으로도 우수한 output을 낼 수 있다는 것이다. 사용자의 입력을 요약, 태그에 따른 자동분류 등을 수행하는 것은 LLM의 프롬프트 엔지니어링을 통해 구현할 예정이다. 또한, 사용자에게 분석 레포트 및 솔루션을 제공할 때 문장을 생성하는 것 역시 LLM을 통해 구현한다. 다방면에서 우수한 성능을 보이며, 가격이 합리적인 OpenAI의 GPT-4 API를 사용하였다.<br>- RAG based LLM: NESS의 핵심기술은 RAG based LLM이다. 근 몇 년 사이 언어모델을 평정한 사전학습된 거대언어모델의 한계는, 사전학습에 포함되지 못한 정보는 알지 못한다는 것이었다. RAG, 즉 Retrieval Augmented Generation은, 쿼리와 관련된 문서를 효율적으로 검색하여 쿼리와 함께 언어모델에 전달하는 방식이다. 이 방식을 이용하면, 추가적인 학습 없이 모델 외부의 데이터를 이용할 수 있다. 따라서 개인화된 경험 제공을 위하여 실시간으로 업데이트 되는 사용자 데이터의 활용이 핵심이 되는 NESS 서비스에 매우 중요한 역할을 한다.<br>- LangChain&VectorDB: LangChain은 AI 모델, 에이전트 및 프롬프트를 구조적으로 만들고 연결하여, LLM 관련 작업을 중앙에서 제어할 수 있는 오케스트레이션 프레임워크이다. 또한 모델에 context-enhanced 프롬프트를 전달하기 위해서는 사용자 쿼리에 관련된 문서를 벡터유사도에 기반하여 검색하게 되는데, 이를 위해 데이터를 벡터로 저장할 수 있는 VectorDB를 사용할 예정이다.<br>- LLM의 finetuning : 우리는 챗봇 기능의 구현 중 LLM의 프롬프트 엔지니어링만으로는 채팅 상황의 분류 성능이 떨어진다는 것을 확인하였다. 기존에 구현하고자 하였던 기능이 구현완료되면, 해당 성능의 개선을 위해 finetuning을 고려 중이다. finetuning을 통해 채팅 케이스 분류에 특화된 모델을 구축하여 더욱 사용자 만족도를 높일 수 있는 서비스를 만들어나갈 예정이다. finetuning의 데이터 생성으로는 GPT-3.5, finetuning 모델으로는 무료로 사용가능한 모델인 baby llama를 고려 중이다.<br><br>[FE/BE 기술]<br>- Spring Boot&FastAPI: 웹 서비스의 벡엔드는 Spring Boot를 사용하고, ChatGPT의 API와 연동하기 위해 FastAPI를 사용할 예정이다. 각 프레임워크별 백엔드 서버를 따로 두고 REST API를 통한 통신을 진행한다.<br>- Next.js&TypeScript: Next.js를 통해 CSR(CLient Side Rendering)의 최적화를 위해 노력한다. 웹 서비스이지만 모바일 기기를 소지한 사용자들 역시 편리하게 이용할 수 있도록 반응형 개발을 진행하며, Next.js의 비동기적 특성을 이용하여 간편하면서도 사용자들의 눈을 사로잡을 수 있는 UI/UX를 구현할 에정이다. TypeScript를 이용해 확장 용이성을 높이고, 발전된 형태의 structure 설계를 하고자 한다.|
| (8-6) 과제: 세부 기술 | - Vector DB(chromaDB): 백터DB에 데이터를 저장하고, 코싸인 유사도 기반 쿼리를 통해서 유사도가 높은 사용자의 일정을 검색하는 데 성공하였다.<br>- RAG: 백터DB에서 가져온 사용자의 일정과, 사용자의 채팅 내역을 합쳐서 LLM에게 제공하는 기능을 테스트하였고, LLM이 사용자의 일정 데이터 기반으로 답변을 생성하는 것을 확인하였다.<br>- OAuth 2.0(소셜 로그인): 카카오, 네이버, 구글 계정을 기반으로 로그인 및 회원가입이 가능한 것을 확인하였다.|
| (8-7) 과제: 기대 효과 및 의의 |[거대언어모델과 생성형 AI 기반으로 만드는 인공지능 비서, NESS]<br>팀 re:coding은 생성형 AI 기반 챗봇을 통해 사용자와 자유로운 의사소통이 가능한 스마트 스케줄링 서비스를 개발할 예정이다. 사용자가 마치 채팅을 하듯 일정을 입력하면, 대규모 언어모델(LLM)이 비정형 데이터를 처리하여 맥락을 파악하고, 사용자의 의도에 부합하는 최적의 스케줄을 도출한다. 이 서비스는 개별 누적 데이터를 기반으로 관련 활동 및 장소를 추천하며, 일정 준비를 위한 사전 피드백과 추후 스케줄링 개선을 위한 사후 피드백을 제공하여 사용자의 일정 관리를 능동적으로 지원한다. 일간, 주간, 할 일 목록을 제공함으로써 다양한 일정을 통합 관리할 수 있는 기능 또한 제공한다. 이를 통해 단순히 일정을 저장하는 수준을 넘어 '인공지능 기반 개인 맞춤형 일정 관리 비서'로서의 기능을 제공하는 것이 목표이다.<br><br>[서비스의 확장 가능성]<br>뛰어난 사용자 경험을 제공하기 위해 다양한 외부 서비스와의 통합을 통해 기능을 확장할 수 있는 구조로 서비스를 설계하였다. 이를 통해 사용자들은 단일 플랫폼에서 다양한 활동을 수행하고 자신의 일상을 보다 간편하게 관리할 수 있다. 아래는 통합 가능한 타 서비스와 기능에 대한 설명이다.<br>- 캘린더 서비스 API 통합: 사용자의 일정 및 일정 관리를 강화하기 위해 주요 캘린더 서비스와의 API 통합을 지원한다. 이를 통해 사용자는 하나의 플랫폼을 통해 다양한 캘린더 서비스 (예: Google 캘린더, Apple 캘린더, Outlook 등)의 일정을 연동하고 중앙에서 효율적으로 관리할 수 있다. 사용자들은 NESS 서비스를 통해 여러 캘린더에서 예약 및 일정을 통합적으로 확인하고 조정할 수 있으며, 일정 충돌 및 중복을 방지할 수 있다.<br>- 쇼핑 서비스 API 통합: 사용자들이 쇼핑 활동을 원활하게 관리할 수 있도록 주요 쇼핑 서비스와의 API 통합을 지원한다. 네이터 쇼핑 등의 서비스와 통합하여 쇼핑 목록, 할인 및 프로모션 정보, 주문 추적 등을 모두 관리할 수 있다. 이를 통해 사용자들은 쇼핑 활동과 일정을 통합할 수 있으며, 쇼핑한 물품이 도착하는 일정까지 모두 관리 가능하다.<br>-지도 및 위치 기반 서비스 API 통합: 위치 기반 정보 및 지도 서비스와의 통합을 통해 사용자들은 일정을 관리할 수 있다. 예를 들어, 회의 위치와 가장 가까운 커피숍을 추천받을 수 있다. |
| (9) 데모 내용 | 1. 메인페이지<br>a. 메인페이지는 NESS가 제공하는 전체적인 서비스를 요약하여 보여준다.<br>b. 사용자의 일정 DB를 분석하여 한 줄의 활동 추천 멘트를 생성 및 제공한다.<br>c. 오늘의 일정을 한 눈에 파악할 수 있는 리마인드 section이 있다.<br>d. 지난 한달 간의 일정을 분석한 간단한 보고서 및 통계를 제공한다.<br><br>2. 채팅창<br>a. 사용자가 자유롭게 채팅을 입력하면 생성형 AI를 통해 NESS가 답을 준다.<br>b. 일정 추가와 관련된 채팅을 입력하면(ex. 나 내일 채원언니랑 도서관 가) 일반적인 대화와 다른 case로 판단하여 일정을 정리 및 추가할 수 있는 응답이 온다. (‘4/15’, ‘채원언니', ‘도서관 방문’ 일정 추가)<br>c. 일정 추가 버튼을 누르면 사용자의 일정 DB에 해당 일정이 추가되고, 월별 및 일별 페이지에서 확인할 수 있다.<br><br>3. 월별 페이지<br>a. 생성된 일정들을 캘린더 뷰로 확인할 수 있다.<br>b. 각 날짜를 클릭하면 일별 modal 페이지를 볼 수 있다.<br><br>4. 일별 페이지<br>a. 각 일자에 해당하는 일정을 확인할 수 있다.<br>b. 장소, 인물, 시간 등은 태그 형태로 확인할 수 있다.<br><br>5. 추가 기능<br>a. 플로팅 NESS ICON<br>i. 항상 오른쪽 아래에 존재하는 NESS ICON 플로팅 버튼을 누르면 채팅창으로 바로 이동한다.  |
| (10) 기타 | 스타트 때 기획을 열심히 진행한 만큼, 그로쓰 수업 시간에는 조금 더 기술적으로 배울 수 있는 강연이나 기회가 있었으면 좋겠습니다. 사실, 학생 입장에서 졸업 프로젝트만큼 제대로 오랜 시간을 들여 서비스를 개발하는 기회가 흔치 않은데, 이 기회를 통해 기획 뿐만 아니라 기술에서의 전문성도 키우고 싶습니다. |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-38
| (1) 과제명 | 스킨트리: 협업필터링과 머신러닝을 활용한 성분 맞춤형 화장품 추천 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 38-화이 |
| (3) 팀원 역할 분담 | 정다희(2076367): 리더, 프론트엔드, 백엔드 프로그래밍<br>안민영(2045025): 팀원, 백엔드 프로그래밍, DB<br>임수화(2176313): 팀원, 머신러닝 및 알고리즘 프로그래밍 |
| (4) 팀 지도교수 | 최병주 |
| (5) 팀 멘토 | 김수보 / 한빛미디어 / 소장 |
| (6) 과제 키워드(keywords) | 화장품, 성분, 추천 |
| (7) 과제 내용 요약 | 스킨트리는 수많은 화장품 속에서 나의 피부에 딱 맞는 화장품을 쉽게 찾을 수 있도록 돕는 서비스입니다. 사용자가 사용해보고 잘 맞았다고 생각하는 제품을 입력하면 해당 제품의 성분을 분석해 머신러닝과 협업 필터링을 거쳐 성분 민감도가 유사한 성분 메이트를 찾아 맞춤형 화장품을 찾아드립니다.|
| (8-1) 과제: 문제의 정의 |  1) 제품을 선택할 때 피부 유형과 민감도를 고려하여 화장품을 선택하는 것은 소비자들에게 복잡한 과정으로 여겨진다. 잘못된 제품 선택으로 인해 피부에 부정적인 영향을 미칠수 있기 때문에 각 개인의 성분 민감도와 알레르기 반응을 고려해야 하지만 이를 위해 필요한 정보를 일일이 찾아보는 것은 번거롭다.<br><br> 2) 화장품 시장에는 다양한 브랜드와 제품이 존재하며, 이로 인해 소비자는 적합한 제품을 선택하는 것에 어려움을 겪을 수 있다. 이러한 다양성 때문에 소비자는 제품 선택을 위해 많은 시간과 비용이 소요할 수 있다.<br><br> 3) 기존에 사용하던 제품이 단종되거나 가격이 인상되면 소비자는 다른 제품을 찾게 되는데 이와 유사한 대체 제품을 찾는 것은 소비자에게 어려운 과제일 수 있다.<br><br> 4) 현재 화장품을 추천하는 경우, 가장 많이 쓰이는 방법은 피부 타입 별 추천인데 대부분의 추천은 건성인지 지성인지와 같은 상위 분류만을 따지기 때문에 개인의 피부상태와 정확히 일치하는 화장품 추천이 어렵다. 이에 기존의 피부타입 분류에서 더 나아가 개인에게 더 밀접한 화장품 추천이 필요하다. |
| (8-2) 과제: 기존연구와의 비교 | 1) 화해: 화장품별 전성분구성을 기본으로 제공하고 주의, 알레르기 성분, 목적 별 성분정보, 피부타입 관련 성분 정보를 제공한다. <br> 장점: 식품의약품안전처나 대한피부과의사회 발표자료에 따른 성분에 대한 정보를 제공하여 성분에 대한 일반화된 정보를 알 수 있다.<br> 단점: 화장품 성분 정보 제공이 메인 기능으로 즐겨 찾는 성분을 직접 입력 해야하는 불편함이 있고 성분이 비슷한 ‘같은’ 카테고리의 화장품 1:1 추천만 제공한다.<br><br> 2) 올리브영: 구매 순 랭킹 제공하고 사용자가 조회한 상품과 유사한 제품 혹은 성분이 비슷한 ‘같은’ 카테고리의 화장품을 추천한다. <br> 장점: 카테고리별 구매랭킹을 다양한 기간으로 설정하여 볼 수 있어 대중적으로 인기있는 상품 구매를 할 수 있다. <br> 단점: 단순 구매 순 랭킹은 개인 맞춤형 화장품 추천이라는 목표와 벗어나고 기획 이벤트, 마케팅적 요소에 의한 결과일 수 있다는 한계가 존재한다.<br><br> 3) 잼페이스: 퍼스널 컬러 별 화장품 추천, AI 화면 인식을 통한 피부타입 및 피부고민 측정에 따른 화장품 추천 기능을 제공한다.<br> 장점: AI를 통해 피부상태를 판단하여 중점적으로 케어 해야 할 고민과 그에 따른 추천상품을 알 수 있다. <br>단점: 조명, 카메라 화질에 따라 달라지는 AI 피부측정의 부정확성이 존재하고, AI 를 통해 판단된 피부타입별로 미리 정해진 추천 화장품이 제공되기 때문에 피부타입에서 더 세분화된 추천은 제공하지 않는다. |
| (8-3) 과제: 제안 내용 | 사용자와 성분 민감도가 비슷한 다른 사용자의 경험을 바탕으로 소비자들이 화장품을 고를 때 본인에게 잘 맞지 않을 수도 있는 불확실성을 줄이고 보다 소비자에게 최적화된 제품 선택지를 제시하여 편리한 선택을 할 수 있도록 돕는 서비스를 제안한다. 현재 화장품 선택을 도와주는 유사 경쟁 서비스들은 제품 자체의 성분만을 비교하여 추천을 제공하는 반면 이 서비스는 사용자들에게 기존에 본인이 잘 사용하는 화장품을 입력 받아 이를 기반으로 사용자의 성분 민감도를 계산하여 더욱 정교하고 높은 신뢰성의 맞춤형 추천을 제공한다. 전체적인 과정은 다음과 같다. 사용자로부터 기존에 본인에게 잘 맞았던 화장품을 입력 받아 이로부터 각 제품의 전 성분 분석을 통한 사용자의 성분 리스트를 생성한다. 이를 기반으로 해당 사용자와 성분 유사도가 높은 그룹을 협업 필터링 알고리즘을 통해 추출하여 그 그룹에서 적합하다고 입력한 화장품을 사용자에게 추천한다. |
| (8-4) 과제: 과제의 주요 기능 | 두가지 추천 기능<br><br>1. 사용자 간의 성분 유사도를 계산하여 매칭 사용자를 찾아 매칭 사용자가 입력한 화장품을 추천하는 기능<br>:메모리 기반 협업 필터링 알고리즘을 사용하며 인풋으로는 사용자의 입력 데이터(기존에 잘 사용하던 제품)를 기반으로 해당 제품의 성분을 추출한 개별 사용자의 성분 리스트를 사용합니다.<br><br>2. 화장품 성분과 사용자의 성분 민감도 간의 유사도를 계산하여 제품을 추천하는 기능<br>:K평균 군집화 비지도 학습을 사용하며 모델의 피처로는 제품 데이터의 전성분을 벡터화하여 2 차원으로 축소한 피처 공간을 사용합니다. |
| (8-5) 과제: 구현 방법 |크롤링으로 화장품 데이터를 수집하고 협업 필터링과 비지도학습 군집화 모델을 이용한다.<br> 1. Application의 동작 환경 (서비스 환경): 크롬 웹 브라우저<br> 2. frontend: html, css, flask<br> 3. backend: flask, AWS EC2 Ubuntu 22.04<br> 4. database: mysql<br> 5. 머신러닝: scikitlearn, numpy, pandas, bs4, matplotlib<br> 6. 수집 데이터: https://kcia.or.kr/cid/main/ (대한화장품협회 성분사전), Incidecoder의 Product List, Product & Ingredients|
| (8-6) 과제: 세부 기술 |1) 자연어 처리(Natural Language Processing, NLP): 사용자가 입력한 화장품의 성분 정보를 처리하고 성분 간의 유사도를 계산하는 데에 사용한다. NLP 기술을 사용하여 성분 정보를 토큰화하고 벡터화하여 성분 유사도를 측정하는데, 적용 가능성을 검증하기 위해 전처리된 자연어를 출력하여 올바른 형태인지 분석한 후 벡터화된 성분들을 확인하여 해당 벡터의 값이 올바른 값인지 검증한다.<br><br>2) 유사도 계산 알고리즘: 협업 필터링 알고리즘과 자카도 유사도를 사용하여 구현하고 적용할 수 있다. 사용자의 성분 리스트에 들어간 값들과 유사도 계산 결과를 비교하여 추출된 유사도의 정확도를 검증한다.<br><br> 3) k평균 클러스터링 모델: K평균 군집화를 사용하여 제품들을 군집화하고 사용자의 성분 민감도와 군집 내 제품들 간의 유사도를 계산한다. 이때 전채 군집화의 실루엣 계수를 계산하여 군집화의 수준을 검증하고 각 군집의 실루엣 계수와 비교하여 해당 클러스터링이 사용자에게 맞춤형 제품을 추천할 수 있는 군집인지 확인할 수 있다. |
| (8-7) 과제: 기대 효과 및 의의 |1) 맞춤형 제품 추천을 통해 사용자들의 피부 건강을 증진시킬 수 있도록 한다. 각 사용자의 피부 타입과 민감도를 고려하여 최적의 제품을 추천함으로써 사용자는 피부 문제를 예방하고 개선할 수 있다. <br> 2) 잘못된 화장품 선택으로 인해 버려지는 화장품 낭비를 막는다. 이를 통해 사용자들은 지속 가능한 소비를 이루며 환경에 미치는 부정적인 영향을 최소화할 수 있다.<br> 3) 화장품 선택의 편의성을 증진시킨다. 간편한 추천을 통해 적합한 제품을 찾는 시간과 비용을 절약하고 뷰티 쇼핑이 더 편리해지도록 한다. |
| (9) 데모 내용 | 데모환경 : 크롬 웹브라우저 (모바일 환경이 메인)<br> 1) 이메일 입력 후 추천 버튼 클릭<br> 2) 사용자 데이터 입력(기존에 사용하던 제품)<br> 3) 카테고리 선택<br> 4) 성분 프렌즈 추천 목록 띄우기<br> 5) 다시 추천받기 버튼 클릭 후 기존 제품 추천 화면으로 이동<br> 6) 새로운 사용자 데이터 입력<br> 7) 카테고리 선택<br> 8) 에디터 추천 목록 띄우기  |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-39
| (1) 과제명 | 객체 인식과 OCR을 활용한 객관·단답식 시험지 채점 AI 소프트웨어
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 39-순간포착 |
| (3) 팀원 역할 분담 | 이주현(1871041): 리더, 계획 및 데이터 라벨링 및 AI training 및 정확도 평가<br>성아정(1971026): 팀원, UI 설계·구축 및 데이터 라벨링 및 데이터 후처리<br>정나영(2129033): 팀원, 자료조사 및 데이터 라벨링 및 데이터 전처리 |
| (4) 팀 지도교수 | 반효경 교수 |
| (5) 팀 멘토 | 김영우 / 크몽 / SRE/DevOps Engineer |
| (6) 과제 키워드(keywords) | 시험지 채점, 채점 자동화, 객체 인식 |
| (7) 과제 내용 요약 | 저희는 시험지 대량 채점 자동화를 위한 시험 기관용 PC 실행 어플리케이션, <포인트 체커>를 개발하고 있습니다. 객체 인식과 OCR을 사용하여, 별도의 답안지 없이 응시자의 시험지를 스캔 이미지의 형태로 입력 받아 채점 결과를 데이터 파일로 출력하는 프로그램을 개발 중입니다. 배포는 실행 어플리케이션의 형태로 할 예정입니다. 채점에 들어가는 인력과 비용을 감축하여, 편하고 빠른 채점 경험을 시험 기관에 제공하는 것이 <포인트 체커>의 목표입니다. |
| (8-1) 과제: 문제의 정의 | 현재 채점방식의 문제 분석 및 정의<br><br> 1. PBT (Paper Based Test) :  컴퓨터 상에서 시험을 진행하는 방식<br>   a. 수기 채점 방식 : 채점자가 직접 채점<br>    -단점 : 많은 인력과 시간 소요, 부정확성<br>   b. OMR 채점 방식 : OMR 카드에 마킹된 답안을 컴퓨터를 사용해 채점<br>     -단점 : 별도의 답안지 작성 필요, OMR 마킹 실수 발생, 단답 채점 불가능, OMR 카드 구매 필요<br><br> 2. CBT (Computer Based Test) : 종이 서류 상에서 시험을 진행하는 방식<br>    -단점 : 네트워크나 컴퓨터 하드웨어 문제 발생 가능, 부정행위의 가능성, 눈의 피로 야기, 응시자 집중도 하락 야기 |
| (8-2) 과제: 기존연구와의 비교 | 1. 연구<br>   a. 딥러닝 기반 어린이 손글씨 답안 자동 채점 시스템<br>     -선생님이 하나씩 손글씨 답안지를 직접 보고 채점하는 것이 아니라, 어린이 손글씨를 인식하여 텍스트로 변환 후, 정답과 비교해 자동으로 채점.<br>     -강점: 답안 영역을 찾아 이미지로 저장해 이미지를 필기체 인식을 통해 텍스트로 변환하고 이를 정답과 비교하여 자동으로 채점.<br>     -약점: 글씨가 배경과 겹치거나 낙서 또는 일정하지않은 글씨로 인해 정확도가 낮음.<br>   b. EasyOCR을 이용한 정형화된 객관식 답안지의 자동채점 시스템 구현<br>     -정형화된 답안지에 필기체로 답안지를 작성하면, easyOCR을 사용하여 자동 채점하는 시스템.<br>     -강점: 숫자인식 모델의 성능을 개선하여 93%의 인식률을 가짐<br>     -약점: 정형화된 답안지를 따로 작성해야 함.<br><br> 2. 서비스<br>   a. 이코딩 (http://edu-coding.co.kr/)<br>     -omr을 사용하는 것이 아닌 앱의 스마트 omr을 사용하여 자동 채점.<br>     -강점: 학원용, 학생용, 학부모용으로 나뉘어 맞춤 제공 서비스가 존재, 출결, 결제, 채팅 등 다양한 기능이 존재하며, 자동으로 오답만 뽑아 정리해줌.<br>     -약점: 앱을 통해 문제를 풀어야 채점이 자동으로 됨. <br>   b. 에듀허브 (https://eduhub.co.kr/)<br>     -omr 종이 없이, 일반 a4에 omr 양식을 인쇄하여 이를 omr지 대신 사용 가능.<br>     -강점: omr 종이를 따로 구매하지 않아도 스캐너를 통해 채점할 수 있음. 자동으로 오답만 뽑아 정리해줌.<br>     -약점: a4에 omr 인쇄 후 스캐너로 채점하거나 스마트 omr을 사용해야 채점이 자동으로 됨. 스캐너를 사용한 경우, 객관식 문제만 자동 채점이 가능함. omr 양식의 답안지를 무조건 사용해야함.<br><br> 3. 시스템<br>   a. OMR<br>     -별도의 규칙이 있는 답안지를 따로 제작하여 답안지에 빛을 비추어 표시된 위치를 얻는 기술.<br>     -강점: OMR 카드 전용 리더기를 사용할 경우 대량의 답안지를 매우 빠르고 정확한 속도로 채점이 가능함.<br>     -약점: 특정 양식을 준수한 답안지만 사용해야하며, 시험지 외에 별도의 답안지를 따로 구매해야해서 비용이 발생함. OMR카드 전용 리더기가 비싸서 소규모의 업장에서는 하드웨어 구매 시 부담을 느낌. 단답식의 채점은 불가함. |
| (8-3) 과제: 제안 내용 | CBT 방식의 한계점과 PBT 방식의 한계점을 모두 극복하기 위해, 별도의 마킹 답안지 없이 시험 지에 적힌 필기를 인식하여 자동으로 채점해 주는 AI 소프트웨어를 개발할 것입니다. 이를 통해 응시자는 가독성이 좋다는 PBT 방식의 장점과 더불어, OMR 마킹을 위한 시간을 따로 마련하지 않아도 된다는 장점을 누리게 될 것이며, 채점자는 간소화된 채점 과정을 통해 채점에 들어가는 인력 및 시간과 비용을 절감하는 효과를 누릴 수 있을 것입니다. 또한 객관식과 더불어 단답식 채점 구현을 통해, 단순 채점을 넘어선 복잡한 채점 소프트웨어 구현을 하여 보편성과 사용성 확 보를 기대할 수 있습니다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 시험지 양식 적용: 응시자별 시험지 구분을 위해 입력받은 응시 인원과 페이지수에 따른 문자와 ID 쓰는 부분을 나타내는 선 삽입<br><br>2. 각 시험지 구분을 위한 응시자 정보 인식 기능: 대량의 시험지를 입력 받을 예정이므로, 각 시험지 구분을 위해 첫 장에 표시된 응시자 정보를 인식하도록 Yolov8 모델을 학습시켰습니다.<br><br>3. 각 시험지의 문제와 답 영역을 추출: 객체 인식 모델인 Yolov8을 사용하여 문항과 답을 묶어 인식하며, 객관식/주관식/잘린 객관식/잘린 주관식을 나눠서 저장합니다.<br><br>4. 추출한 문제와 답 영역 중 잘린 문제 처리: 잘려나간 문제는 주로 두 부분으로 나뉘므로, 부족한 정보를 인식해 매칭하는 Yolov8 모델을 통해 잘린 문제를 이어붙여 저장합니다.<br><br>5. 각 문항에 표시한 응시자의 필기를 분석: 각 문항에서 객관식 선지를 골랐거나 단답식 서술을 하여 시험지에 기록한 답안을 Yolov8을 사용해 인식해 전산화합니다.<br><br>6. 응시자별 답안 채점: 전산화 된 응시자의 답과 입력된 정답을 비교하여 채점합니다.<br><br>7. 최종 결과를 데이터 파일 형태로 제공<br><br>8. 응시자의 필기 데이터를 시각화하여 이미지로 제공 |
| (8-5) 과제: 구현 방법 | 1. 객체 인식 기술 사용<br>   -딥러닝 기반의 CNN을 사용하여 각 시험지 이미지의 특징을 추출하고 패턴을 학습.<br><br> 2. 데이터 수집 및 라벨링<br>   -표지 인식 모델을 훈련시키기 위한 시험지 로우 데이터를 수집하고 라벨링함. 처음에는 체크만으로 이루어진 시험지로 학습하고, 점차 다양한 유형의 표식과 다양한 시험지 양식을 포함해 모델을 발전시킴.<br><br> 3. 소프트웨어 인터페이스 개발<br>   -사용자가 쉽게 사용할 수 있는 소프트웨어 인터페이스를 개발해 사용자가 시험지를 업로드하면 채점 결과를 확인할 수 있도록 함.<br><br> 4. 성적 결과 제공<br>   -시험지 채점 결과를 계산해 성적 제공.<br><br> 5. 모델 성능 평가 및 지속적인 개선<br>   -사용자 피드백을 수집해 모델의 성능을 지속적으로 향상시킴. 추가적인 훈련 데이터를 확보하고 모델의 가중치 및 하이퍼 파라미터를 조정해 정확도를 높임. |
| (8-6) 과제: 세부 기술 | YOLOv8, easyOCR, OpenCV, labelImg |
| (8-7) 과제: 기대 효과 및 의의 | 1. 비용 절감<br>   -채점에 필요한 인력 낭비를 줄임으로써 인건비 절감<br>   -OMR 용지나 컴퓨터용 싸인펜 구매 비용 절감<br><br> 2. 환경 보호<br>   -OMR 용지를 따로 제작하지 않아도 되어 이에 사용되는 종이 절약<br><br> 3. 응시자의 표기 다양성 존중<br>   -정해진 규격에 맞추어 응답을 하지 않아도 되므로 개인별로 자신에게 익숙한 표기 법을 이용하여 답을 표기 가능<br><br> 4. 다양한 사람들에게 시험 응시 기회 제공<br>   -답안지를 따로 작성할 필요가 없어, OMR 작성이 어려운 응시자들도 쉽게 시험에 응시 가능<br><br> 5. 답안지 작성 교육 및 연습 불필요<br>   -답안지 작성에 대한 별도의 교육 불필요|
| (9) 데모 내용 | Demo1. 시험지 양식 적용<br>  1) 포인트체커 어플리케이션 실행<br>  2) '시험지 양식 적용' 버튼 클릭<br>  3) 응시자 수 입력<br>  4) 시험지 원본 파일을 선택<br>  5) '인쇄용 파일 저장' 버튼 클릭<br>  6) 저장된 파일 확인<br><br> Demo2. 객관식/주관식 문항 채점 후 결과 확인<br>  1) 포인트체커 어플리케이션 실행<br>  2) 시험 정보 입력<br>  3) 채점할 시험지 파일 업로드<br>  4) 정답 입력<br>  5) '채점하기' 버튼 클릭<br>  6) '결과 확인하기' 버튼 클릭<br>  7) 출력된 결과 확인<br>  8) '결과 다운로드' 버튼 클릭<br>  9) 저장된 파일 열어 보여주기 |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-40
| (1) 과제명 | FingerSpell: 초등학생 장애 인식 개선을 위한 모션인식 수어 게임
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 40-흰토끼 |
| (3) 팀원 역할 분담 | 김지수(2117009): 리더, 계획 수립, 문서화, 데이터셋 제작<br>신소현(2071029): 게임 내 주요 시스템 구현, 데이터셋 제작<br>Tan Jiali(2071085): 게임 스테이지 구현 및 제작 |
| (4) 팀 지도교수 | 이미정 |
| (5) 팀 멘토 | 이정욱 / (주)엔테코 인터렉티브 / CEO |
| (6) 과제 키워드(keywords) | 모션인식, 게임, 수어 |
| (7) 과제 내용 요약 | 초등학생 장애 인식 개선을 위한 모션 인식 수어 게임을 개발한다. 수어는 한글의 자음, 모음을 표현하는 지문자에 한한다. 플레이 가능한 게임은 2개 scene이 있다. 기본 학습을 위한 퍼즐 요소가 있는 횡스크롤 2D 플랫폼 게임과, 심화 학습을 위한 타임어택 게임으로 구성되어 있다. 계획 상, 기본 학습에서는 ㄱ,ㄴ,ㄷ,ㄹ까지 학습할 수 있을 것이고, 심화 학습에서는 모든 지문자를 학습 가능할 것이다. |
| (8-1) 과제: 문제의 정의 | 심화되는 장애인 차별과, 비장애인 학생들이 장애학생을 자신과는 아예 다른 존재라고 이해하고, 장애에 대한 이질성과 거부감을 더욱 느끼게 만드는 형식적인 장애이해교육 |
| (8-2) 과제: 기존연구와의 비교 | popsign :미국 수어 교육용 퍼즐 보블류 게임. 게임을 통해 수어를 배울 수 있으며, 플레이어가 직접 수어를 하는 것이 게임에 반영된다. 하지만 한국 수어는 지원하지 않는다. 또한, 인식률이 낮다. <br>중국 학교 수어교육과정: 중국의 학교와 교육기관에서 제공하는 수어교육과정으로 중국수어(CSL)나 중국수어의 다양한 형태를 가르치기 위한 것. 이 수업들은 수어 기초, 수어 어휘, 문법 규칙 등을 다룬다. 그러나 교육자 및 학생 간의 상호작용과 효과적인 교육 방법이 중요하며, 이는 교육자의 역량에 의존하기 때문에, 향상시키는데 어려움이 있을 수 있다. |
| (8-3) 과제: 제안 내용 | 장애인 차별이 심화되고 있다. 그런데, 학교의 형식적인 장애 이해 교육은 오히려 비장애인의 장애에 대한 이질성과 거부감을 향상시킨다. 따라서, 초등학생의 장애 인식 개선을 위해, 모션인식 기술을 활용한 수어 교육 게임을 개발한다. 개선률을 높일 수 있도록 실제 초등학교 학교 장애 이해 교육에서 사용하는 교재에서 모티브를 얻어 스토리를 구성한다. 또한, 일상 속에서 장애 수용 태도를 증진시킬 수 있도록 접근성이 높은 Window 플랫폼에서 구동할 수 있고, 높은 사양을 필요로 하지 않으며, 수어의 인식률이 높고 반응이 빠르도록 한다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 손동작 인식<br>2. 지화의 의미 파악<br>3. 플레이 가능한 게임 scene 2개<br>3-1. 수어 기본 학습 scene : 퍼즐 요소가 있는 횡스크롤 2D 플랫폼 게임<br>3-2. 수어 심화 학습 scene : 떨어지는 자음, 모음을 일정 시간 내에 수어로 맞추는 게임 |
| (8-5) 과제: 구현 방법 | 1. Mediapipe 를 활용한 손동작 인식 <br>2. KNN 알고리즘을 활용한 지문자의 의미 파악 <br>3. Unity 게임 엔진을 활용한 플레이 가능한 게임 scene 2 개 <br>3-1. 퍼즐 요소가 있는 횡스크롤 2D 플랫폼 게임 <br>3-2. 떨어지는 자음, 모음을 일정 시간 내에 수어로 맞추는 게임 |
| (8-6) 과제: 세부 기술 | 수어 의미 파악 모듈은 Mediapipe 에서 전송되는 실시간 데이터를 한 번에 하나씩 받아, 유클리드 거리 등을 활용하여 landmark 와 landmark 위치 정보를 기반으로 각 관절 사이의 각도를 계산한다. 이후 KNN 알고리즘을 활용하여, 미리 만들어 놓은 dataset 중가장 거리가 가까운 K 개를 골라 가장 빈번한 라벨과 일치하는 gesture 를 반환한다. 반환 후, 다시 Mediapipe 로부터 데이터가 들어오면 기능 수행을 반복한다. |
| (8-7) 과제: 기대 효과 및 의의 |2024 년 3 월 26 일 기준, 모션인식 기술을 활용한 한국 수어 교육 게임은 존재하지 않는다. 따라서, 새로운 형식의 수어 교육이라는 점에서 의의가 있으며, 이를 통해 장애이해도를 향상시키고, 사회 통합과 안정을 가져올 수 있을 것으로 기대된다.  |
| (9) 데모 내용 | 1. 수어 기본 학습 scene : <br>1) 플레이어 움직임 구현 <br>2) 수어 인식 및 입력 받은 수어와 일치하는 오브젝트 파괴 <br>3)NPC 이동 및 대사창 구현 <br>2.수어 심화 학습 scene: <br>1) 오브젝트의 무작위 배치와 플레이어 캐릭터로의 이동 <br>2) 플레이어 캐릭터가 오브젝트에 닿을 시 hp 감소  |
| (10) 기타 | https://store.onstove.com/ko/games/3571 게임 출시 페이지 |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-41
| (1) 과제명 | MATHORY: 재미있는 프롬프트 생성 기반 스토리텔링형 초등 수학 교육 게임
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 41-초이배리 |
| (3) 팀원 역할 분담 | 이나영(2071090): 리더, 프론트엔드: 게임 클라이언트(Unity), 백엔드: 게임 서버 (ASP.NET Core), AWS 연결 <br>배소현(2076183): 팀원, 백엔드: chat GPT 파인 튜닝 모델, 게임 서버 (ASP.NET Core), AWS 연결<br>Choi Hannah Vanessa(2171001): 백엔드: chat GPT 파인 튜닝 모델, 게임 서버 (ASP.NET Core), AWS 연결 |
| (4) 팀 지도교수 | 이형준 교수님 |
| (5) 팀 멘토 | 조광래 / 넷마블 잼팟 / CTO |
| (6) 과제 키워드(keywords) | 초등학교 수학, 게임, 스토리텔링 |
| (7) 과제 내용 요약 | Mathory는 초등학생을 대상으로 한 스토리텔링형 수학 교육 게임으로, 프롬포트 생성 기술인 chatGPT 파인튜닝을 이용하여 다양한 스토리와 해당 스토리와 관련된 수학 문제를 만든다. 학생들은 매번 플레이할 때마다 달라지는 새로운 스토리와 함께 게임을 즐기며 흥미롭게 수학 공부가 가능하다. 따라서 공부하는 동안 계속 흥미가 유지될 수 있으므로, 아이들은 모르는 개념을 배우는 수학 공부의 과정을 즐기며 수학을 배울 수 있다. |
| (8-1) 과제: 문제의 정의 | 많은 초등학교 학생들이 수학을 재미없고 어려운 영역으로 여기기에, 학생들에게 학습 동기와 흥미 유발이 필요하다. |
| (8-2) 과제: 기존연구와의 비교 | 1. Toon Math<br>장점: 수학 연산 및 난이도를 설정할 수 있어 사용자의 수준별로 게임 플레이를 할 수 있다.<br>단점: 수학 학습이 중점인 게임라기보다는 부가적인 요소로 들어간 게임으로, 학습 효과가 부족할 것으로 보인다.<br><br>2.토도수학<br>장점: 직관적인 룰의 사용으로 이해가 쉽다. 처음 게임 실행 시, 사용자의 수학 수준을 선택할 수 있어 사용자의 수준별로 게임 플레이를 할 수 있다.<br>단점: 게임이라기보단 퀴즈에 더 가까워보이는 게임의 룰. 아이들의 흥미를 끌 만한 요소가 적어서 쉽게 지루해질 수 있다.<br><br>3. 수학의 제왕<br>장점: UI와 게임의 규칙이 직관적이다.<br>단점: 게임이라기보단 퀴즈에 더 가까워보이는 게임의 룰. 게임 단계를 설정하지 못하고 순서대로 게임을 진행해야 함.<br><br>세 가지 게임 모두 다른 문제점이 있지만, 종합적으로 보았을 때 교육적인 측면이나 오락적인 측면에 치중하여 다른 하나를 놓친다는 문제점을 볼 수 있었다. 또한, 일부 게임에서는 사용자의 교육 수준을 파악하지 못하고 가장 낮은 수준부터 게임을 진행해야 하였다. <br>'Mathory'에서는 세 가지 게임과 다르게 "스토리텔링" 요소를 강조하여 차별점을 두었다. 또한, 회원가입 시 사용자의 학년을 입력함으로써 사용자들의 수준에 맞게 게임을 플레이 할 수 있도록 한다. 따라서 문제 수준에 따라 단계적이고, 오락 및 교육적인 측면까지 모두 고려한 수학 교육 게임을 개발하고자 한다. |
| (8-3) 과제: 제안 내용 | [게임 진행 방식] <br>1. 사용자는 존재하는 캐릭터 중, 자신의 게임에 등장시키고자 하는 2~3명을 고른다. <br>2. ChatGPT를 활용하여 주인공과 사용자가 고른 캐릭터의 성격과 특성에 맞게 스토리가 진행된다. 큰 틀에서의 배경과 테마/주제는 설정되어 있지만, 주인공과 선택한 캐릭터에 성격에 따라 이야기의 결말은 다양하게 진행된다.<br>3. 스토리를 진행 중간에 수학 퀴즈를 풀어야 하는 구간이 있고 퀴즈는 진행되는 스토리와 연관되어 있다. 모든 퀴즈를 풀었으면 스토리를 완성하고 다음 레벨로 통과할 수 있다. 틀린 문제가 있으면 틀린 문제에 대한 풀이를 보여준다.  |
| (8-4) 과제: 과제의 주요 기능 | 1. 선택된 캐릭터와 게임 줄거리를 제공하는 프롬프트에 따른 게임 시나리오 생성 <br>2. 게임 레벨 및 생성된 스토리에 따른 자연어 퀴즈 생성 <br>3. 사용자의 정보 제공 페이지 |
| (8-5) 과제: 구현 방법 | 1. Unity를 이용하여 게임 프론트 생성 <br>2. ASP.NET CORE를 이용하여 서버 구축 및 게임 프론트(Unity)와 연결 <br>3. MSSQL를 통한 데이터 저장 <br>4. Microsoft Azure의 VM으로 ASP.NET CORE과 MSSQL 운영 <br>5. chatGPT를 활용한 스토리 및 퀴즈 생성 모델 구축 <br>6. Canva의 이미지 생성 기능(Magic Media)을 통한 스토리 배경 및 인물 그림 생성 |
| (8-6) 과제: 세부 기술 | 1. 게임 줄거리를 제공하는 프롬프트에 따라 chatGPT의 파인튜닝을 활용하여 게임 시나리오를 생성한다. <br>1)사용자가 스토리에 등장시키고 싶은 캐릭터를 2-3명을 고른 후, [이야기 프롬프트 만들기]코드를 통해 랜덤으로 스토리의 목표가 선택된다. <br>2)목표에 따라 [스토리 생성 모델]의 프롬프트가 생성된다. [스토리 모델]에서는 프롬프트에 맞게 발단-전개-위기-결말의 양식으로 스토리가 생성된다. <br><br>2. 게임이 진행되는 중간에는 해당 레벨에 맞고, 게임의 스토리와 연관이 있는 수학 문제가 chatGPT의 파인튜닝 모델을 활용하여 생성된다. <br>1)학년에 맞게 수학 식을 [수학 식 만들기] 코드를 통해 생성한다. 단, 수학 식은 식으로 나타낼 수 있는 것만 포함되며 도형, 그래프 등 그림과 관련된 문제는 제공하지 않는다. <br>2)[수학 퀴즈 생성 모델]은 [스토리 생성 모델]에서 생성한 스토리를 발단-전개-위기-결말에 따라 나눈 이야기의 일부와 학년에 맞는 수학 식을 input으로 받아서 이야기에 맞는 해당 수학 식을 사용하는 자연어로 작성된 수학 문제를 생성한다. |
| (8-7) 과제: 기대 효과 및 의의 | 사용자들이 매번 플레이 할 때 마다 달라지는 새로운 스토리와 함께 게임을 즐기며 흥미롭게 수학 공부가 가능하다. 따라서 공부하는 동안 계속 흥미가 유지될 수 있으므로, 아이들은 모르는 개념을 배우는 수학 공부의 과정을 즐기며 수학을 배울 수 있다. |
| (9) 데모 내용 | 1. 아이디를 입력하여 게임에 접속한다. <br>2. 원하는 게임 레벨을 선택한다. <br>3. 이야기에 등장시키고자 하는 캐릭터 2-3명을 선택한다. <br>4. 선택한 캐릭터들이 등장하는 이야기와 해당 이야기와 어울리는 수학 퀴즈가 만들어져 각 이야기 및 퀴즈는 유니티 화면을 통해 보여진다. <br>5. 퀴즈를 맞추고 게임이 끝나면, 퀴즈의 풀이가 제공된다. |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-42
| (1) 과제명 | DRIVE GUARDIAN : 운전자 모니터링 앱 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 42-왈라비 |
| (3) 팀원 역할 분담 | 이하진(2176308): 리더, Landmark detection, UI/UX 프로그래밍, DB<br>박지현(2176155): 팀원, Object detection, UI/UX 프로그래밍<br>이지원(2171038): 팀원, Landmark detection |
| (4) 팀 지도교수 | 이형준 교수님 |
| (5) 팀 멘토 | 이태영 / 신한은행 / 연구원 |
| (6) 과제 키워드(keywords) | CV, 운전자 모니터링, 졸음 탐지 |
| (7) 과제 내용 요약 | &emsp;Drive Guardian은 운전자들에게 스스로 이상행동을 모니터링 할 수 있는 앱 서비스를 제공하여 사고발생 위험을 줄이고자 합니다. 운전자의 상태는 평상시, 주의력 부족으로 인한 부주의 상태, 수면부족으로 인한 졸린 상태, 위험 상태로 분류됩니다. 부주의 상태에서는 흡연과 운전자 이탈을 감지하고, 졸린 상태는 하품, 눈 깜박임 횟수와 눈 크기를 종합하여 졸림여부를 판정합니다. 부주의 상태 또는 졸음상태가 감지되면 각 상태에 따라 경고 방식을 달리하여 운전 중 졸음과 부주의를 방지합니다. |
| (8-1) 과제: 문제의 정의 | &emsp;졸음 운전과 주시 태만으로 인한 교통사고는 사망자 비율이 80%에 육박합니다. 또한 교통안전공사의 조사에 따르면 화물차 운전자 10명 중 8명이 최근 1년 사이에 졸음운전을 경험한 것으로 나타납니다. 졸음운전은 운전자는 물론 보행자나 다른 운전자까지 사망에 이르게 할 수 있기 때문에 제대로된 대비책이 마련되어야 하는 심각한 사안입니다. 이러한 문제를 예방하기 위해 운전자 모니터링에 대한 선행 연구들이 많이 있다고는 하지만 거의 대부분의 이러한 서비스들은 특화 장치 구매를 필요로 합니다. DSM처럼 자동차 자체에서 제공하는 서비스는 아직 상용화되지 않았기 때문에 장시간 운전해야하는 화물차, 택배 운전기사와 같이 졸음운전에 취약한 운전자들을 포함한 대부분의 운전자들은 아직까지 졸음 운전 방지 서비스를 제공받지 못하고 있습니다. 따라서 저희는 이렇게 모든 운전자들에게 접근성이 높은 졸음방지 앱 서비스를 제공하여 사고발생 위험을 줄이고자 합니다. |
| (8-2) 과제: 기존연구와의 비교 | &emsp;현대모비스, 기아의 운전자 상태 모니터링 시스템 DSM은 적외선 카메라와 영상 센싱 기술로 운전자의 얼굴과 동공 상태를 감지하여 정상적인 운전 상태가 아니라고 판단될 경우 주의를 주는 시스템입니다. 또한, 차량과 별개로 사용자가 구입할 수 있는 ‘AIKEEP’도 출시되어 있습니다. 기존 제품의 장점은 최적화된 소프트웨어에 의한 빠른 프로세싱 속도입니다. 다만, 대부분 아직 상용화되지 않았으며, AI딥러닝 기술과 하드웨어 시스템의 조합으로 구성되어 있기에 상용화 과정에서 하드웨어의 비용 문제가 발생할 수 있다는 단점이 있습니다.<br><br>&emsp;이에 본 팀은 사용자의 부담을 덜고 접근성을 높이기 위해 운전 중 스마트폰을 통해 졸음을 모니터링하고 알림을 받을 수 있는 앱 서비스를 개발하고자 합니다. 또한, 기존 제품들의 기능에 더하여 졸음뿐만 아니라 운전중 부주의 행동 또한 모니터링할 수 있도록 기획했습니다. |
| (8-3) 과제: 제안 내용 | &emsp;저희는 딥러닝 모델을 이용한 운전자 모니터링 앱 서비스 ‘Drive Guardian’을 개발하고 있습니다. 이미지를 인식하고 분류하는 Object Detection과 얼굴을 인식할 수 있는 Landmark Detection, 사람의 몸을 인식할 수 있는 Pose Estimation 모델을 이용하여 운전 중 졸음과 부주의 행동을 탐지합니다. 일정 기준 이상의 졸음과 부주의 행동이 탐지되면 Alert를 실행하여 운전자가 위험 상황에서 벗어나게 합니다.이를 효과적으로 구현하기 위하여, 운전자의 상태는 크게 평상시 상태, 부주의 상태, 졸음 상태로 구분됩니다.<br>&emsp;부주의 상태를 탐지할 때에는 흡연, 운전자 자리 이탈(전방 미주시, 몸을 조수석을 돌리는 행위 등) 두 가지 요소에 대한 Object Detection을 각각 실행하고, 두 모델의 탐지 결과의 빈도나 양상이 일정 기준 이상에 해당하면 Alert로 주의를 환기하는 경고 음성을 출력하여 빠르게 부주의 상태에서 벗어날 수 있도록 합니다.<br>&emsp;졸음은 또다시 졸린 상태와 완전히 수면 상태에 접어든 위험 상태로 구분됩니다. 졸린 상태를 탐지할 때에는 하품에 대한 Object Detection, 눈 깜빡임 빈도와 눈 크기에 대한 Landmark Detection을 실행하여, 두 모델의 탐지 결과를 종합하여 부주의 상태와 마찬가지로 일정 기준 이상일 시 졸린 상태로 판정합니다. 이때 Alert로 졸음 쉼터를 안내하는 등의 경고 음성을 출력합니다.<br>&emsp;위험 상태는 Pose Estimation으로 얼굴의 숙인 각도를 탐지하여 위험상태로 판정합니다. 이 경우 Alert 음성을 다른 단계들에 비해 강한 강도로 출력합니다.사용자는 앱을 이용하여 운전 모니터링 서비스를 편리하게 사용할 수 있고, 이 앱을 통하여 졸음 및 부주의 운전 방지에 좋은 효과를 가져올 수 있을 것입니다. |
| (8-4) 과제: 과제의 주요 기능 | &emsp;Drive Guardian은 운전자의 부주의와 졸린 상태를 중점적으로 탐지합니다. 부주의는 흡연과 자리 이탈 탐지로 detect합니다. 흡연과 자리 이탈이 감지되면 그 즉시 경고 메시지 음성 안내를 하여 운전자의 주의력을 회복시킵니다. 졸린 상태는 눈 크기와 눈 깜박임과 하품으로 detect합니다. 이 세 가지의 항목을 multi-label classification으로 구현합니다. 졸린 상태로 판단되면 흥미로운 음성 안내나 주위의 휴게소를 안내하는 음성을 반복적으로 재생하도록 하여 운전자가 자신의 상태를 인지하고 극복할 수 있도록 도와줍니다. 위험 상태로 인식되면 계속해서 경고를 울려 운전자가 일단 졸음 상태에서 빠져나올 수 있도록 도와줍니다. |
| (8-5) 과제: 구현 방법 | &emsp;개발 툴로는 Android Studio를 바탕으로 CameraX 라이브러리와 안드로이드 sdk를 사용합니다. Android Studio에서 앱의 전반적인 작동과 프론트엔드를 구현합니다. 데이터베이스와 인증은 Firebase를 사용합니다. Android Studio에 AI 모델을 임베딩하기 위하여 OpenCV, OpenPose, Tensorflow 라이브러리를 불러와 사용합니다.<br>&emsp;부주의 단계의 detection은 object detection, pose estimation을 사용하고 졸린 상태의 detection은 object detection, landmark detection을 사용하며, 위험 단계는 pose estimation과 졸린 상태 탐지결과를 사용합니다. 이 과정에서 EAR 알고리즘과 EMA Smoothing 알고리즘을 사용합니다. 이 모든 detection을 하나로 묶어 부주의, 졸린 상태, 위험 상태 중 하나로 real time으로 탐지하는 multilabel classification을 최종적으로 구현합니다. 사용자가 얼굴을 운전 중에 카메라에 비추는 동안 모델이 구동되어 특정 상태가  detect 되면 각 단계에 맞는 알림 시스템을 취합니다. |
| (8-6) 과제: 세부 기술 | &emsp;부주의는 흡연과 자리 이탈 탐지로 detect합니다. 흡연은 Roboflow의 smoking dataset과 YOLOv5를 이용하여 하품을 탐지하도록 training했습니다. 그리고 자리 이탈은 Pose Estimation을 통해 탐지합니다. ML kit에서 제공하는 Pose Estimation 모델을 불러와 각각의 Landmark들을 표시하는 점을 이어 자세의 각도를 탐지하여 자리 이탈을 detect 합니다. 흡연과 자리 이탈이 감지되면 그 즉시 경고 메시지 음성 안내를 하여 운전자의 주의력을 회복시킵니다.<br>&emsp;졸린 상태는 눈 크기와 눈 깜박임과 하품으로 탐지합니다. 눈 크기와 눈 깜박임은 ML kit에서 제공하는 Landmark Detection 모델을 사용합니다. 운전자의 눈이 감기는 정도를 판단하기 위해 해당 모델을 사용합니다. 눈 크기 비율 계산은 EAR(eye aspect ratio) 공식을 따릅니다. 이를 이용해 실시간으로 탐지되는 눈 크기 비율과 그래프의 경향을 통해 졸린 상태를 판정하도록 합니다. Landmark detection 모델에 의해 얼굴에 Landmark point들이 그려지면 그 point들을 이용하여 눈의 경계에 사각형을 그리는 좌표값 함수와 눈 크기의 임계값을 의미하는 적절한 k를 이용하여 눈 깜박임을 탐지합니다. 깜박임은 이 사각형의 넓이가 k 일 때 count되는 방식으로 구현할 예정입니다. 마지막으로 하품 탐지는 Roboflow의 Drowsiness Dataset과 YOLOv5를 이용하여 하품을 탐지하도록 training했습니다. Real time으로 탐지해야 하는 만큼 가볍고 빠른 YOLO를 선택했고 버전 중 가장 가벼운 nano model을 선택했습니다. 이 세가지의 항목을 통합하여 졸린 상태 classification으로 구현합니다. 눈을 깜박이는 횟수가 증가하고 눈의 크기가 평소의 0.6 이하로 떨어지고 하품이 감지된다면 졸린 상태에 가까운 상태가 되었다고 판단합니다. 졸린 상태로 판단되면 흥미로운 음성 안내나 주위의 휴게소를 안내하는 음성을 반복적으로 재생하도록 하여 운전자가 자신의 상태를 인지하고 극복할 수 있도록 도와줍니다.<br>&emsp;졸린 상태가 일정 시간 내 3회 이상 detect 되어 위험 상태로 인식되면 계속해서 경고를 울려 운전자가 일단 졸음 상태에서 빠져나올 수 있도록 도와줍니다. 추가로 오탐을 방지하게 위해서 비정상적으로 깜박임이 잦은 경우에는 눈 깜박임이 m회 이상 과도하게 반복되면 무시하도록 설정합니다. 눈을 작게 뜨는 경우는 눈 깜박임 탐지 사각형의 k값이 일반적인 상황을 포괄할 수 있도록 설정합니다. |
| (8-7) 과제: 기대 효과 및 의의 | &emsp;Drive Guardian을 통하여 사용자는 운전 중에 졸거나, 운전에 집중하지 않는 상황을 방지하고, 미연의 사고의 가능성 또한 줄일 수 있을 것입니다. 고가의 장치를 구매하지 않아도 간단하게 앱을 설치하는 것만으로 모니터링이 가능하므로 쉽게 앱에 접근하여 안전하게 운전할 수 있게 됩니다. 또한 계속해서 모니터링되고 있다는 사실 자체로 운전자에게 경각심을 심어줄 수 있을 것입니다. |
| (9) 데모 내용 | 최종 데모<br><br>제목: Drive Guardian 의 부주의, 졸린 상태, 위험 상태 단계의 detection 및 alert 시연<br>데모 내용:<br>• 운전자로 가정된 시연자 1명의 얼굴 및 상체 일부가 휴대폰 카메라에 잡히도록 세팅한다.<br>• 사용자가 Drive Guardian에 회원가입 / 로그인한다.<br>• 사용자가 카메라 아이콘을 눌러 카메라 화면에 진입힌다.<br>• detect 버튼을 누르면 부주의(흡연, 전방 주시)/졸린(눈 크기, 눈 깜박임, 하품)/위험 상태에 대해 real-time 탐지가 시작된다.<br>• 사용자가 연이어 조수석 쪽으로 몸을 돌리면 부주의 상태에서 벗어나도록 하는 안내 메시지가 음성으로 출력된다.<br>• 사용자가 연이어 하품을 하면 졸린 상태에서 벗어나도록 하는 경고 메시지가 음성으로 출력된다.<br>• 사용자가 눈을 자주 깜빡이거나, 눈을 감은 상태가 지속되면 졸린 상태에서 벗어나도록 하는 경고 메시지가 음성으로 출력된다.<br>• 사용자가 고개를 숙이고 수면을 취하는 상태가 지속되면 위험 상태로 판단하여 긴급 알림을 출력한다. |
| (10) 기타 | 없음 |

 
[Return TOP](#list-of-teamsprojects)
 
